var By = (n, e, t) => {
  if (!e.has(n)) throw TypeError("Cannot " + t);
};
var re = (n, e, t) => (
    By(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  ct = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Je = (n, e, t, i) => (
    By(n, e, "write to private field"), i ? i.call(n, t) : e.set(n, t), t
  );
var xp = (n, e, t, i) => ({
    set _(r) {
      Je(n, e, r, t);
    },
    get _() {
      return re(n, e, i);
    },
  }),
  Ft = (n, e, t) => (By(n, e, "access private method"), t);
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
          ? (s.credentials = "omit")
          : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
var RI =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {};
function Wg(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var Mb = { exports: {} },
  jg = {},
  Eb = { exports: {} },
  zt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var lf = Symbol.for("react.element"),
  LI = Symbol.for("react.portal"),
  II = Symbol.for("react.fragment"),
  OI = Symbol.for("react.strict_mode"),
  NI = Symbol.for("react.profiler"),
  DI = Symbol.for("react.provider"),
  kI = Symbol.for("react.context"),
  UI = Symbol.for("react.forward_ref"),
  FI = Symbol.for("react.suspense"),
  BI = Symbol.for("react.memo"),
  zI = Symbol.for("react.lazy"),
  VM = Symbol.iterator;
function HI(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (VM && n[VM]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Tb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Cb = Object.assign,
  bb = {};
function Vc(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = bb),
    (this.updater = t || Tb);
}
Vc.prototype.isReactComponent = {};
Vc.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Vc.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Ab() {}
Ab.prototype = Vc.prototype;
function _S(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = bb),
    (this.updater = t || Tb);
}
var xS = (_S.prototype = new Ab());
xS.constructor = _S;
Cb(xS, Vc.prototype);
xS.isPureReactComponent = !0;
var GM = Array.isArray,
  Pb = Object.prototype.hasOwnProperty,
  SS = { current: null },
  Rb = { key: !0, ref: !0, __self: !0, __source: !0 };
function Lb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      Pb.call(e, i) && !Rb.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var u = Array(a), h = 0; h < a; h++) u[h] = arguments[h + 2];
    r.children = u;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: lf,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: SS.current,
  };
}
function VI(n, e) {
  return {
    $$typeof: lf,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function wS(n) {
  return typeof n == "object" && n !== null && n.$$typeof === lf;
}
function GI(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var WM = /\/+/g;
function zy(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? GI("" + n.key)
    : e.toString(36);
}
function km(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case lf:
          case LI:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + zy(o, 0) : i),
      GM(r)
        ? ((t = ""),
          n != null && (t = n.replace(WM, "$&/") + "/"),
          km(r, e, t, "", function (h) {
            return h;
          }))
        : r != null &&
          (wS(r) &&
            (r = VI(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(WM, "$&/") + "/") +
                n,
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), GM(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var u = i + zy(s, a);
      o += km(s, e, t, u, r);
    }
  else if (((u = HI(n)), typeof u == "function"))
    for (n = u.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (u = i + zy(s, a++)), (o += km(s, e, t, u, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead.",
      ))
    );
  return o;
}
function Sp(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    km(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function WI(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        },
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var Bi = { current: null },
  Um = { transition: null },
  jI = {
    ReactCurrentDispatcher: Bi,
    ReactCurrentBatchConfig: Um,
    ReactCurrentOwner: SS,
  };
zt.Children = {
  map: Sp,
  forEach: function (n, e, t) {
    Sp(
      n,
      function () {
        e.apply(this, arguments);
      },
      t,
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Sp(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Sp(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!wS(n))
      throw Error(
        "React.Children.only expected to receive a single React element child.",
      );
    return n;
  },
};
zt.Component = Vc;
zt.Fragment = II;
zt.Profiler = NI;
zt.PureComponent = _S;
zt.StrictMode = OI;
zt.Suspense = FI;
zt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jI;
zt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        ".",
    );
  var i = Cb({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = SS.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (u in e)
      Pb.call(e, u) &&
        !Rb.hasOwnProperty(u) &&
        (i[u] = e[u] === void 0 && a !== void 0 ? a[u] : e[u]);
  }
  var u = arguments.length - 2;
  if (u === 1) i.children = t;
  else if (1 < u) {
    a = Array(u);
    for (var h = 0; h < u; h++) a[h] = arguments[h + 2];
    i.children = a;
  }
  return { $$typeof: lf, type: n.type, key: r, ref: s, props: i, _owner: o };
};
zt.createContext = function (n) {
  return (
    (n = {
      $$typeof: kI,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: DI, _context: n }),
    (n.Consumer = n)
  );
};
zt.createElement = Lb;
zt.createFactory = function (n) {
  var e = Lb.bind(null, n);
  return (e.type = n), e;
};
zt.createRef = function () {
  return { current: null };
};
zt.forwardRef = function (n) {
  return { $$typeof: UI, render: n };
};
zt.isValidElement = wS;
zt.lazy = function (n) {
  return { $$typeof: zI, _payload: { _status: -1, _result: n }, _init: WI };
};
zt.memo = function (n, e) {
  return { $$typeof: BI, type: n, compare: e === void 0 ? null : e };
};
zt.startTransition = function (n) {
  var e = Um.transition;
  Um.transition = {};
  try {
    n();
  } finally {
    Um.transition = e;
  }
};
zt.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
zt.useCallback = function (n, e) {
  return Bi.current.useCallback(n, e);
};
zt.useContext = function (n) {
  return Bi.current.useContext(n);
};
zt.useDebugValue = function () {};
zt.useDeferredValue = function (n) {
  return Bi.current.useDeferredValue(n);
};
zt.useEffect = function (n, e) {
  return Bi.current.useEffect(n, e);
};
zt.useId = function () {
  return Bi.current.useId();
};
zt.useImperativeHandle = function (n, e, t) {
  return Bi.current.useImperativeHandle(n, e, t);
};
zt.useInsertionEffect = function (n, e) {
  return Bi.current.useInsertionEffect(n, e);
};
zt.useLayoutEffect = function (n, e) {
  return Bi.current.useLayoutEffect(n, e);
};
zt.useMemo = function (n, e) {
  return Bi.current.useMemo(n, e);
};
zt.useReducer = function (n, e, t) {
  return Bi.current.useReducer(n, e, t);
};
zt.useRef = function (n) {
  return Bi.current.useRef(n);
};
zt.useState = function (n) {
  return Bi.current.useState(n);
};
zt.useSyncExternalStore = function (n, e, t) {
  return Bi.current.useSyncExternalStore(n, e, t);
};
zt.useTransition = function () {
  return Bi.current.useTransition();
};
zt.version = "18.2.0";
Eb.exports = zt;
var se = Eb.exports;
const Ib = Wg(se);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var XI = se,
  qI = Symbol.for("react.element"),
  $I = Symbol.for("react.fragment"),
  YI = Object.prototype.hasOwnProperty,
  KI = XI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  QI = { key: !0, ref: !0, __self: !0, __source: !0 };
function Ob(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) YI.call(e, i) && !QI.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: qI,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: KI.current,
  };
}
jg.Fragment = $I;
jg.jsx = Ob;
jg.jsxs = Ob;
Mb.exports = jg;
var ce = Mb.exports;
const jM = "pushstate",
  XM = "popstate",
  Nb = "beforeunload",
  Db = (n) => (n.preventDefault(), (n.returnValue = "")),
  ZI = () => {
    removeEventListener(Nb, Db, { capture: !0 });
  };
function kb(n) {
  let e = n.getLocation(),
    t = new Set(),
    i = [];
  const r = () => {
      (e = n.getLocation()), t.forEach((o) => o());
    },
    s = async (o) => {
      var a;
      if (typeof document < "u" && i.length) {
        for (let u of i)
          if (!(await u())) {
            (a = n.onBlocked) == null || a.call(n, r);
            return;
          }
      }
      o();
    };
  return {
    get location() {
      return e;
    },
    subscribe: (o) => (
      t.add(o),
      () => {
        t.delete(o);
      }
    ),
    push: (o, a) => {
      (a = qM(a)),
        s(() => {
          n.pushState(o, a), r();
        });
    },
    replace: (o, a) => {
      (a = qM(a)),
        s(() => {
          n.replaceState(o, a), r();
        });
    },
    go: (o) => {
      s(() => {
        n.go(o);
      });
    },
    back: () => {
      s(() => {
        n.back();
      });
    },
    forward: () => {
      s(() => {
        n.forward();
      });
    },
    createHref: (o) => n.createHref(o),
    block: (o) => (
      i.push(o),
      i.length === 1 && addEventListener(Nb, Db, { capture: !0 }),
      () => {
        (i = i.filter((a) => a !== o)), i.length || ZI();
      }
    ),
    flush: () => {
      var o;
      return (o = n.flush) == null ? void 0 : o.call(n);
    },
    destroy: () => {
      var o;
      return (o = n.destroy) == null ? void 0 : o.call(n);
    },
    notify: r,
  };
}
function qM(n) {
  return n || (n = {}), { ...n, key: Ub() };
}
function JI(n) {
  const e =
      (n == null ? void 0 : n.window) ??
      (typeof document < "u" ? window : void 0),
    t = (n == null ? void 0 : n.createHref) ?? ((d) => d),
    i =
      (n == null ? void 0 : n.parseLocation) ??
      (() =>
        g_(
          `${e.location.pathname}${e.location.search}${e.location.hash}`,
          e.history.state,
        ));
  let r = i(),
    s;
  const o = () => r;
  let a,
    u = !0,
    h;
  const p = (d) => {
      (u = !1), d(), (u = !0);
    },
    v = () => {
      p(() => {
        a &&
          (e.history[a.isPush ? "pushState" : "replaceState"](
            a.state,
            "",
            a.href,
          ),
          (a = void 0),
          (h = void 0),
          (s = void 0));
      });
    },
    y = (d, m, g) => {
      const w = t(m);
      h || (s = r),
        (r = g_(m, g)),
        (a = {
          href: w,
          state: g,
          isPush: (a == null ? void 0 : a.isPush) || d === "push",
        }),
        h || (h = Promise.resolve().then(() => v()));
    },
    S = () => {
      (r = i()), f.notify();
    };
  var x = e.history.pushState,
    _ = e.history.replaceState;
  const f = kb({
    getLocation: o,
    pushState: (d, m) => y("push", d, m),
    replaceState: (d, m) => y("replace", d, m),
    back: () => e.history.back(),
    forward: () => e.history.forward(),
    go: (d) => e.history.go(d),
    createHref: (d) => t(d),
    flush: v,
    destroy: () => {
      (e.history.pushState = x),
        (e.history.replaceState = _),
        e.removeEventListener(jM, S),
        e.removeEventListener(XM, S);
    },
    onBlocked: (d) => {
      s && r !== s && ((r = s), d());
    },
  });
  return (
    e.addEventListener(jM, S),
    e.addEventListener(XM, S),
    (e.history.pushState = function () {
      let d = x.apply(e.history, arguments);
      return u && f.notify(), d;
    }),
    (e.history.replaceState = function () {
      let d = _.apply(e.history, arguments);
      return u && f.notify(), d;
    }),
    f
  );
}
function e3(n = { initialEntries: ["/"] }) {
  const e = n.initialEntries;
  let t = n.initialIndex ?? e.length - 1,
    i = { key: Ub() };
  return kb({
    getLocation: () => g_(e[t], i),
    pushState: (s, o) => {
      (i = o), e.push(s), t++;
    },
    replaceState: (s, o) => {
      (i = o), (e[t] = s);
    },
    back: () => {
      t--;
    },
    forward: () => {
      t = Math.min(t + 1, e.length - 1);
    },
    go: (s) => {
      t = Math.min(Math.max(t + s, 0), e.length - 1);
    },
    createHref: (s) => s,
  });
}
function g_(n, e) {
  let t = n.indexOf("#"),
    i = n.indexOf("?");
  return {
    href: n,
    pathname: n.substring(
      0,
      t > 0 ? (i > 0 ? Math.min(t, i) : t) : i > 0 ? i : n.length,
    ),
    hash: t > -1 ? n.substring(t) : "",
    search: i > -1 ? n.slice(i, t === -1 ? void 0 : t) : "",
    state: e || {},
  };
}
function Ub() {
  return (Math.random() + 1).toString(36).substring(7);
}
var t3 = !0,
  Hy = "Invariant failed";
function cr(n, e) {
  if (!n) {
    if (t3) throw new Error(Hy);
    var t = typeof e == "function" ? e() : e,
      i = t ? "".concat(Hy, ": ").concat(t) : Hy;
    throw new Error(i);
  }
}
function MS(n) {
  const e = n.errorComponent ?? ES;
  return ce.jsx(n3, {
    getResetKey: n.getResetKey,
    onCatch: n.onCatch,
    children: ({ error: t }) =>
      t ? se.createElement(e, { error: t }) : n.children,
  });
}
class n3 extends se.Component {
  constructor() {
    super(...arguments), (this.state = { error: null });
  }
  static getDerivedStateFromProps(e) {
    var t;
    return { resetKey: (t = e.getResetKey) == null ? void 0 : t.call(e) };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  componentDidUpdate(e, t) {
    t.error &&
      t.resetKey !== this.state.resetKey &&
      this.setState({ error: null });
  }
  componentDidCatch(e) {
    var t, i;
    this.props.onCatch
      ? (i = (t = this.props).onCatch) == null || i.call(t, e)
      : console.error(e);
  }
  render() {
    return this.props.children(this.state);
  }
}
function ES({ error: n }) {
  const [e, t] = se.useState(!1);
  return ce.jsxs("div", {
    style: { padding: ".5rem", maxWidth: "100%" },
    children: [
      ce.jsxs("div", {
        style: { display: "flex", alignItems: "center", gap: ".5rem" },
        children: [
          ce.jsx("strong", {
            style: { fontSize: "1rem" },
            children: "Something went wrong!",
          }),
          ce.jsx("button", {
            style: {
              appearance: "none",
              fontSize: ".6em",
              border: "1px solid currentColor",
              padding: ".1rem .2rem",
              fontWeight: "bold",
              borderRadius: ".25rem",
            },
            onClick: () => t((i) => !i),
            children: e ? "Hide Error" : "Show Error",
          }),
        ],
      }),
      ce.jsx("div", { style: { height: ".25rem" } }),
      e
        ? ce.jsx("div", {
            children: ce.jsx("pre", {
              style: {
                fontSize: ".7em",
                border: "1px solid red",
                borderRadius: ".25rem",
                padding: ".3rem",
                color: "red",
                overflow: "auto",
              },
              children: n.message
                ? ce.jsx("code", { children: n.message })
                : null,
            }),
          })
        : null,
    ],
  });
}
var Fb = { exports: {} },
  Bb = {},
  zb = { exports: {} },
  Hb = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bc = se;
function i3(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var r3 = typeof Object.is == "function" ? Object.is : i3,
  s3 = bc.useState,
  o3 = bc.useEffect,
  a3 = bc.useLayoutEffect,
  l3 = bc.useDebugValue;
function u3(n, e) {
  var t = e(),
    i = s3({ inst: { value: t, getSnapshot: e } }),
    r = i[0].inst,
    s = i[1];
  return (
    a3(
      function () {
        (r.value = t), (r.getSnapshot = e), Vy(r) && s({ inst: r });
      },
      [n, t, e],
    ),
    o3(
      function () {
        return (
          Vy(r) && s({ inst: r }),
          n(function () {
            Vy(r) && s({ inst: r });
          })
        );
      },
      [n],
    ),
    l3(t),
    t
  );
}
function Vy(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !r3(n, t);
  } catch {
    return !0;
  }
}
function c3(n, e) {
  return e();
}
var d3 =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? c3
    : u3;
Hb.useSyncExternalStore =
  bc.useSyncExternalStore !== void 0 ? bc.useSyncExternalStore : d3;
zb.exports = Hb;
var h3 = zb.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Xg = se,
  f3 = h3;
function p3(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var m3 = typeof Object.is == "function" ? Object.is : p3,
  g3 = f3.useSyncExternalStore,
  v3 = Xg.useRef,
  y3 = Xg.useEffect,
  _3 = Xg.useMemo,
  x3 = Xg.useDebugValue;
Bb.useSyncExternalStoreWithSelector = function (n, e, t, i, r) {
  var s = v3(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = _3(
    function () {
      function u(S) {
        if (!h) {
          if (((h = !0), (p = S), (S = i(S)), r !== void 0 && o.hasValue)) {
            var x = o.value;
            if (r(x, S)) return (v = x);
          }
          return (v = S);
        }
        if (((x = v), m3(p, S))) return x;
        var _ = i(S);
        return r !== void 0 && r(x, _) ? x : ((p = S), (v = _));
      }
      var h = !1,
        p,
        v,
        y = t === void 0 ? null : t;
      return [
        function () {
          return u(e());
        },
        y === null
          ? void 0
          : function () {
              return u(y());
            },
      ];
    },
    [e, t, i, r],
  );
  var a = g3(n, s[0], s[1]);
  return (
    y3(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a],
    ),
    x3(a),
    a
  );
};
Fb.exports = Bb;
var S3 = Fb.exports,
  w3 = class {
    constructor(n, e) {
      (this.listeners = new Set()),
        (this._batching = !1),
        (this._flushing = 0),
        (this._nextPriority = null),
        (this.subscribe = (t) => {
          var r, s;
          this.listeners.add(t);
          const i =
            (s = (r = this.options) == null ? void 0 : r.onSubscribe) == null
              ? void 0
              : s.call(r, t, this);
          return () => {
            this.listeners.delete(t), i == null || i();
          };
        }),
        (this.setState = (t, i) => {
          var o, a, u, h, p;
          const r = this.state;
          this.state =
            (o = this.options) != null && o.updateFn
              ? this.options.updateFn(r)(t)
              : t(r);
          const s =
            (i == null ? void 0 : i.priority) ??
            ((a = this.options) == null ? void 0 : a.defaultPriority) ??
            "high";
          this._nextPriority === null
            ? (this._nextPriority = s)
            : this._nextPriority === "high"
              ? (this._nextPriority = s)
              : (this._nextPriority =
                  ((u = this.options) == null ? void 0 : u.defaultPriority) ??
                  "high"),
            (p = (h = this.options) == null ? void 0 : h.onUpdate) == null ||
              p.call(h, { priority: this._nextPriority }),
            this._flush();
        }),
        (this._flush = () => {
          if (this._batching) return;
          const t = ++this._flushing;
          this.listeners.forEach((i) => {
            this._flushing === t &&
              i({ priority: this._nextPriority ?? "high" });
          });
        }),
        (this.batch = (t) => {
          if (this._batching) return t();
          (this._batching = !0), t(), (this._batching = !1), this._flush();
        }),
        (this.state = n),
        (this.options = e);
    }
  };
function M3(n, e = (t) => t) {
  return S3.useSyncExternalStoreWithSelector(
    n.subscribe,
    () => n.state,
    () => n.state,
    e,
    E3,
  );
}
function E3(n, e) {
  if (Object.is(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(n);
  if (t.length !== Object.keys(e).length) return !1;
  for (let i = 0; i < t.length; i++)
    if (
      !Object.prototype.hasOwnProperty.call(e, t[i]) ||
      !Object.is(n[t[i]], e[t[i]])
    )
      return !1;
  return !0;
}
let Gy = se.createContext(null);
function Vb() {
  return typeof document > "u"
    ? Gy
    : window.__TSR_ROUTER_CONTEXT__
      ? window.__TSR_ROUTER_CONTEXT__
      : ((window.__TSR_ROUTER_CONTEXT__ = Gy), Gy);
}
function Ca(n) {
  const e = se.useContext(Vb());
  return n == null || n.warn, e;
}
function vr(n) {
  const e = Ca({ warn: (n == null ? void 0 : n.router) === void 0 });
  return M3(
    ((n == null ? void 0 : n.router) || e).__store,
    n == null ? void 0 : n.select,
  );
}
function TS(n) {
  return n[n.length - 1];
}
function T3(n) {
  return typeof n == "function";
}
function zu(n, e) {
  return T3(n) ? n(e) : n;
}
function Gd(n, e) {
  return e.reduce((t, i) => ((t[i] = n[i]), t), {});
}
function jo(n, e) {
  if (n === e) return n;
  const t = e,
    i = YM(n) && YM(t);
  if (i || (ag(n) && ag(t))) {
    const r = i ? n : Object.keys(n),
      s = r.length,
      o = i ? t : Object.keys(t),
      a = o.length,
      u = i ? [] : {};
    let h = 0;
    for (let p = 0; p < a; p++) {
      const v = i ? p : o[p];
      !i && n[v] === void 0 && t[v] === void 0 && r.includes(v)
        ? ((u[v] = void 0), h++)
        : ((u[v] = jo(n[v], t[v])), u[v] === n[v] && n[v] !== void 0 && h++);
    }
    return s === a && h === s ? n : u;
  }
  return t;
}
function ag(n) {
  if (!$M(n)) return !1;
  const e = n.constructor;
  if (typeof e > "u") return !0;
  const t = e.prototype;
  return !(!$M(t) || !t.hasOwnProperty("isPrototypeOf"));
}
function $M(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function YM(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function oh(n, e, t = !1) {
  if (n === e) return !0;
  if (typeof n != typeof e) return !1;
  if (ag(n) && ag(e)) {
    const i = Object.keys(n),
      r = Object.keys(e);
    return !t && i.length !== r.length
      ? !1
      : !r.some((s) => !(s in n) || !oh(n[s], e[s], t));
  }
  return Array.isArray(n) && Array.isArray(e)
    ? !n.some((i, r) => !oh(i, e[r], t))
    : !1;
}
const Wy = typeof window < "u" ? se.useLayoutEffect : se.useEffect;
function C3(n) {
  return n.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"');
}
function ua(n) {
  return qg(n.filter(Boolean).join("/"));
}
function qg(n) {
  return n.replace(/\/{2,}/g, "/");
}
function CS(n) {
  return n === "/" ? n : n.replace(/^\/{1,}/, "");
}
function Fm(n) {
  return n === "/" ? n : n.replace(/\/{1,}$/, "");
}
function b3(n) {
  return Fm(CS(n));
}
function A3(n, e, t) {
  (e = e.replace(new RegExp(`^${n}`), "/")),
    (t = t.replace(new RegExp(`^${n}`), "/"));
  let i = Ac(e);
  const r = Ac(t);
  r.forEach((o, a) => {
    var u;
    if (o.value === "/") a ? a === r.length - 1 && i.push(o) : (i = [o]);
    else if (o.value === "..")
      i.length > 1 &&
        ((u = TS(i)) == null ? void 0 : u.value) === "/" &&
        i.pop(),
        i.pop();
    else {
      if (o.value === ".") return;
      i.push(o);
    }
  });
  const s = ua([n, ...i.map((o) => o.value)]);
  return qg(s);
}
function Ac(n) {
  if (!n) return [];
  n = qg(n);
  const e = [];
  if (
    (n.slice(0, 1) === "/" &&
      ((n = n.substring(1)), e.push({ type: "pathname", value: "/" })),
    !n)
  )
    return e;
  const t = n.split("/").filter(Boolean);
  return (
    e.push(
      ...t.map((i) =>
        i === "$" || i === "*"
          ? { type: "wildcard", value: i }
          : i.charAt(0) === "$"
            ? { type: "param", value: i }
            : { type: "pathname", value: i },
      ),
    ),
    n.slice(-1) === "/" &&
      ((n = n.substring(1)), e.push({ type: "pathname", value: "/" })),
    e
  );
}
function jy({ path: n, params: e, leaveWildcards: t, leaveParams: i }) {
  const r = Ac(n);
  return ua(
    r.map((s) => {
      if (s.type === "wildcard") {
        const o = e[s.value];
        return t ? `${s.value}${o ?? ""}` : o;
      }
      if (s.type === "param") {
        if (i) {
          const o = e[s.value];
          return `${s.value}${o ?? ""}`;
        }
        return e[s.value.substring(1)] ?? "undefined";
      }
      return s.value;
    }),
  );
}
function Xy(n, e, t) {
  const i = R3(n, e, t);
  if (!(t.to && !i)) return i ?? {};
}
function P3(n, e) {
  return n != "/" ? e.substring(n.length) : e;
}
function R3(n, e, t) {
  e = P3(n, e);
  const i = `${t.to ?? "$"}`,
    r = Ac(e),
    s = Ac(i);
  e.startsWith("/") || r.unshift({ type: "pathname", value: "/" }),
    i.startsWith("/") || s.unshift({ type: "pathname", value: "/" });
  const o = {};
  return (() => {
    for (let u = 0; u < Math.max(r.length, s.length); u++) {
      const h = r[u],
        p = s[u],
        v = u >= r.length - 1,
        y = u >= s.length - 1;
      if (p) {
        if (p.type === "wildcard") {
          if (h != null && h.value) {
            const S = decodeURI(ua(r.slice(u).map((x) => x.value)));
            return (o["*"] = S), (o._splat = S), !0;
          }
          return !1;
        }
        if (p.type === "pathname") {
          if (p.value === "/" && !(h != null && h.value)) return !0;
          if (h) {
            if (t.caseSensitive) {
              if (p.value !== h.value) return !1;
            } else if (p.value.toLowerCase() !== h.value.toLowerCase())
              return !1;
          }
        }
        if (!h) return !1;
        if (p.type === "param") {
          if ((h == null ? void 0 : h.value) === "/") return !1;
          h.value.charAt(0) !== "$" &&
            (o[p.value.substring(1)] = decodeURI(h.value));
        }
      }
      if (!v && y)
        return (
          (o["**"] = ua(r.slice(u + 1).map((S) => S.value))),
          !!t.fuzzy && (p == null ? void 0 : p.value) !== "/"
        );
    }
    return !0;
  })()
    ? o
    : void 0;
}
function L3(n) {
  return vr({
    select: (e) => {
      var t;
      const i = (t = TS(ao(e))) == null ? void 0 : t.params;
      return n != null && n.select ? n.select(i) : i;
    },
  });
}
function I3(n) {
  return Dl({
    ...n,
    select: (e) => (n != null && n.select ? n.select(e.search) : e.search),
  });
}
function Wd(n) {
  return !!(n != null && n.isNotFound);
}
function O3(n) {
  const e = vr({
    select: (t) => `not-found-${t.location.pathname}-${t.status}`,
  });
  return ce.jsx(MS, {
    getResetKey: () => e,
    onCatch: (t) => {
      var i;
      if (Wd(t)) (i = n.onCatch) == null || i.call(n, t);
      else throw t;
    },
    errorComponent: ({ error: t }) => {
      var i;
      return (i = n.fallback) == null ? void 0 : i.call(n, t);
    },
    children: n.children,
  });
}
function N3() {
  return ce.jsx("p", { children: "Not Found" });
}
const kr = "__root__";
let Gb = class {
  constructor(e) {
    (this.init = (t) => {
      var i, r;
      this.originalIndex = t.originalIndex;
      const s = this.options,
        o = !(s != null && s.path) && !(s != null && s.id);
      (this.parentRoute =
        (r = (i = this.options) == null ? void 0 : i.getParentRoute) == null
          ? void 0
          : r.call(i)),
        o
          ? (this.path = kr)
          : cr(
              this.parentRoute,
              "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.",
            );
      let a = o ? kr : s.path;
      a && a !== "/" && (a = CS(a));
      const u = (s == null ? void 0 : s.id) || a;
      let h = o
        ? kr
        : ua([this.parentRoute.id === kr ? "" : this.parentRoute.id, u]);
      a === kr && (a = "/"), h !== kr && (h = ua(["/", h]));
      const p = h === kr ? "/" : ua([this.parentRoute.fullPath, a]);
      (this.path = a), (this.id = h), (this.fullPath = p), (this.to = p);
    }),
      (this.addChildren = (t) => ((this.children = t), this)),
      (this.updateLoader = (t) => (Object.assign(this.options, t), this)),
      (this.update = (t) => (Object.assign(this.options, t), this)),
      (this.lazy = (t) => ((this.lazyFn = t), this)),
      (this.useMatch = (t) => Dl({ ...t, from: this.id })),
      (this.useRouteContext = (t) =>
        Dl({
          ...t,
          from: this.id,
          select: (i) =>
            t != null && t.select ? t.select(i.context) : i.context,
        })),
      (this.useSearch = (t) => I3({ ...t, from: this.id })),
      (this.useParams = (t) => L3({ ...t, from: this.id })),
      (this.useLoaderDeps = (t) => B3({ ...t, from: this.id })),
      (this.useLoaderData = (t) => z3({ ...t, from: this.id })),
      (this.options = e || {}),
      (this.isRoot = !(e != null && e.getParentRoute)),
      cr(
        !(e != null && e.id && e != null && e.path),
        "Route cannot have both an 'id' and a 'path' option.",
      ),
      (this.$$typeof = Symbol.for("react.memo"));
  }
};
function D3(n) {
  return new Gb(n);
}
class k3 extends Gb {
  constructor(e) {
    super(e);
  }
}
function U3(n) {
  return new k3(n);
}
const $g = se.createContext(void 0);
function KM() {
  const n = Ca(),
    e = vr({
      select: (t) => {
        var i;
        return (i = ao(t)[0]) == null ? void 0 : i.id;
      },
    });
  return ce.jsx($g.Provider, {
    value: e,
    children: ce.jsx(MS, {
      getResetKey: () => {
        var t;
        return (t = n.state.resolvedLocation.state) == null ? void 0 : t.key;
      },
      errorComponent: ES,
      onCatch: (t) => {
        console.error(t);
      },
      children: e ? ce.jsx(Wb, { matchId: e }) : null,
    }),
  });
}
function qy(n) {
  return ce.jsx(ce.Fragment, { children: n.children });
}
function Wb({ matchId: n }) {
  var e, t, i, r;
  const s = Ca(),
    o = vr({
      select: (_) => {
        var f;
        return (f = ao(_).find((d) => d.id === n)) == null ? void 0 : f.routeId;
      },
    });
  cr(o, `Could not find routeId for matchId "${n}". Please file an issue!`);
  const a = s.routesById[o],
    u = a.options.pendingComponent ?? s.options.defaultPendingComponent,
    h = u ? ce.jsx(u, {}) : null,
    p = a.options.errorComponent ?? s.options.defaultErrorComponent ?? ES,
    v = a.isRoot
      ? a.options.notFoundComponent ??
        ((e = s.options.notFoundRoute) == null ? void 0 : e.options.component)
      : a.options.notFoundComponent,
    y =
      a.options.wrapInSuspense ??
      u ??
      ((t = a.options.component) == null ? void 0 : t.preload) ??
      ((i = a.options.pendingComponent) == null ? void 0 : i.preload) ??
      ((r = a.options.errorComponent) == null ? void 0 : r.preload)
        ? se.Suspense
        : qy,
    S = p ? MS : qy,
    x = v ? O3 : qy;
  return ce.jsx($g.Provider, {
    value: n,
    children: ce.jsx(y, {
      fallback: h,
      children: ce.jsx(S, {
        getResetKey: () => {
          var _;
          return (_ = s.state.resolvedLocation.state) == null ? void 0 : _.key;
        },
        errorComponent: p,
        onCatch: (_) => {
          if (Wd(_)) throw _;
          console.error(_);
        },
        children: ce.jsx(x, {
          fallback: (_) => {
            if (!v || (_.global && !a.isRoot)) throw _;
            return se.createElement(v, { data: _.data });
          },
          children: ce.jsx(F3, { matchId: n, pendingElement: h }),
        }),
      }),
    }),
  });
}
function F3({ matchId: n, pendingElement: e }) {
  var t;
  const i = Ca(),
    r = vr({
      select: (a) => {
        var u;
        return (u = ao(a).find((h) => h.id === n)) == null ? void 0 : u.routeId;
      },
    }),
    s = i.routesById[r],
    { match: o } = vr({
      select: (a) => ({
        match: Gd(
          ao(a).find((u) => u.id === n),
          ["status", "error", "showPending", "loadPromise", "notFoundError"],
        ),
      }),
    });
  if (o.notFoundError)
    return r === kr && !s.options.notFoundComponent
      ? ce.jsx(N3, {})
      : (cr(
          s.options.notFoundComponent,
          "Route matched with notFoundError should have a notFoundComponent",
        ),
        ce.jsx(s.options.notFoundComponent, { data: o.notFoundError }));
  if (o.status === "error")
    throw H3(o.error)
      ? (
          ((t = i.options.errorSerializer) == null ? void 0 : t.deserialize) ??
          V3
        )(o.error.data)
      : o.error;
  if (o.status === "pending") {
    if (o.showPending) return e;
    throw o.loadPromise;
  }
  if (o.status === "success") {
    let a = s.options.component ?? i.options.defaultComponent;
    return a ? ce.jsx(a, {}) : ce.jsx(jb, {});
  }
  cr(
    !1,
    "Idle routeMatch status encountered during rendering! You should never see this. File an issue!",
  );
}
const jb = se.memo(function () {
  const e = se.useContext($g),
    t = vr({
      select: (i) => {
        var r;
        const s = ao(i),
          o = s.findIndex((a) => a.id === e);
        return (r = s[o + 1]) == null ? void 0 : r.id;
      },
    });
  return t ? ce.jsx(Wb, { matchId: t }) : null;
});
function ao(n) {
  var e;
  return (e = n.pendingMatches) != null && e.some((t) => t.showPending)
    ? n.pendingMatches
    : n.matches;
}
function Dl(n) {
  var e;
  const t = Ca(),
    i = se.useContext($g),
    r = (e = ao(t.state).find((a) => a.id === i)) == null ? void 0 : e.routeId,
    s = (() => {
      const a = ao(t.state);
      return (
        n != null && n.from
          ? a.find((h) => h.routeId === (n == null ? void 0 : n.from))
          : a.find((h) => h.id === i)
      ).routeId;
    })();
  return (
    ((n == null ? void 0 : n.strict) ?? !0) &&
      cr(
        r == s,
        `useMatch("${s}") is being called in a component that is meant to render the '${r}' route. Did you mean to 'useMatch("${s}", { strict: false })' or 'useRoute("${s}")' instead?`,
      ),
    vr({
      select: (a) => {
        const u = ao(a).find((h) => h.id === i);
        return (
          cr(
            u,
            `Could not find ${n != null && n.from ? `an active match from "${n.from}"` : "a nearest match!"}`,
          ),
          n != null && n.select ? n.select(u) : u
        );
      },
    })
  );
}
function B3(n) {
  return Dl({
    ...n,
    select: (e) =>
      typeof n.select == "function"
        ? n.select(e == null ? void 0 : e.loaderDeps)
        : e == null
          ? void 0
          : e.loaderDeps,
  });
}
function z3(n) {
  return Dl({
    ...n,
    select: (e) =>
      typeof n.select == "function"
        ? n.select(e == null ? void 0 : e.loaderData)
        : e == null
          ? void 0
          : e.loaderData,
  });
}
function H3(n) {
  return !(typeof n == "object" && n && "data" in n) ||
    !("__isServerError" in n && n.__isServerError) ||
    !(typeof n.data == "object" && n.data)
    ? !1
    : n.__isServerError === !0;
}
function V3(n) {
  if ("name" in n && "message" in n) {
    const e = new Error(n.message);
    return (e.name = n.name), e;
  }
  return n.data;
}
function G3(n, e) {
  var t,
    i,
    r,
    s = "";
  for (t in n)
    if ((r = n[t]) !== void 0)
      if (Array.isArray(r))
        for (i = 0; i < r.length; i++)
          s && (s += "&"),
            (s += encodeURIComponent(t) + "=" + encodeURIComponent(r[i]));
      else
        s && (s += "&"),
          (s += encodeURIComponent(t) + "=" + encodeURIComponent(r));
  return (e || "") + s;
}
function QM(n) {
  if (!n) return "";
  var e = decodeURIComponent(n);
  return e === "false"
    ? !1
    : e === "true"
      ? !0
      : +e * 0 === 0 && +e + "" === e
        ? +e
        : e;
}
function W3(n) {
  for (var e, t, i = {}, r = n.split("&"); (e = r.shift()); )
    (e = e.split("=")),
      (t = e.shift()),
      i[t] !== void 0
        ? (i[t] = [].concat(i[t], QM(e.shift())))
        : (i[t] = QM(e.shift()));
  return i;
}
const j3 = q3(JSON.parse),
  X3 = $3(JSON.stringify, JSON.parse);
function q3(n) {
  return (e) => {
    e.substring(0, 1) === "?" && (e = e.substring(1));
    let t = W3(e);
    for (let i in t) {
      const r = t[i];
      if (typeof r == "string")
        try {
          t[i] = n(r);
        } catch {}
    }
    return t;
  };
}
function $3(n, e) {
  function t(i) {
    if (typeof i == "object" && i !== null)
      try {
        return n(i);
      } catch {}
    else if (typeof i == "string" && typeof e == "function")
      try {
        return e(i), n(i);
      } catch {}
    return i;
  }
  return (i) => {
    (i = { ...i }),
      i &&
        Object.keys(i).forEach((s) => {
          const o = i[s];
          typeof o > "u" || o === void 0 ? delete i[s] : (i[s] = t(o));
        });
    const r = G3(i).toString();
    return r ? `?${r}` : "";
  };
}
const Y3 =
  se.useTransition ||
  (() => [
    !1,
    (n) => {
      n();
    },
  ]);
function K3({ router: n, ...e }) {
  n.update({
    ...n.options,
    ...e,
    context: { ...n.options.context, ...(e == null ? void 0 : e.context) },
  });
  const t = n.options.InnerWrap
      ? ce.jsx(n.options.InnerWrap, { children: ce.jsx(KM, {}) })
      : ce.jsx(KM, {}),
    i = Vb(),
    r = ce.jsxs(i.Provider, { value: n, children: [t, ce.jsx(Q3, {})] });
  return n.options.Wrap ? ce.jsx(n.options.Wrap, { children: r }) : r;
}
function Q3() {
  const n = Ca(),
    e = se.useRef({ router: n, mounted: !1 }),
    t = vr({
      select: (o) =>
        Gd(o, ["isLoading", "location", "resolvedLocation", "isTransitioning"]),
    }),
    [i, r] = Y3();
  (n.startReactTransition = r),
    se.useEffect(() => {
      i && n.__store.setState((o) => ({ ...o, isTransitioning: i }));
    }, [i]);
  const s = () => {
    ((a) => {
      t.isTransitioning ? a() : r(() => a());
    })(() => {
      try {
        n.load();
      } catch (a) {
        console.error(a);
      }
    });
  };
  return (
    Wy(() => {
      const o = n.history.subscribe(() => {
          (n.latestLocation = n.parseLocation(n.latestLocation)),
            t.location !== n.latestLocation && s();
        }),
        a = n.buildLocation({ search: !0, params: !0, hash: !0, state: !0 });
      return (
        t.location.href !== a.href && n.commitLocation({ ...a, replace: !0 }),
        () => {
          o();
        }
      );
    }, [n.history]),
    Wy(() => {
      var o;
      if (
        se.useTransition
          ? t.isTransitioning && !i
          : !t.isLoading && t.resolvedLocation !== t.location
      ) {
        if (
          (n.emit({
            type: "onResolved",
            fromLocation: t.resolvedLocation,
            toLocation: t.location,
            pathChanged:
              t.location.href !==
              ((o = t.resolvedLocation) == null ? void 0 : o.href),
          }),
          document.querySelector && t.location.hash !== "")
        ) {
          const a = document.getElementById(t.location.hash);
          a && a.scrollIntoView();
        }
        n.__store.setState((a) => ({
          ...a,
          isTransitioning: !1,
          resolvedLocation: a.location,
        }));
      }
    }, [t.isTransitioning, i, t.isLoading, t.resolvedLocation, t.location]),
    Wy(() => {
      window.__TSR_DEHYDRATED__ ||
        (e.current.router === n && e.current.mounted) ||
        ((e.current = { router: n, mounted: !0 }), s());
    }, [n]),
    null
  );
}
function $y(n, e) {
  return [...n.cachedMatches, ...(n.pendingMatches ?? []), ...n.matches].find(
    (t) => t.id === e,
  );
}
function fu(n) {
  return !!(n != null && n.isRedirect);
}
const Z3 = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent",
];
function J3(n) {
  return new eO(n);
}
class eO {
  constructor(e) {
    (this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`),
      (this.resetNextScroll = !0),
      (this.navigateTimeout = null),
      (this.latestLoadPromise = Promise.resolve()),
      (this.subscribers = new Set()),
      (this.injectedHtml = []),
      (this.startReactTransition = (t) => t()),
      (this.update = (t) => {
        t.notFoundRoute &&
          console.warn(
            "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.",
          );
        const i = this.options;
        (this.options = { ...this.options, ...t }),
          (!this.basepath || (t.basepath && t.basepath !== i.basepath)) &&
            (t.basepath === void 0 || t.basepath === "" || t.basepath === "/"
              ? (this.basepath = "/")
              : (this.basepath = `/${b3(t.basepath)}`)),
          (!this.history ||
            (this.options.history && this.options.history !== this.history)) &&
            ((this.history =
              this.options.history ??
              (typeof document < "u"
                ? JI()
                : e3({ initialEntries: [this.options.basepath || "/"] }))),
            (this.latestLocation = this.parseLocation())),
          this.options.routeTree !== this.routeTree &&
            ((this.routeTree = this.options.routeTree), this.buildRouteTree()),
          this.__store ||
            (this.__store = new w3(iO(this.latestLocation), {
              onUpdate: () => {
                this.__store.state = {
                  ...this.state,
                  status:
                    this.state.isTransitioning || this.state.isLoading
                      ? "pending"
                      : "idle",
                };
              },
            }));
      }),
      (this.buildRouteTree = () => {
        (this.routesById = {}), (this.routesByPath = {});
        const t = this.options.notFoundRoute;
        t &&
          (t.init({ originalIndex: 99999999999 }), (this.routesById[t.id] = t));
        const i = (s) => {
          s.forEach((o, a) => {
            o.init({ originalIndex: a });
            const u = this.routesById[o.id];
            if (
              (cr(!u, `Duplicate routes found with id: ${String(o.id)}`),
              (this.routesById[o.id] = o),
              !o.isRoot && o.path)
            ) {
              const p = Fm(o.fullPath);
              (!this.routesByPath[p] || o.fullPath.endsWith("/")) &&
                (this.routesByPath[p] = o);
            }
            const h = o.children;
            h != null && h.length && i(h);
          });
        };
        i([this.routeTree]);
        const r = [];
        Object.values(this.routesById).forEach((s, o) => {
          var a;
          if (s.isRoot || !s.path) return;
          const u = CS(s.fullPath),
            h = Ac(u);
          for (
            ;
            h.length > 1 && ((a = h[0]) == null ? void 0 : a.value) === "/";

          )
            h.shift();
          const p = h.map((v) =>
            v.value === "/"
              ? 0.75
              : v.type === "param"
                ? 0.5
                : v.type === "wildcard"
                  ? 0.25
                  : 1,
          );
          r.push({ child: s, trimmed: u, parsed: h, index: o, scores: p });
        }),
          (this.flatRoutes = r
            .sort((s, o) => {
              const a = Math.min(s.scores.length, o.scores.length);
              for (let u = 0; u < a; u++)
                if (s.scores[u] !== o.scores[u])
                  return o.scores[u] - s.scores[u];
              if (s.scores.length !== o.scores.length)
                return o.scores.length - s.scores.length;
              for (let u = 0; u < a; u++)
                if (s.parsed[u].value !== o.parsed[u].value)
                  return s.parsed[u].value > o.parsed[u].value ? 1 : -1;
              return s.index - o.index;
            })
            .map((s, o) => ((s.child.rank = o), s.child)));
      }),
      (this.subscribe = (t, i) => {
        const r = { eventType: t, fn: i };
        return (
          this.subscribers.add(r),
          () => {
            this.subscribers.delete(r);
          }
        );
      }),
      (this.emit = (t) => {
        this.subscribers.forEach((i) => {
          i.eventType === t.type && i.fn(t);
        });
      }),
      (this.checkLatest = (t) =>
        this.latestLoadPromise !== t ? this.latestLoadPromise : void 0),
      (this.parseLocation = (t) => {
        const i = ({ pathname: a, search: u, hash: h, state: p }) => {
            const v = this.options.parseSearch(u),
              y = this.options.stringifySearch(v);
            return {
              pathname: a,
              searchStr: y,
              search: jo(t == null ? void 0 : t.search, v),
              hash: h.split("#").reverse()[0] ?? "",
              href: `${a}${y}${h}`,
              state: jo(t == null ? void 0 : t.state, p),
            };
          },
          r = i(this.history.location);
        let { __tempLocation: s, __tempKey: o } = r.state;
        if (s && (!o || o === this.tempLocationKey)) {
          const a = i(s);
          return (
            (a.state.key = r.state.key),
            delete a.state.__tempLocation,
            { ...a, maskedLocation: r }
          );
        }
        return r;
      }),
      (this.resolvePathWithBase = (t, i) => A3(this.basepath, t, qg(i))),
      (this.matchRoutes = (t, i, r) => {
        let s = {},
          o = this.flatRoutes.find((y) => {
            const S = Xy(this.basepath, Fm(t), {
              to: y.fullPath,
              caseSensitive:
                y.options.caseSensitive ?? this.options.caseSensitive,
              fuzzy: !0,
            });
            return S ? ((s = S), !0) : !1;
          }),
          a = o || this.routesById.__root__,
          u = [a],
          h = !1;
        for (
          (o ? o.path !== "/" && s["**"] : Fm(t)) &&
          (this.options.notFoundRoute
            ? u.push(this.options.notFoundRoute)
            : (h = !0));
          a != null && a.parentRoute;

        )
          (a = a.parentRoute), a && u.unshift(a);
        const p = u.map((y) => {
            let S;
            if (y.options.parseParams)
              try {
                const x = y.options.parseParams(s);
                Object.assign(s, x);
              } catch (x) {
                if (
                  ((S = new nO(x.message, { cause: x })),
                  r != null && r.throwOnError)
                )
                  throw S;
                return S;
              }
          }),
          v = [];
        return (
          u.forEach((y, S) => {
            var x, _, f, d, m, g;
            const w = v[S - 1],
              [T, C] = (() => {
                const F = (w == null ? void 0 : w.search) ?? i;
                try {
                  const X =
                    typeof y.options.validateSearch == "object"
                      ? y.options.validateSearch.parse
                      : y.options.validateSearch;
                  let G = (X == null ? void 0 : X(F)) ?? {};
                  return [{ ...F, ...G }, void 0];
                } catch (X) {
                  const G = new tO(X.message, { cause: X });
                  if (r != null && r.throwOnError) throw G;
                  return [F, G];
                }
              })(),
              A =
                ((_ = (x = y.options).loaderDeps) == null
                  ? void 0
                  : _.call(x, { search: T })) ?? "",
              L = A ? JSON.stringify(A) : "",
              N = jy({ path: y.fullPath, params: s }),
              P = jy({ path: y.id, params: s, leaveWildcards: !0 }) + L,
              I = $y(this.state, P),
              Q = this.state.matches.find((F) => F.id === P) ? "stay" : "enter",
              ue = I
                ? {
                    ...I,
                    cause: Q,
                    notFoundError: h && y.id === kr ? { global: !0 } : void 0,
                  }
                : {
                    id: P,
                    routeId: y.id,
                    params: s,
                    pathname: ua([this.basepath, N]),
                    updatedAt: Date.now(),
                    search: {},
                    searchError: void 0,
                    status: "pending",
                    showPending: !1,
                    isFetching: !1,
                    error: void 0,
                    paramsError: p[S],
                    loadPromise: Promise.resolve(),
                    routeContext: void 0,
                    context: void 0,
                    abortController: new AbortController(),
                    fetchCount: 0,
                    cause: Q,
                    loaderDeps: A,
                    invalid: !1,
                    preload: !1,
                    notFoundError: h && y.id === kr ? { global: !0 } : void 0,
                    links:
                      (d = (f = y.options).links) == null ? void 0 : d.call(f),
                    scripts:
                      (g = (m = y.options).scripts) == null
                        ? void 0
                        : g.call(m),
                    staticData: y.options.staticData || {},
                  };
            (ue.search = jo(ue.search, T)), (ue.searchError = C), v.push(ue);
          }),
          v
        );
      }),
      (this.cancelMatch = (t) => {
        var i, r;
        (r = (i = $y(this.state, t)) == null ? void 0 : i.abortController) ==
          null || r.abort();
      }),
      (this.cancelMatches = () => {
        var t;
        (t = this.state.pendingMatches) == null ||
          t.forEach((i) => {
            this.cancelMatch(i.id);
          });
      }),
      (this.buildLocation = (t) => {
        const i = (s = {}, o) => {
            var a, u;
            const h = this.state.pendingMatches || this.state.matches,
              p =
                ((a = h[h.length - 1]) == null ? void 0 : a.search) ||
                this.latestLocation.search;
            let v = this.resolvePathWithBase(
              s.from ?? this.latestLocation.pathname,
              `${s.to ?? ""}`,
            );
            const y = this.matchRoutes(this.latestLocation.pathname, p),
              S =
                o == null
                  ? void 0
                  : o.filter((P) =>
                      y == null
                        ? void 0
                        : y.find((I) => I.routeId === P.routeId),
                    ),
              x = { ...((u = TS(y)) == null ? void 0 : u.params) };
            let _ = (s.params ?? !0) === !0 ? x : zu(s.params, x);
            _ &&
              (o == null ||
                o
                  .map(
                    (P) =>
                      this.looseRoutesById[P.routeId].options.stringifyParams,
                  )
                  .filter(Boolean)
                  .forEach((P) => {
                    _ = { ..._, ...P(_) };
                  })),
              (v = jy({
                path: v,
                params: _ ?? {},
                leaveWildcards: !1,
                leaveParams: t.leaveParams,
              }));
            const f =
                (S == null
                  ? void 0
                  : S.map(
                      (P) =>
                        this.looseRoutesById[P.routeId].options
                          .preSearchFilters ?? [],
                    )
                      .flat()
                      .filter(Boolean)) ?? [],
              d =
                (S == null
                  ? void 0
                  : S.map(
                      (P) =>
                        this.looseRoutesById[P.routeId].options
                          .postSearchFilters ?? [],
                    )
                      .flat()
                      .filter(Boolean)) ?? [],
              m =
                f != null && f.length
                  ? f == null
                    ? void 0
                    : f.reduce((P, I) => I(P), p)
                  : p,
              g =
                s.search === !0
                  ? m
                  : s.search
                    ? zu(s.search, m) ?? {}
                    : f != null && f.length
                      ? m
                      : {},
              w = d != null && d.length ? d.reduce((P, I) => I(P), g) : g,
              T = jo(p, w),
              C = this.options.stringifySearch(T),
              A =
                s.hash === !0
                  ? this.latestLocation.hash
                  : s.hash
                    ? zu(s.hash, this.latestLocation.hash)
                    : void 0,
              L = A ? `#${A}` : "";
            let N =
              s.state === !0
                ? this.latestLocation.state
                : s.state
                  ? zu(s.state, this.latestLocation.state)
                  : {};
            return (
              (N = jo(this.latestLocation.state, N)),
              {
                pathname: v,
                search: T,
                searchStr: C,
                state: N,
                hash: A ?? "",
                href: `${v}${C}${L}`,
                unmaskOnReload: s.unmaskOnReload,
              }
            );
          },
          r = (s = {}, o) => {
            var a;
            let u = i(s),
              h = o ? i(o) : void 0;
            if (!h) {
              let x = {},
                _ =
                  (a = this.options.routeMasks) == null
                    ? void 0
                    : a.find((f) => {
                        const d = Xy(this.basepath, u.pathname, {
                          to: f.from,
                          caseSensitive: !1,
                          fuzzy: !1,
                        });
                        return d ? ((x = d), !0) : !1;
                      });
              _ && ((o = { ...Gd(t, ["from"]), ..._, params: x }), (h = i(o)));
            }
            const p = this.matchRoutes(u.pathname, u.search),
              v = h ? this.matchRoutes(h.pathname, h.search) : void 0,
              y = h ? i(o, v) : void 0,
              S = i(s, p);
            return y && (S.maskedLocation = y), S;
          };
        return t.mask ? r(t, { ...Gd(t, ["from"]), ...t.mask }) : r(t);
      }),
      (this.commitLocation = async ({ startTransition: t, ...i }) => {
        if (
          (this.navigateTimeout && clearTimeout(this.navigateTimeout),
          !(this.latestLocation.href === i.href) || !i.replace)
        ) {
          let { maskedLocation: s, ...o } = i;
          s &&
            ((o = {
              ...s,
              state: {
                ...s.state,
                __tempKey: void 0,
                __tempLocation: {
                  ...o,
                  search: o.searchStr,
                  state: {
                    ...o.state,
                    __tempKey: void 0,
                    __tempLocation: void 0,
                    key: void 0,
                  },
                },
              },
            }),
            (o.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) &&
              (o.state.__tempKey = this.tempLocationKey));
          const a = () => {
            this.history[i.replace ? "replace" : "push"](o.href, o.state);
          };
          t ?? !0 ? this.startReactTransition(a) : a();
        }
        return (
          (this.resetNextScroll = i.resetScroll ?? !0), this.latestLoadPromise
        );
      }),
      (this.buildAndCommitLocation = ({
        replace: t,
        resetScroll: i,
        startTransition: r,
        ...s
      } = {}) => {
        const o = this.buildLocation(s);
        return this.commitLocation({
          ...o,
          startTransition: r,
          replace: t,
          resetScroll: i,
        });
      }),
      (this.navigate = ({ from: t, to: i, ...r }) => {
        const s = String(i);
        let o;
        try {
          new URL(`${s}`), (o = !0);
        } catch {}
        return (
          cr(!o, "Attempting to navigate to external url with this.navigate!"),
          this.buildAndCommitLocation({ ...r, from: t, to: i })
        );
      }),
      (this.loadMatches = async ({
        checkLatest: t,
        matches: i,
        preload: r,
      }) => {
        var s, o;
        let a, u;
        const h = (y) => {
          var S;
          const x =
              (S = this.state.pendingMatches) == null
                ? void 0
                : S.find((d) => d.id === y.id),
            _ = this.state.matches.find((d) => d.id === y.id),
            f = x ? "pendingMatches" : _ ? "matches" : "cachedMatches";
          this.__store.setState((d) => {
            var m;
            return {
              ...d,
              [f]:
                (m = d[f]) == null
                  ? void 0
                  : m.map((g) => (g.id === y.id ? y : g)),
            };
          });
        };
        try {
          for (let [y, S] of i.entries()) {
            const x = i[y - 1],
              _ = this.looseRoutesById[S.routeId],
              f = new AbortController(),
              d = (m, g) => {
                var w, T;
                if (((m.routerCode = g), (u = u ?? y), fu(m))) throw m;
                Wd(m) && this.updateMatchesWithNotFound(i, S, m);
                try {
                  (T = (w = _.options).onError) == null || T.call(w, m);
                } catch (C) {
                  if (((m = C), fu(C))) throw C;
                }
                i[y] = S = {
                  ...S,
                  error: m,
                  status: "error",
                  updatedAt: Date.now(),
                  abortController: new AbortController(),
                };
              };
            try {
              S.paramsError && d(S.paramsError, "PARSE_PARAMS"),
                S.searchError && d(S.searchError, "VALIDATE_SEARCH");
              const m =
                  (x == null ? void 0 : x.context) ??
                  this.options.context ??
                  {},
                g = _.options.pendingMs ?? this.options.defaultPendingMs,
                w =
                  typeof g == "number" && g <= 0
                    ? Promise.resolve()
                    : new Promise((A) => setTimeout(A, g)),
                T =
                  (await ((o = (s = _.options).beforeLoad) == null
                    ? void 0
                    : o.call(s, {
                        search: S.search,
                        abortController: f,
                        params: S.params,
                        preload: !!r,
                        context: m,
                        location: this.state.location,
                        navigate: (A) =>
                          this.navigate({ ...A, from: S.pathname }),
                        buildLocation: this.buildLocation,
                        cause: r ? "preload" : S.cause,
                      }))) ?? {};
              if (fu(T)) throw T;
              const C = { ...m, ...T };
              i[y] = S = {
                ...S,
                routeContext: jo(S.routeContext, T),
                context: jo(S.context, C),
                abortController: f,
                pendingPromise: w,
              };
            } catch (m) {
              d(m, "BEFORE_LOAD");
              break;
            }
          }
        } catch (y) {
          if (fu(y)) return r || this.navigate(y), i;
          throw y;
        }
        const p = i.slice(0, u),
          v = [];
        return (
          p.forEach((y, S) => {
            v.push(
              new Promise(async (x) => {
                var _;
                const f = v[S - 1],
                  d = this.looseRoutesById[y.routeId],
                  m = (F) =>
                    fu(F)
                      ? (r || this.navigate(F), !0)
                      : Wd(F)
                        ? (r || this.updateMatchesWithNotFound(i, y, F), !0)
                        : !1;
                let g;
                i[S] = y = { ...y, showPending: !1 };
                let w = !1;
                const T = d.options.pendingMs ?? this.options.defaultPendingMs,
                  C =
                    d.options.pendingMinMs ?? this.options.defaultPendingMinMs,
                  A =
                    !r &&
                    typeof T == "number" &&
                    (d.options.pendingComponent ??
                      this.options.defaultPendingComponent),
                  L = {
                    params: y.params,
                    deps: y.loaderDeps,
                    preload: !!r,
                    parentMatchPromise: f,
                    abortController: y.abortController,
                    context: y.context,
                    location: this.state.location,
                    navigate: (F) => this.navigate({ ...F, from: y.pathname }),
                    cause: r ? "preload" : y.cause,
                  },
                  N = async () => {
                    var F, X, G, ne, k, W;
                    if (y.isFetching)
                      g =
                        (F = $y(this.state, y.id)) == null
                          ? void 0
                          : F.loadPromise;
                    else {
                      y.fetchCount && y.status === "success" && x(),
                        (i[S] = y =
                          {
                            ...y,
                            isFetching: !0,
                            fetchCount: y.fetchCount + 1,
                          });
                      const H =
                          ((X = d.lazyFn) == null
                            ? void 0
                            : X.call(d).then((te) => {
                                Object.assign(d.options, te.options);
                              })) || Promise.resolve(),
                        ee = H.then(() =>
                          Promise.all(
                            Z3.map(async (te) => {
                              const de = d.options[te];
                              de != null && de.preload && (await de.preload());
                            }),
                          ),
                        );
                      async function ae() {
                        var te, de;
                        return await ((de = (te = d.options).loader) == null
                          ? void 0
                          : de.call(te, L));
                      }
                      const xe = ae();
                      g = Promise.all([ee, xe, H]).then((te) => te[1]);
                    }
                    (i[S] = y = { ...y, loadPromise: g }), h(y);
                    try {
                      const H = await g;
                      if ((a = t())) return await a;
                      if ((fu(H) || Wd(H)) && m(H)) return;
                      if (
                        (w &&
                          C &&
                          (await new Promise((ae) => setTimeout(ae, C))),
                        (a = t()))
                      )
                        return await a;
                      const ee =
                        (ne = (G = d.options).meta) == null
                          ? void 0
                          : ne.call(G, { loaderData: H });
                      i[S] = y = {
                        ...y,
                        error: void 0,
                        status: "success",
                        isFetching: !1,
                        updatedAt: Date.now(),
                        loaderData: H,
                        loadPromise: void 0,
                        meta: ee,
                      };
                    } catch (H) {
                      if ((a = t())) return await a;
                      if (m(H)) return;
                      try {
                        (W = (k = d.options).onError) == null || W.call(k, H);
                      } catch (ee) {
                        if (((H = ee), m(ee))) return;
                      }
                      i[S] = y = {
                        ...y,
                        error: H,
                        status: "error",
                        isFetching: !1,
                      };
                    }
                    h(y);
                  },
                  P = Date.now() - y.updatedAt;
                let I = r
                    ? d.options.preloadStaleTime ??
                      this.options.defaultPreloadStaleTime ??
                      3e4
                    : d.options.staleTime ?? this.options.defaultStaleTime ?? 0,
                  Q;
                const ue = d.options.shouldReload;
                (Q = typeof ue == "function" ? ue(L) : ue),
                  (i[S] = y =
                    {
                      ...y,
                      preload:
                        !!r && !this.state.matches.find((F) => F.id === y.id),
                    }),
                  y.status !== "success"
                    ? (A &&
                        ((_ = y.pendingPromise) == null ||
                          _.then(async () => {
                            if ((a = t())) return a;
                            (w = !0),
                              (i[S] = y = { ...y, showPending: !0 }),
                              h(y),
                              x();
                          })),
                      await N())
                    : (y.invalid || (Q ?? P > I)) && N(),
                  x();
              }),
            );
          }),
          await Promise.all(v),
          i
        );
      }),
      (this.invalidate = () => {
        const t = (i) => ({ ...i, invalid: !0 });
        this.__store.setState((i) => {
          var r;
          return {
            ...i,
            matches: i.matches.map(t),
            cachedMatches: i.cachedMatches.map(t),
            pendingMatches: (r = i.pendingMatches) == null ? void 0 : r.map(t),
          };
        }),
          this.load();
      }),
      (this.load = async () => {
        const t = new Promise(async (i, r) => {
          const s = this.latestLocation,
            o = this.state.resolvedLocation,
            a = o.href !== s.href;
          let u;
          this.cancelMatches(),
            this.emit({
              type: "onBeforeLoad",
              fromLocation: o,
              toLocation: s,
              pathChanged: a,
            });
          let h;
          const p = this.state.matches;
          this.__store.batch(() => {
            this.cleanCache(),
              (h = this.matchRoutes(s.pathname, s.search, { debug: !0 })),
              this.__store.setState((v) => ({
                ...v,
                isLoading: !0,
                location: s,
                pendingMatches: h,
                cachedMatches: v.cachedMatches.filter(
                  (y) => !h.find((S) => S.id === y.id),
                ),
              }));
          });
          try {
            try {
              await this.loadMatches({
                matches: h,
                checkLatest: () => this.checkLatest(t),
              });
            } catch {}
            if ((u = this.checkLatest(t))) return u;
            const v = p.filter((x) => !h.find((_) => _.id === x.id)),
              y = h.filter((x) => !p.find((_) => _.id === x.id)),
              S = p.filter((x) => h.find((_) => _.id === x.id));
            this.__store.batch(() => {
              this.__store.setState((x) => ({
                ...x,
                isLoading: !1,
                matches: x.pendingMatches,
                pendingMatches: void 0,
                cachedMatches: [
                  ...x.cachedMatches,
                  ...v.filter((_) => _.status !== "error"),
                ],
              })),
                this.cleanCache();
            }),
              [
                [v, "onLeave"],
                [y, "onEnter"],
                [S, "onStay"],
              ].forEach(([x, _]) => {
                x.forEach((f) => {
                  var d, m;
                  (m = (d = this.looseRoutesById[f.routeId].options)[_]) ==
                    null || m.call(d, f);
                });
              }),
              this.emit({
                type: "onLoad",
                fromLocation: o,
                toLocation: s,
                pathChanged: a,
              }),
              i();
          } catch (v) {
            if ((u = this.checkLatest(t))) return u;
            r(v);
          }
        });
        return (this.latestLoadPromise = t), this.latestLoadPromise;
      }),
      (this.cleanCache = () => {
        this.__store.setState((t) => ({
          ...t,
          cachedMatches: t.cachedMatches.filter((i) => {
            const r = this.looseRoutesById[i.routeId];
            if (!r.options.loader) return !1;
            const s =
              (i.preload
                ? r.options.preloadGcTime ?? this.options.defaultPreloadGcTime
                : r.options.gcTime ?? this.options.defaultGcTime) ??
              5 * 60 * 1e3;
            return i.status !== "error" && Date.now() - i.updatedAt < s;
          }),
        }));
      }),
      (this.preloadRoute = async (t = this.state.location) => {
        var i;
        let r = this.buildLocation(t),
          s = this.matchRoutes(r.pathname, r.search, { throwOnError: !0 });
        const o = Object.fromEntries(
          (i = [
            ...this.state.matches,
            ...(this.state.pendingMatches ?? []),
            ...this.state.cachedMatches,
          ]) == null
            ? void 0
            : i.map((a) => [a.id, !0]),
        );
        return (
          this.__store.batch(() => {
            s.forEach((a) => {
              o[a.id] ||
                this.__store.setState((u) => ({
                  ...u,
                  cachedMatches: [...u.cachedMatches, a],
                }));
            });
          }),
          (s = await this.loadMatches({
            matches: s,
            preload: !0,
            checkLatest: () => {},
          })),
          s
        );
      }),
      (this.matchRoute = (t, i) => {
        const r = {
            ...t,
            to: t.to ? this.resolvePathWithBase(t.from || "", t.to) : void 0,
            params: t.params || {},
            leaveParams: !0,
          },
          s = this.buildLocation(r);
        if (i != null && i.pending && this.state.status !== "pending")
          return !1;
        const o =
          i != null && i.pending
            ? this.latestLocation
            : this.state.resolvedLocation;
        if (!o) return !1;
        const a = Xy(this.basepath, o.pathname, { ...i, to: s.pathname });
        return !a || (t.params && !oh(a, t.params, !0))
          ? !1
          : a && ((i == null ? void 0 : i.includeSearch) ?? !0)
            ? oh(o.search, s.search, !0)
              ? a
              : !1
            : a;
      }),
      (this.injectHtml = async (t) => {
        this.injectedHtml.push(t);
      }),
      (this.dehydrateData = (t, i) => {
        if (typeof document > "u") {
          const r = typeof t == "string" ? t : JSON.stringify(t);
          return (
            this.injectHtml(async () => {
              const s = `__TSR_DEHYDRATED__${r}`,
                o = typeof i == "function" ? await i() : i;
              return `<script id='${s}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${C3(r)}"] = ${JSON.stringify(this.options.transformer.stringify(o))}
          ;(() => {
            var el = document.getElementById('${s}')
            el.parentElement.removeChild(el)
          })()
          <\/script>`;
            }),
            () => this.hydrateData(t)
          );
        }
        return () => {};
      }),
      (this.hydrateData = (t) => {
        if (typeof document < "u") {
          const i = typeof t == "string" ? t : JSON.stringify(t);
          return this.options.transformer.parse(
            window[`__TSR_DEHYDRATED__${i}`],
          );
        }
      }),
      (this.dehydrate = () => {
        var t;
        const i =
          ((t = this.options.errorSerializer) == null ? void 0 : t.serialize) ??
          rO;
        return {
          state: {
            dehydratedMatches: this.state.matches.map((r) => ({
              ...Gd(r, [
                "id",
                "status",
                "updatedAt",
                "loaderData",
                "notFoundError",
              ]),
              error: r.error
                ? { data: i(r.error), __isServerError: !0 }
                : void 0,
            })),
          },
        };
      }),
      (this.hydrate = async (t) => {
        var i, r, s;
        let o = t;
        typeof document < "u" &&
          (o = (i = window.__TSR_DEHYDRATED__) == null ? void 0 : i.data),
          cr(
            o,
            "Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?",
          );
        const a = this.options.transformer.parse(o);
        (this.dehydratedData = a.payload),
          (s = (r = this.options).hydrate) == null || s.call(r, a.payload);
        const u = a.router.state;
        let h = this.matchRoutes(
          this.state.location.pathname,
          this.state.location.search,
        ).map((p) => {
          var v, y, S, x, _, f;
          const d = u.dehydratedMatches.find((m) => m.id === p.id);
          if (
            (cr(
              d,
              `Could not find a client-side match for dehydrated match with id: ${p.id}!`,
            ),
            d)
          ) {
            const m = this.looseRoutesById[p.routeId];
            return {
              ...p,
              ...d,
              meta:
                (y = (v = m.options).meta) == null
                  ? void 0
                  : y.call(v, { loaderData: d.loaderData }),
              links: (x = (S = m.options).links) == null ? void 0 : x.call(S),
              scripts:
                (f = (_ = m.options).scripts) == null ? void 0 : f.call(_),
            };
          }
          return p;
        });
        this.__store.setState((p) => ({
          ...p,
          matches: h,
          lastUpdated: Date.now(),
        }));
      }),
      (this.updateMatchesWithNotFound = (t, i, r) => {
        const s = Object.fromEntries(t.map((o) => [o.routeId, o]));
        if (r.global) s[kr].notFoundError = r;
        else {
          let o = this.routesById[r.route ?? i.routeId];
          for (
            ;
            !o.options.notFoundComponent &&
            ((o = o == null ? void 0 : o.parentRoute),
            cr(
              o,
              "Found invalid route tree while trying to find not-found handler.",
            ),
            o.id !== kr);

          );
          const a = s[o.id];
          cr(a, "Could not find match for route: " + o.id),
            (a.notFoundError = r);
        }
      }),
      (this.hasNotFoundMatch = () =>
        this.__store.state.matches.some((t) => t.notFoundError)),
      this.update({
        defaultPreloadDelay: 50,
        defaultPendingMs: 1e3,
        defaultPendingMinMs: 500,
        context: void 0,
        ...e,
        stringifySearch: (e == null ? void 0 : e.stringifySearch) ?? X3,
        parseSearch: (e == null ? void 0 : e.parseSearch) ?? j3,
        transformer: (e == null ? void 0 : e.transformer) ?? JSON,
      });
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
}
class tO extends Error {}
class nO extends Error {}
function iO(n) {
  return {
    isLoading: !1,
    isTransitioning: !1,
    status: "idle",
    resolvedLocation: { ...n },
    location: n,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    lastUpdated: 0,
  };
}
function rO(n) {
  return n instanceof Error
    ? { name: n.name, message: n.message }
    : { data: n };
}
function bS(n) {
  return new sO(n, { silent: !0 }).createRoute;
}
class sO {
  constructor(e, t) {
    (this.path = e),
      (this.createRoute = (i) => {
        this.silent;
        const r = D3(i);
        return (r.isRoot = !1), r;
      }),
      (this.silent = t == null ? void 0 : t.silent);
  }
}
const Yy = "Error preloading route! ";
function oO(n) {
  const e = Ca(),
    t = Dl({ strict: !1, select: (ye) => ye.pathname }),
    {
      activeProps: i = () => ({ className: "active" }),
      inactiveProps: r = () => ({}),
      activeOptions: s,
      hash: o,
      search: a,
      params: u,
      to: h,
      state: p,
      mask: v,
      preload: y,
      preloadDelay: S,
      replace: x,
      startTransition: _,
      resetScroll: f,
      children: d,
      target: m,
      disabled: g,
      style: w,
      className: T,
      onClick: C,
      onFocus: A,
      onMouseEnter: L,
      onMouseLeave: N,
      onTouchStart: P,
      ...I
    } = n,
    Q = { from: n.to ? t : void 0, ...n };
  let ue = "internal";
  try {
    new URL(`${h}`), (ue = "external");
  } catch {}
  if (ue === "external")
    return {
      ...I,
      type: ue,
      href: h,
      children: d,
      target: m,
      disabled: g,
      style: w,
      className: T,
      onClick: C,
      onFocus: A,
      onMouseEnter: L,
      onMouseLeave: N,
      onTouchStart: P,
    };
  const F = e.buildLocation(Q),
    X = y ?? e.options.defaultPreload,
    G = S ?? e.options.defaultPreloadDelay ?? 0,
    ne = vr({
      select: (ye) => {
        const Ce = ye.location.pathname.split("/"),
          ze = F.pathname.split("/").every((be, ge) => be === Ce[ge]),
          tt = s != null && s.exact ? ye.location.pathname === F.pathname : ze,
          Ge = s != null && s.includeHash ? ye.location.hash === F.hash : !0,
          V =
            (s == null ? void 0 : s.includeSearch) ?? !0
              ? oh(ye.location.search, F.search, !(s != null && s.exact))
              : !0;
        return tt && Ge && V;
      },
    }),
    k = (ye) => {
      !g &&
        !lO(ye) &&
        !ye.defaultPrevented &&
        (!m || m === "_self") &&
        ye.button === 0 &&
        (ye.preventDefault(),
        e.commitLocation({
          ...F,
          replace: x,
          resetScroll: f,
          startTransition: _,
        }));
    },
    W = (ye) => {
      X &&
        e.preloadRoute(Q).catch((Ce) => {
          console.warn(Ce), console.warn(Yy);
        });
    },
    H = (ye) => {
      X &&
        e.preloadRoute(Q).catch((Ce) => {
          console.warn(Ce), console.warn(Yy);
        });
    },
    ee = (ye) => {
      const Ce = ye.target || {};
      if (X) {
        if (Ce.preloadTimeout) return;
        Ce.preloadTimeout = setTimeout(() => {
          (Ce.preloadTimeout = null),
            e.preloadRoute(Q).catch((Ze) => {
              console.warn(Ze), console.warn(Yy);
            });
        }, G);
      }
    },
    ae = (ye) => {
      const Ce = ye.target || {};
      Ce.preloadTimeout &&
        (clearTimeout(Ce.preloadTimeout), (Ce.preloadTimeout = null));
    },
    xe = (ye) => (Ce) => {
      Ce.persist && Ce.persist(),
        ye.filter(Boolean).forEach((Ze) => {
          Ce.defaultPrevented || Ze(Ce);
        });
    },
    te = ne ? zu(i, {}) ?? {} : {},
    de = ne ? {} : zu(r, {}) ?? {};
  return {
    ...te,
    ...de,
    ...I,
    href: g ? void 0 : F.maskedLocation ? F.maskedLocation.href : F.href,
    onClick: xe([C, k]),
    onFocus: xe([A, W]),
    onMouseEnter: xe([L, ee]),
    onMouseLeave: xe([N, ae]),
    onTouchStart: xe([P, H]),
    target: m,
    style: { ...w, ...te.style, ...de.style },
    className:
      [T, te.className, de.className].filter(Boolean).join(" ") || void 0,
    ...(g ? { role: "link", "aria-disabled": !0 } : void 0),
    "data-status": ne ? "active" : void 0,
  };
}
const Xb = se.forwardRef((n, e) => {
    const { type: t, ...i } = oO(n),
      r =
        typeof n.children == "function"
          ? n.children({ isActive: i["data-status"] === "active" })
          : n.children;
    return t === "external"
      ? ce.jsx("a", { ...i, ref: e, children: r })
      : ce.jsx(aO, { ...i, ref: e, children: r });
  }),
  aO = se.forwardRef((n, e) => ce.jsx("a", { ref: e, ...n }));
function lO(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function AS(n) {
  const { navigate: e } = Ca(),
    t = Dl({ strict: !1, select: (i) => i.pathname });
  return se.useCallback(
    ({ from: i, ...r }) => e({ from: r != null && r.to ? t : void 0, ...r }),
    [],
  );
}
var v_ = {},
  qb = { exports: {} },
  _r = {},
  $b = { exports: {} },
  Yb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(k, W) {
    var H = k.length;
    k.push(W);
    e: for (; 0 < H; ) {
      var ee = (H - 1) >>> 1,
        ae = k[ee];
      if (0 < r(ae, W)) (k[ee] = W), (k[H] = ae), (H = ee);
      else break e;
    }
  }
  function t(k) {
    return k.length === 0 ? null : k[0];
  }
  function i(k) {
    if (k.length === 0) return null;
    var W = k[0],
      H = k.pop();
    if (H !== W) {
      k[0] = H;
      e: for (var ee = 0, ae = k.length, xe = ae >>> 1; ee < xe; ) {
        var te = 2 * (ee + 1) - 1,
          de = k[te],
          ye = te + 1,
          Ce = k[ye];
        if (0 > r(de, H))
          ye < ae && 0 > r(Ce, de)
            ? ((k[ee] = Ce), (k[ye] = H), (ee = ye))
            : ((k[ee] = de), (k[te] = H), (ee = te));
        else if (ye < ae && 0 > r(Ce, H)) (k[ee] = Ce), (k[ye] = H), (ee = ye);
        else break e;
      }
    }
    return W;
  }
  function r(k, W) {
    var H = k.sortIndex - W.sortIndex;
    return H !== 0 ? H : k.id - W.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var u = [],
    h = [],
    p = 1,
    v = null,
    y = 3,
    S = !1,
    x = !1,
    _ = !1,
    f = typeof setTimeout == "function" ? setTimeout : null,
    d = typeof clearTimeout == "function" ? clearTimeout : null,
    m = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function g(k) {
    for (var W = t(h); W !== null; ) {
      if (W.callback === null) i(h);
      else if (W.startTime <= k)
        i(h), (W.sortIndex = W.expirationTime), e(u, W);
      else break;
      W = t(h);
    }
  }
  function w(k) {
    if (((_ = !1), g(k), !x))
      if (t(u) !== null) (x = !0), G(T);
      else {
        var W = t(h);
        W !== null && ne(w, W.startTime - k);
      }
  }
  function T(k, W) {
    (x = !1), _ && ((_ = !1), d(L), (L = -1)), (S = !0);
    var H = y;
    try {
      for (
        g(W), v = t(u);
        v !== null && (!(v.expirationTime > W) || (k && !I()));

      ) {
        var ee = v.callback;
        if (typeof ee == "function") {
          (v.callback = null), (y = v.priorityLevel);
          var ae = ee(v.expirationTime <= W);
          (W = n.unstable_now()),
            typeof ae == "function" ? (v.callback = ae) : v === t(u) && i(u),
            g(W);
        } else i(u);
        v = t(u);
      }
      if (v !== null) var xe = !0;
      else {
        var te = t(h);
        te !== null && ne(w, te.startTime - W), (xe = !1);
      }
      return xe;
    } finally {
      (v = null), (y = H), (S = !1);
    }
  }
  var C = !1,
    A = null,
    L = -1,
    N = 5,
    P = -1;
  function I() {
    return !(n.unstable_now() - P < N);
  }
  function Q() {
    if (A !== null) {
      var k = n.unstable_now();
      P = k;
      var W = !0;
      try {
        W = A(!0, k);
      } finally {
        W ? ue() : ((C = !1), (A = null));
      }
    } else C = !1;
  }
  var ue;
  if (typeof m == "function")
    ue = function () {
      m(Q);
    };
  else if (typeof MessageChannel < "u") {
    var F = new MessageChannel(),
      X = F.port2;
    (F.port1.onmessage = Q),
      (ue = function () {
        X.postMessage(null);
      });
  } else
    ue = function () {
      f(Q, 0);
    };
  function G(k) {
    (A = k), C || ((C = !0), ue());
  }
  function ne(k, W) {
    L = f(function () {
      k(n.unstable_now());
    }, W);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (k) {
      k.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      x || S || ((x = !0), G(T));
    }),
    (n.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
          )
        : (N = 0 < k ? Math.floor(1e3 / k) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return y;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(u);
    }),
    (n.unstable_next = function (k) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var W = 3;
          break;
        default:
          W = y;
      }
      var H = y;
      y = W;
      try {
        return k();
      } finally {
        y = H;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (k, W) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          k = 3;
      }
      var H = y;
      y = k;
      try {
        return W();
      } finally {
        y = H;
      }
    }),
    (n.unstable_scheduleCallback = function (k, W, H) {
      var ee = n.unstable_now();
      switch (
        (typeof H == "object" && H !== null
          ? ((H = H.delay), (H = typeof H == "number" && 0 < H ? ee + H : ee))
          : (H = ee),
        k)
      ) {
        case 1:
          var ae = -1;
          break;
        case 2:
          ae = 250;
          break;
        case 5:
          ae = 1073741823;
          break;
        case 4:
          ae = 1e4;
          break;
        default:
          ae = 5e3;
      }
      return (
        (ae = H + ae),
        (k = {
          id: p++,
          callback: W,
          priorityLevel: k,
          startTime: H,
          expirationTime: ae,
          sortIndex: -1,
        }),
        H > ee
          ? ((k.sortIndex = H),
            e(h, k),
            t(u) === null &&
              k === t(h) &&
              (_ ? (d(L), (L = -1)) : (_ = !0), ne(w, H - ee)))
          : ((k.sortIndex = ae), e(u, k), x || S || ((x = !0), G(T))),
        k
      );
    }),
    (n.unstable_shouldYield = I),
    (n.unstable_wrapCallback = function (k) {
      var W = y;
      return function () {
        var H = y;
        y = W;
        try {
          return k.apply(this, arguments);
        } finally {
          y = H;
        }
      };
    });
})(Yb);
$b.exports = Yb;
var uO = $b.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Kb = se,
  yr = uO;
function Ie(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Qb = new Set(),
  ah = {};
function Wl(n, e) {
  Pc(n, e), Pc(n + "Capture", e);
}
function Pc(n, e) {
  for (ah[n] = e, n = 0; n < e.length; n++) Qb.add(e[n]);
}
var co = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  y_ = Object.prototype.hasOwnProperty,
  cO =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  ZM = {},
  JM = {};
function dO(n) {
  return y_.call(JM, n)
    ? !0
    : y_.call(ZM, n)
      ? !1
      : cO.test(n)
        ? (JM[n] = !0)
        : ((ZM[n] = !0), !1);
}
function hO(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
          ? !t.acceptsBooleans
          : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function fO(n, e, t, i) {
  if (e === null || typeof e > "u" || hO(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function zi(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var ui = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    ui[n] = new zi(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  ui[e] = new zi(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  ui[n] = new zi(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  ui[n] = new zi(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    ui[n] = new zi(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  ui[n] = new zi(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  ui[n] = new zi(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  ui[n] = new zi(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  ui[n] = new zi(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var PS = /[\-:]([a-z])/g;
function RS(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(PS, RS);
    ui[e] = new zi(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(PS, RS);
    ui[e] = new zi(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(PS, RS);
  ui[e] = new zi(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  ui[n] = new zi(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
ui.xlinkHref = new zi(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1,
);
["src", "href", "action", "formAction"].forEach(function (n) {
  ui[n] = new zi(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function LS(n, e, t, i) {
  var r = ui.hasOwnProperty(e) ? ui[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (fO(e, t, r, i) && (t = null),
    i || r === null
      ? dO(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
        ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
        : ((e = r.attributeName),
          (i = r.attributeNamespace),
          t === null
            ? n.removeAttribute(e)
            : ((r = r.type),
              (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
              i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var _o = Kb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  wp = Symbol.for("react.element"),
  Hu = Symbol.for("react.portal"),
  Vu = Symbol.for("react.fragment"),
  IS = Symbol.for("react.strict_mode"),
  __ = Symbol.for("react.profiler"),
  Zb = Symbol.for("react.provider"),
  Jb = Symbol.for("react.context"),
  OS = Symbol.for("react.forward_ref"),
  x_ = Symbol.for("react.suspense"),
  S_ = Symbol.for("react.suspense_list"),
  NS = Symbol.for("react.memo"),
  qo = Symbol.for("react.lazy"),
  eA = Symbol.for("react.offscreen"),
  eE = Symbol.iterator;
function md(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (eE && n[eE]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var En = Object.assign,
  Ky;
function Ud(n) {
  if (Ky === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      Ky = (e && e[1]) || "";
    }
  return (
    `
` +
    Ky +
    n
  );
}
var Qy = !1;
function Zy(n, e) {
  if (!n || Qy) return "";
  Qy = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (h) {
          var i = h;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (h) {
          i = h;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (h) {
        i = h;
      }
      n();
    }
  } catch (h) {
    if (h && i && typeof h.stack == "string") {
      for (
        var r = h.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var u =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    u.includes("<anonymous>") &&
                    (u = u.replace("<anonymous>", n.displayName)),
                  u
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (Qy = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? Ud(n) : "";
}
function pO(n) {
  switch (n.tag) {
    case 5:
      return Ud(n.type);
    case 16:
      return Ud("Lazy");
    case 13:
      return Ud("Suspense");
    case 19:
      return Ud("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = Zy(n.type, !1)), n;
    case 11:
      return (n = Zy(n.type.render, !1)), n;
    case 1:
      return (n = Zy(n.type, !0)), n;
    default:
      return "";
  }
}
function w_(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Vu:
      return "Fragment";
    case Hu:
      return "Portal";
    case __:
      return "Profiler";
    case IS:
      return "StrictMode";
    case x_:
      return "Suspense";
    case S_:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Jb:
        return (n.displayName || "Context") + ".Consumer";
      case Zb:
        return (n._context.displayName || "Context") + ".Provider";
      case OS:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case NS:
        return (
          (e = n.displayName || null), e !== null ? e : w_(n.type) || "Memo"
        );
      case qo:
        (e = n._payload), (n = n._init);
        try {
          return w_(n(e));
        } catch {}
    }
  return null;
}
function mO(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return w_(e);
    case 8:
      return e === IS ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Sa(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function tA(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function gO(n) {
  var e = tA(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Mp(n) {
  n._valueTracker || (n._valueTracker = gO(n));
}
function nA(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = tA(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function lg(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function M_(n, e) {
  var t = e.checked;
  return En({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function tE(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = Sa(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function iA(n, e) {
  (e = e.checked), e != null && LS(n, "checked", e, !1);
}
function E_(n, e) {
  iA(n, e);
  var t = Sa(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? T_(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && T_(n, e.type, Sa(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function nE(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function T_(n, e, t) {
  (e !== "number" || lg(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Fd = Array.isArray;
function sc(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + Sa(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function C_(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Ie(91));
  return En({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function iE(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(Ie(92));
      if (Fd(t)) {
        if (1 < t.length) throw Error(Ie(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: Sa(t) };
}
function rA(n, e) {
  var t = Sa(e.value),
    i = Sa(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function rE(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function sA(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function b_(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? sA(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : n;
}
var Ep,
  oA = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Ep = Ep || document.createElement("div"),
          Ep.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Ep.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function lh(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var jd = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  vO = ["Webkit", "ms", "Moz", "O"];
Object.keys(jd).forEach(function (n) {
  vO.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (jd[e] = jd[n]);
  });
});
function aA(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (jd.hasOwnProperty(n) && jd[n])
      ? ("" + e).trim()
      : e + "px";
}
function lA(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = aA(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var yO = En(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  },
);
function A_(n, e) {
  if (e) {
    if (yO[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Ie(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Ie(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Ie(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Ie(62));
  }
}
function P_(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var R_ = null;
function DS(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var L_ = null,
  oc = null,
  ac = null;
function sE(n) {
  if ((n = df(n))) {
    if (typeof L_ != "function") throw Error(Ie(280));
    var e = n.stateNode;
    e && ((e = Jg(e)), L_(n.stateNode, n.type, e));
  }
}
function uA(n) {
  oc ? (ac ? ac.push(n) : (ac = [n])) : (oc = n);
}
function cA() {
  if (oc) {
    var n = oc,
      e = ac;
    if (((ac = oc = null), sE(n), e)) for (n = 0; n < e.length; n++) sE(e[n]);
  }
}
function dA(n, e) {
  return n(e);
}
function hA() {}
var Jy = !1;
function fA(n, e, t) {
  if (Jy) return n(e, t);
  Jy = !0;
  try {
    return dA(n, e, t);
  } finally {
    (Jy = !1), (oc !== null || ac !== null) && (hA(), cA());
  }
}
function uh(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = Jg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(Ie(231, e, typeof t));
  return t;
}
var I_ = !1;
if (co)
  try {
    var gd = {};
    Object.defineProperty(gd, "passive", {
      get: function () {
        I_ = !0;
      },
    }),
      window.addEventListener("test", gd, gd),
      window.removeEventListener("test", gd, gd);
  } catch {
    I_ = !1;
  }
function _O(n, e, t, i, r, s, o, a, u) {
  var h = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, h);
  } catch (p) {
    this.onError(p);
  }
}
var Xd = !1,
  ug = null,
  cg = !1,
  O_ = null,
  xO = {
    onError: function (n) {
      (Xd = !0), (ug = n);
    },
  };
function SO(n, e, t, i, r, s, o, a, u) {
  (Xd = !1), (ug = null), _O.apply(xO, arguments);
}
function wO(n, e, t, i, r, s, o, a, u) {
  if ((SO.apply(this, arguments), Xd)) {
    if (Xd) {
      var h = ug;
      (Xd = !1), (ug = null);
    } else throw Error(Ie(198));
    cg || ((cg = !0), (O_ = h));
  }
}
function jl(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function pA(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function oE(n) {
  if (jl(n) !== n) throw Error(Ie(188));
}
function MO(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = jl(n)), e === null)) throw Error(Ie(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return oE(r), n;
        if (s === i) return oE(r), e;
        s = s.sibling;
      }
      throw Error(Ie(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Ie(189));
      }
    }
    if (t.alternate !== i) throw Error(Ie(190));
  }
  if (t.tag !== 3) throw Error(Ie(188));
  return t.stateNode.current === t ? n : e;
}
function mA(n) {
  return (n = MO(n)), n !== null ? gA(n) : null;
}
function gA(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = gA(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var vA = yr.unstable_scheduleCallback,
  aE = yr.unstable_cancelCallback,
  EO = yr.unstable_shouldYield,
  TO = yr.unstable_requestPaint,
  On = yr.unstable_now,
  CO = yr.unstable_getCurrentPriorityLevel,
  kS = yr.unstable_ImmediatePriority,
  yA = yr.unstable_UserBlockingPriority,
  dg = yr.unstable_NormalPriority,
  bO = yr.unstable_LowPriority,
  _A = yr.unstable_IdlePriority,
  Yg = null,
  Rs = null;
function AO(n) {
  if (Rs && typeof Rs.onCommitFiberRoot == "function")
    try {
      Rs.onCommitFiberRoot(Yg, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var rs = Math.clz32 ? Math.clz32 : LO,
  PO = Math.log,
  RO = Math.LN2;
function LO(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((PO(n) / RO) | 0)) | 0;
}
var Tp = 64,
  Cp = 4194304;
function Bd(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function hg(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = Bd(a)) : ((s &= o), s !== 0 && (i = Bd(s)));
  } else (o = t & ~r), o !== 0 ? (i = Bd(o)) : s !== 0 && (i = Bd(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - rs(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function IO(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function OO(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - rs(s),
      a = 1 << o,
      u = r[o];
    u === -1
      ? (!(a & t) || a & i) && (r[o] = IO(a, e))
      : u <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function N_(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function xA() {
  var n = Tp;
  return (Tp <<= 1), !(Tp & 4194240) && (Tp = 64), n;
}
function e0(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function uf(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - rs(e)),
    (n[e] = t);
}
function NO(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - rs(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function US(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - rs(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var sn = 0;
function SA(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var wA,
  FS,
  MA,
  EA,
  TA,
  D_ = !1,
  bp = [],
  ca = null,
  da = null,
  ha = null,
  ch = new Map(),
  dh = new Map(),
  Ko = [],
  DO =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " ",
    );
function lE(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      ca = null;
      break;
    case "dragenter":
    case "dragleave":
      da = null;
      break;
    case "mouseover":
    case "mouseout":
      ha = null;
      break;
    case "pointerover":
    case "pointerout":
      ch.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      dh.delete(e.pointerId);
  }
}
function vd(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = df(e)), e !== null && FS(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function kO(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (ca = vd(ca, n, e, t, i, r)), !0;
    case "dragenter":
      return (da = vd(da, n, e, t, i, r)), !0;
    case "mouseover":
      return (ha = vd(ha, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return ch.set(s, vd(ch.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), dh.set(s, vd(dh.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function CA(n) {
  var e = dl(n.target);
  if (e !== null) {
    var t = jl(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = pA(t)), e !== null)) {
          (n.blockedOn = e),
            TA(n.priority, function () {
              MA(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function Bm(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = k_(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (R_ = i), t.target.dispatchEvent(i), (R_ = null);
    } else return (e = df(t)), e !== null && FS(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function uE(n, e, t) {
  Bm(n) && t.delete(e);
}
function UO() {
  (D_ = !1),
    ca !== null && Bm(ca) && (ca = null),
    da !== null && Bm(da) && (da = null),
    ha !== null && Bm(ha) && (ha = null),
    ch.forEach(uE),
    dh.forEach(uE);
}
function yd(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    D_ ||
      ((D_ = !0),
      yr.unstable_scheduleCallback(yr.unstable_NormalPriority, UO)));
}
function hh(n) {
  function e(r) {
    return yd(r, n);
  }
  if (0 < bp.length) {
    yd(bp[0], n);
    for (var t = 1; t < bp.length; t++) {
      var i = bp[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    ca !== null && yd(ca, n),
      da !== null && yd(da, n),
      ha !== null && yd(ha, n),
      ch.forEach(e),
      dh.forEach(e),
      t = 0;
    t < Ko.length;
    t++
  )
    (i = Ko[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < Ko.length && ((t = Ko[0]), t.blockedOn === null); )
    CA(t), t.blockedOn === null && Ko.shift();
}
var lc = _o.ReactCurrentBatchConfig,
  fg = !0;
function FO(n, e, t, i) {
  var r = sn,
    s = lc.transition;
  lc.transition = null;
  try {
    (sn = 1), BS(n, e, t, i);
  } finally {
    (sn = r), (lc.transition = s);
  }
}
function BO(n, e, t, i) {
  var r = sn,
    s = lc.transition;
  lc.transition = null;
  try {
    (sn = 4), BS(n, e, t, i);
  } finally {
    (sn = r), (lc.transition = s);
  }
}
function BS(n, e, t, i) {
  if (fg) {
    var r = k_(n, e, t, i);
    if (r === null) c0(n, e, i, pg, t), lE(n, i);
    else if (kO(r, n, e, t, i)) i.stopPropagation();
    else if ((lE(n, i), e & 4 && -1 < DO.indexOf(n))) {
      for (; r !== null; ) {
        var s = df(r);
        if (
          (s !== null && wA(s),
          (s = k_(n, e, t, i)),
          s === null && c0(n, e, i, pg, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else c0(n, e, i, null, t);
  }
}
var pg = null;
function k_(n, e, t, i) {
  if (((pg = null), (n = DS(i)), (n = dl(n)), n !== null))
    if (((e = jl(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = pA(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (pg = n), null;
}
function bA(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (CO()) {
        case kS:
          return 1;
        case yA:
          return 4;
        case dg:
        case bO:
          return 16;
        case _A:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var aa = null,
  zS = null,
  zm = null;
function AA() {
  if (zm) return zm;
  var n,
    e = zS,
    t = e.length,
    i,
    r = "value" in aa ? aa.value : aa.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (zm = r.slice(n, 1 < i ? 1 - i : void 0));
}
function Hm(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Ap() {
  return !0;
}
function cE() {
  return !1;
}
function xr(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Ap
        : cE),
      (this.isPropagationStopped = cE),
      this
    );
  }
  return (
    En(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Ap));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Ap));
      },
      persist: function () {},
      isPersistent: Ap,
    }),
    e
  );
}
var Gc = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  HS = xr(Gc),
  cf = En({}, Gc, { view: 0, detail: 0 }),
  zO = xr(cf),
  t0,
  n0,
  _d,
  Kg = En({}, cf, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: VS,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== _d &&
            (_d && n.type === "mousemove"
              ? ((t0 = n.screenX - _d.screenX), (n0 = n.screenY - _d.screenY))
              : (n0 = t0 = 0),
            (_d = n)),
          t0);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : n0;
    },
  }),
  dE = xr(Kg),
  HO = En({}, Kg, { dataTransfer: 0 }),
  VO = xr(HO),
  GO = En({}, cf, { relatedTarget: 0 }),
  i0 = xr(GO),
  WO = En({}, Gc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  jO = xr(WO),
  XO = En({}, Gc, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  qO = xr(XO),
  $O = En({}, Gc, { data: 0 }),
  hE = xr($O),
  YO = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  KO = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  QO = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function ZO(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = QO[n]) ? !!e[n] : !1;
}
function VS() {
  return ZO;
}
var JO = En({}, cf, {
    key: function (n) {
      if (n.key) {
        var e = YO[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Hm(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
          ? KO[n.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: VS,
    charCode: function (n) {
      return n.type === "keypress" ? Hm(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Hm(n)
        : n.type === "keydown" || n.type === "keyup"
          ? n.keyCode
          : 0;
    },
  }),
  eN = xr(JO),
  tN = En({}, Kg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  fE = xr(tN),
  nN = En({}, cf, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: VS,
  }),
  iN = xr(nN),
  rN = En({}, Gc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  sN = xr(rN),
  oN = En({}, Kg, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
          ? -n.wheelDeltaY
          : "wheelDelta" in n
            ? -n.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  aN = xr(oN),
  lN = [9, 13, 27, 32],
  GS = co && "CompositionEvent" in window,
  qd = null;
co && "documentMode" in document && (qd = document.documentMode);
var uN = co && "TextEvent" in window && !qd,
  PA = co && (!GS || (qd && 8 < qd && 11 >= qd)),
  pE = String.fromCharCode(32),
  mE = !1;
function RA(n, e) {
  switch (n) {
    case "keyup":
      return lN.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function LA(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Gu = !1;
function cN(n, e) {
  switch (n) {
    case "compositionend":
      return LA(e);
    case "keypress":
      return e.which !== 32 ? null : ((mE = !0), pE);
    case "textInput":
      return (n = e.data), n === pE && mE ? null : n;
    default:
      return null;
  }
}
function dN(n, e) {
  if (Gu)
    return n === "compositionend" || (!GS && RA(n, e))
      ? ((n = AA()), (zm = zS = aa = null), (Gu = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return PA && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var hN = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function gE(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!hN[n.type] : e === "textarea";
}
function IA(n, e, t, i) {
  uA(i),
    (e = mg(e, "onChange")),
    0 < e.length &&
      ((t = new HS("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var $d = null,
  fh = null;
function fN(n) {
  GA(n, 0);
}
function Qg(n) {
  var e = Xu(n);
  if (nA(e)) return n;
}
function pN(n, e) {
  if (n === "change") return e;
}
var OA = !1;
if (co) {
  var r0;
  if (co) {
    var s0 = "oninput" in document;
    if (!s0) {
      var vE = document.createElement("div");
      vE.setAttribute("oninput", "return;"),
        (s0 = typeof vE.oninput == "function");
    }
    r0 = s0;
  } else r0 = !1;
  OA = r0 && (!document.documentMode || 9 < document.documentMode);
}
function yE() {
  $d && ($d.detachEvent("onpropertychange", NA), (fh = $d = null));
}
function NA(n) {
  if (n.propertyName === "value" && Qg(fh)) {
    var e = [];
    IA(e, fh, n, DS(n)), fA(fN, e);
  }
}
function mN(n, e, t) {
  n === "focusin"
    ? (yE(), ($d = e), (fh = t), $d.attachEvent("onpropertychange", NA))
    : n === "focusout" && yE();
}
function gN(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return Qg(fh);
}
function vN(n, e) {
  if (n === "click") return Qg(e);
}
function yN(n, e) {
  if (n === "input" || n === "change") return Qg(e);
}
function _N(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var os = typeof Object.is == "function" ? Object.is : _N;
function ph(n, e) {
  if (os(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!y_.call(e, r) || !os(n[r], e[r])) return !1;
  }
  return !0;
}
function _E(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function xE(n, e) {
  var t = _E(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = _E(t);
  }
}
function DA(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
        ? !1
        : e && e.nodeType === 3
          ? DA(n, e.parentNode)
          : "contains" in n
            ? n.contains(e)
            : n.compareDocumentPosition
              ? !!(n.compareDocumentPosition(e) & 16)
              : !1
    : !1;
}
function kA() {
  for (var n = window, e = lg(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = lg(n.document);
  }
  return e;
}
function WS(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function xN(n) {
  var e = kA(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    DA(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && WS(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = xE(t, s));
        var o = xE(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var SN = co && "documentMode" in document && 11 >= document.documentMode,
  Wu = null,
  U_ = null,
  Yd = null,
  F_ = !1;
function SE(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  F_ ||
    Wu == null ||
    Wu !== lg(i) ||
    ((i = Wu),
    "selectionStart" in i && WS(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (Yd && ph(Yd, i)) ||
      ((Yd = i),
      (i = mg(U_, "onSelect")),
      0 < i.length &&
        ((e = new HS("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = Wu))));
}
function Pp(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var ju = {
    animationend: Pp("Animation", "AnimationEnd"),
    animationiteration: Pp("Animation", "AnimationIteration"),
    animationstart: Pp("Animation", "AnimationStart"),
    transitionend: Pp("Transition", "TransitionEnd"),
  },
  o0 = {},
  UA = {};
co &&
  ((UA = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete ju.animationend.animation,
    delete ju.animationiteration.animation,
    delete ju.animationstart.animation),
  "TransitionEvent" in window || delete ju.transitionend.transition);
function Zg(n) {
  if (o0[n]) return o0[n];
  if (!ju[n]) return n;
  var e = ju[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in UA) return (o0[n] = e[t]);
  return n;
}
var FA = Zg("animationend"),
  BA = Zg("animationiteration"),
  zA = Zg("animationstart"),
  HA = Zg("transitionend"),
  VA = new Map(),
  wE =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " ",
    );
function ba(n, e) {
  VA.set(n, e), Wl(e, [n]);
}
for (var a0 = 0; a0 < wE.length; a0++) {
  var l0 = wE[a0],
    wN = l0.toLowerCase(),
    MN = l0[0].toUpperCase() + l0.slice(1);
  ba(wN, "on" + MN);
}
ba(FA, "onAnimationEnd");
ba(BA, "onAnimationIteration");
ba(zA, "onAnimationStart");
ba("dblclick", "onDoubleClick");
ba("focusin", "onFocus");
ba("focusout", "onBlur");
ba(HA, "onTransitionEnd");
Pc("onMouseEnter", ["mouseout", "mouseover"]);
Pc("onMouseLeave", ["mouseout", "mouseover"]);
Pc("onPointerEnter", ["pointerout", "pointerover"]);
Pc("onPointerLeave", ["pointerout", "pointerover"]);
Wl(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(
    " ",
  ),
);
Wl(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " ",
  ),
);
Wl("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Wl(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" "),
);
Wl(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" "),
);
Wl(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" "),
);
var zd =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " ",
    ),
  EN = new Set("cancel close invalid load scroll toggle".split(" ").concat(zd));
function ME(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), wO(i, e, void 0, n), (n.currentTarget = null);
}
function GA(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            u = a.instance,
            h = a.currentTarget;
          if (((a = a.listener), u !== s && r.isPropagationStopped())) break e;
          ME(r, a, h), (s = u);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (u = a.instance),
            (h = a.currentTarget),
            (a = a.listener),
            u !== s && r.isPropagationStopped())
          )
            break e;
          ME(r, a, h), (s = u);
        }
    }
  }
  if (cg) throw ((n = O_), (cg = !1), (O_ = null), n);
}
function dn(n, e) {
  var t = e[G_];
  t === void 0 && (t = e[G_] = new Set());
  var i = n + "__bubble";
  t.has(i) || (WA(e, n, 2, !1), t.add(i));
}
function u0(n, e, t) {
  var i = 0;
  e && (i |= 4), WA(t, n, i, e);
}
var Rp = "_reactListening" + Math.random().toString(36).slice(2);
function mh(n) {
  if (!n[Rp]) {
    (n[Rp] = !0),
      Qb.forEach(function (t) {
        t !== "selectionchange" && (EN.has(t) || u0(t, !1, n), u0(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Rp] || ((e[Rp] = !0), u0("selectionchange", !1, e));
  }
}
function WA(n, e, t, i) {
  switch (bA(e)) {
    case 1:
      var r = FO;
      break;
    case 4:
      r = BO;
      break;
    default:
      r = BS;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !I_ ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
        ? n.addEventListener(e, t, { passive: r })
        : n.addEventListener(e, t, !1);
}
function c0(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var u = o.tag;
            if (
              (u === 3 || u === 4) &&
              ((u = o.stateNode.containerInfo),
              u === r || (u.nodeType === 8 && u.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = dl(a)), o === null)) return;
          if (((u = o.tag), u === 5 || u === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  fA(function () {
    var h = s,
      p = DS(t),
      v = [];
    e: {
      var y = VA.get(n);
      if (y !== void 0) {
        var S = HS,
          x = n;
        switch (n) {
          case "keypress":
            if (Hm(t) === 0) break e;
          case "keydown":
          case "keyup":
            S = eN;
            break;
          case "focusin":
            (x = "focus"), (S = i0);
            break;
          case "focusout":
            (x = "blur"), (S = i0);
            break;
          case "beforeblur":
          case "afterblur":
            S = i0;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            S = dE;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            S = VO;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            S = iN;
            break;
          case FA:
          case BA:
          case zA:
            S = jO;
            break;
          case HA:
            S = sN;
            break;
          case "scroll":
            S = zO;
            break;
          case "wheel":
            S = aN;
            break;
          case "copy":
          case "cut":
          case "paste":
            S = qO;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            S = fE;
        }
        var _ = (e & 4) !== 0,
          f = !_ && n === "scroll",
          d = _ ? (y !== null ? y + "Capture" : null) : y;
        _ = [];
        for (var m = h, g; m !== null; ) {
          g = m;
          var w = g.stateNode;
          if (
            (g.tag === 5 &&
              w !== null &&
              ((g = w),
              d !== null && ((w = uh(m, d)), w != null && _.push(gh(m, w, g)))),
            f)
          )
            break;
          m = m.return;
        }
        0 < _.length &&
          ((y = new S(y, x, null, t, p)), v.push({ event: y, listeners: _ }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((y = n === "mouseover" || n === "pointerover"),
          (S = n === "mouseout" || n === "pointerout"),
          y &&
            t !== R_ &&
            (x = t.relatedTarget || t.fromElement) &&
            (dl(x) || x[ho]))
        )
          break e;
        if (
          (S || y) &&
          ((y =
            p.window === p
              ? p
              : (y = p.ownerDocument)
                ? y.defaultView || y.parentWindow
                : window),
          S
            ? ((x = t.relatedTarget || t.toElement),
              (S = h),
              (x = x ? dl(x) : null),
              x !== null &&
                ((f = jl(x)), x !== f || (x.tag !== 5 && x.tag !== 6)) &&
                (x = null))
            : ((S = null), (x = h)),
          S !== x)
        ) {
          if (
            ((_ = dE),
            (w = "onMouseLeave"),
            (d = "onMouseEnter"),
            (m = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((_ = fE),
              (w = "onPointerLeave"),
              (d = "onPointerEnter"),
              (m = "pointer")),
            (f = S == null ? y : Xu(S)),
            (g = x == null ? y : Xu(x)),
            (y = new _(w, m + "leave", S, t, p)),
            (y.target = f),
            (y.relatedTarget = g),
            (w = null),
            dl(p) === h &&
              ((_ = new _(d, m + "enter", x, t, p)),
              (_.target = g),
              (_.relatedTarget = f),
              (w = _)),
            (f = w),
            S && x)
          )
            t: {
              for (_ = S, d = x, m = 0, g = _; g; g = pu(g)) m++;
              for (g = 0, w = d; w; w = pu(w)) g++;
              for (; 0 < m - g; ) (_ = pu(_)), m--;
              for (; 0 < g - m; ) (d = pu(d)), g--;
              for (; m--; ) {
                if (_ === d || (d !== null && _ === d.alternate)) break t;
                (_ = pu(_)), (d = pu(d));
              }
              _ = null;
            }
          else _ = null;
          S !== null && EE(v, y, S, _, !1),
            x !== null && f !== null && EE(v, f, x, _, !0);
        }
      }
      e: {
        if (
          ((y = h ? Xu(h) : window),
          (S = y.nodeName && y.nodeName.toLowerCase()),
          S === "select" || (S === "input" && y.type === "file"))
        )
          var T = pN;
        else if (gE(y))
          if (OA) T = yN;
          else {
            T = gN;
            var C = mN;
          }
        else
          (S = y.nodeName) &&
            S.toLowerCase() === "input" &&
            (y.type === "checkbox" || y.type === "radio") &&
            (T = vN);
        if (T && (T = T(n, h))) {
          IA(v, T, t, p);
          break e;
        }
        C && C(n, y, h),
          n === "focusout" &&
            (C = y._wrapperState) &&
            C.controlled &&
            y.type === "number" &&
            T_(y, "number", y.value);
      }
      switch (((C = h ? Xu(h) : window), n)) {
        case "focusin":
          (gE(C) || C.contentEditable === "true") &&
            ((Wu = C), (U_ = h), (Yd = null));
          break;
        case "focusout":
          Yd = U_ = Wu = null;
          break;
        case "mousedown":
          F_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (F_ = !1), SE(v, t, p);
          break;
        case "selectionchange":
          if (SN) break;
        case "keydown":
        case "keyup":
          SE(v, t, p);
      }
      var A;
      if (GS)
        e: {
          switch (n) {
            case "compositionstart":
              var L = "onCompositionStart";
              break e;
            case "compositionend":
              L = "onCompositionEnd";
              break e;
            case "compositionupdate":
              L = "onCompositionUpdate";
              break e;
          }
          L = void 0;
        }
      else
        Gu
          ? RA(n, t) && (L = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (L = "onCompositionStart");
      L &&
        (PA &&
          t.locale !== "ko" &&
          (Gu || L !== "onCompositionStart"
            ? L === "onCompositionEnd" && Gu && (A = AA())
            : ((aa = p),
              (zS = "value" in aa ? aa.value : aa.textContent),
              (Gu = !0))),
        (C = mg(h, L)),
        0 < C.length &&
          ((L = new hE(L, n, null, t, p)),
          v.push({ event: L, listeners: C }),
          A ? (L.data = A) : ((A = LA(t)), A !== null && (L.data = A)))),
        (A = uN ? cN(n, t) : dN(n, t)) &&
          ((h = mg(h, "onBeforeInput")),
          0 < h.length &&
            ((p = new hE("onBeforeInput", "beforeinput", null, t, p)),
            v.push({ event: p, listeners: h }),
            (p.data = A)));
    }
    GA(v, e);
  });
}
function gh(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function mg(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = uh(n, t)),
      s != null && i.unshift(gh(n, s, r)),
      (s = uh(n, e)),
      s != null && i.push(gh(n, s, r))),
      (n = n.return);
  }
  return i;
}
function pu(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function EE(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      u = a.alternate,
      h = a.stateNode;
    if (u !== null && u === i) break;
    a.tag === 5 &&
      h !== null &&
      ((a = h),
      r
        ? ((u = uh(t, s)), u != null && o.unshift(gh(t, u, a)))
        : r || ((u = uh(t, s)), u != null && o.push(gh(t, u, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var TN = /\r\n?/g,
  CN = /\u0000|\uFFFD/g;
function TE(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      TN,
      `
`,
    )
    .replace(CN, "");
}
function Lp(n, e, t) {
  if (((e = TE(e)), TE(n) !== e && t)) throw Error(Ie(425));
}
function gg() {}
var B_ = null,
  z_ = null;
function H_(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var V_ = typeof setTimeout == "function" ? setTimeout : void 0,
  bN = typeof clearTimeout == "function" ? clearTimeout : void 0,
  CE = typeof Promise == "function" ? Promise : void 0,
  AN =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof CE < "u"
        ? function (n) {
            return CE.resolve(null).then(n).catch(PN);
          }
        : V_;
function PN(n) {
  setTimeout(function () {
    throw n;
  });
}
function d0(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), hh(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  hh(e);
}
function fa(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function bE(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Wc = Math.random().toString(36).slice(2),
  Cs = "__reactFiber$" + Wc,
  vh = "__reactProps$" + Wc,
  ho = "__reactContainer$" + Wc,
  G_ = "__reactEvents$" + Wc,
  RN = "__reactListeners$" + Wc,
  LN = "__reactHandles$" + Wc;
function dl(n) {
  var e = n[Cs];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[ho] || t[Cs])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = bE(n); n !== null; ) {
          if ((t = n[Cs])) return t;
          n = bE(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function df(n) {
  return (
    (n = n[Cs] || n[ho]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function Xu(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(Ie(33));
}
function Jg(n) {
  return n[vh] || null;
}
var W_ = [],
  qu = -1;
function Aa(n) {
  return { current: n };
}
function pn(n) {
  0 > qu || ((n.current = W_[qu]), (W_[qu] = null), qu--);
}
function cn(n, e) {
  qu++, (W_[qu] = n.current), (n.current = e);
}
var wa = {},
  Ti = Aa(wa),
  Ki = Aa(!1),
  kl = wa;
function Rc(n, e) {
  var t = n.type.contextTypes;
  if (!t) return wa;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Qi(n) {
  return (n = n.childContextTypes), n != null;
}
function vg() {
  pn(Ki), pn(Ti);
}
function AE(n, e, t) {
  if (Ti.current !== wa) throw Error(Ie(168));
  cn(Ti, e), cn(Ki, t);
}
function jA(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(Ie(108, mO(n) || "Unknown", r));
  return En({}, t, i);
}
function yg(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || wa),
    (kl = Ti.current),
    cn(Ti, n),
    cn(Ki, Ki.current),
    !0
  );
}
function PE(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(Ie(169));
  t
    ? ((n = jA(n, e, kl)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      pn(Ki),
      pn(Ti),
      cn(Ti, n))
    : pn(Ki),
    cn(Ki, t);
}
var to = null,
  ev = !1,
  h0 = !1;
function XA(n) {
  to === null ? (to = [n]) : to.push(n);
}
function IN(n) {
  (ev = !0), XA(n);
}
function Pa() {
  if (!h0 && to !== null) {
    h0 = !0;
    var n = 0,
      e = sn;
    try {
      var t = to;
      for (sn = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (to = null), (ev = !1);
    } catch (r) {
      throw (to !== null && (to = to.slice(n + 1)), vA(kS, Pa), r);
    } finally {
      (sn = e), (h0 = !1);
    }
  }
  return null;
}
var $u = [],
  Yu = 0,
  _g = null,
  xg = 0,
  Ur = [],
  Fr = 0,
  Ul = null,
  io = 1,
  ro = "";
function rl(n, e) {
  ($u[Yu++] = xg), ($u[Yu++] = _g), (_g = n), (xg = e);
}
function qA(n, e, t) {
  (Ur[Fr++] = io), (Ur[Fr++] = ro), (Ur[Fr++] = Ul), (Ul = n);
  var i = io;
  n = ro;
  var r = 32 - rs(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - rs(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (io = (1 << (32 - rs(e) + r)) | (t << r) | i),
      (ro = s + n);
  } else (io = (1 << s) | (t << r) | i), (ro = n);
}
function jS(n) {
  n.return !== null && (rl(n, 1), qA(n, 1, 0));
}
function XS(n) {
  for (; n === _g; )
    (_g = $u[--Yu]), ($u[Yu] = null), (xg = $u[--Yu]), ($u[Yu] = null);
  for (; n === Ul; )
    (Ul = Ur[--Fr]),
      (Ur[Fr] = null),
      (ro = Ur[--Fr]),
      (Ur[Fr] = null),
      (io = Ur[--Fr]),
      (Ur[Fr] = null);
}
var mr = null,
  fr = null,
  vn = !1,
  ns = null;
function $A(n, e) {
  var t = zr(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function RE(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (mr = n), (fr = fa(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (mr = n), (fr = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = Ul !== null ? { id: io, overflow: ro } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = zr(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (mr = n),
            (fr = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function j_(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function X_(n) {
  if (vn) {
    var e = fr;
    if (e) {
      var t = e;
      if (!RE(n, e)) {
        if (j_(n)) throw Error(Ie(418));
        e = fa(t.nextSibling);
        var i = mr;
        e && RE(n, e)
          ? $A(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (vn = !1), (mr = n));
      }
    } else {
      if (j_(n)) throw Error(Ie(418));
      (n.flags = (n.flags & -4097) | 2), (vn = !1), (mr = n);
    }
  }
}
function LE(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  mr = n;
}
function Ip(n) {
  if (n !== mr) return !1;
  if (!vn) return LE(n), (vn = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !H_(n.type, n.memoizedProps))),
    e && (e = fr))
  ) {
    if (j_(n)) throw (YA(), Error(Ie(418)));
    for (; e; ) $A(n, e), (e = fa(e.nextSibling));
  }
  if ((LE(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(Ie(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              fr = fa(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      fr = null;
    }
  } else fr = mr ? fa(n.stateNode.nextSibling) : null;
  return !0;
}
function YA() {
  for (var n = fr; n; ) n = fa(n.nextSibling);
}
function Lc() {
  (fr = mr = null), (vn = !1);
}
function qS(n) {
  ns === null ? (ns = [n]) : ns.push(n);
}
var ON = _o.ReactCurrentBatchConfig;
function Zr(n, e) {
  if (n && n.defaultProps) {
    (e = En({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var Sg = Aa(null),
  wg = null,
  Ku = null,
  $S = null;
function YS() {
  $S = Ku = wg = null;
}
function KS(n) {
  var e = Sg.current;
  pn(Sg), (n._currentValue = e);
}
function q_(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function uc(n, e) {
  (wg = n),
    ($S = Ku = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (Yi = !0), (n.firstContext = null));
}
function Vr(n) {
  var e = n._currentValue;
  if ($S !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Ku === null)) {
      if (wg === null) throw Error(Ie(308));
      (Ku = n), (wg.dependencies = { lanes: 0, firstContext: n });
    } else Ku = Ku.next = n;
  return e;
}
var hl = null;
function QS(n) {
  hl === null ? (hl = [n]) : hl.push(n);
}
function KA(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), QS(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    fo(n, i)
  );
}
function fo(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var $o = !1;
function ZS(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function QA(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function lo(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function pa(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), jt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      fo(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), QS(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    fo(n, t)
  );
}
function Vm(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), US(n, t);
  }
}
function IE(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function Mg(n, e, t, i) {
  var r = n.updateQueue;
  $o = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var u = a,
      h = u.next;
    (u.next = null), o === null ? (s = h) : (o.next = h), (o = u);
    var p = n.alternate;
    p !== null &&
      ((p = p.updateQueue),
      (a = p.lastBaseUpdate),
      a !== o &&
        (a === null ? (p.firstBaseUpdate = h) : (a.next = h),
        (p.lastBaseUpdate = u)));
  }
  if (s !== null) {
    var v = r.baseState;
    (o = 0), (p = h = u = null), (a = s);
    do {
      var y = a.lane,
        S = a.eventTime;
      if ((i & y) === y) {
        p !== null &&
          (p = p.next =
            {
              eventTime: S,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var x = n,
            _ = a;
          switch (((y = e), (S = t), _.tag)) {
            case 1:
              if (((x = _.payload), typeof x == "function")) {
                v = x.call(S, v, y);
                break e;
              }
              v = x;
              break e;
            case 3:
              x.flags = (x.flags & -65537) | 128;
            case 0:
              if (
                ((x = _.payload),
                (y = typeof x == "function" ? x.call(S, v, y) : x),
                y == null)
              )
                break e;
              v = En({}, v, y);
              break e;
            case 2:
              $o = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (y = r.effects),
          y === null ? (r.effects = [a]) : y.push(a));
      } else
        (S = {
          eventTime: S,
          lane: y,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          p === null ? ((h = p = S), (u = v)) : (p = p.next = S),
          (o |= y);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (y = a),
          (a = y.next),
          (y.next = null),
          (r.lastBaseUpdate = y),
          (r.shared.pending = null);
      }
    } while (1);
    if (
      (p === null && (u = v),
      (r.baseState = u),
      (r.firstBaseUpdate = h),
      (r.lastBaseUpdate = p),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (Bl |= o), (n.lanes = o), (n.memoizedState = v);
  }
}
function OE(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(Ie(191, r));
        r.call(i);
      }
    }
}
var ZA = new Kb.Component().refs;
function $_(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : En({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var tv = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? jl(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = ki(),
      r = ga(n),
      s = lo(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = pa(n, s, r)),
      e !== null && (ss(e, n, r, i), Vm(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = ki(),
      r = ga(n),
      s = lo(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = pa(n, s, r)),
      e !== null && (ss(e, n, r, i), Vm(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = ki(),
      i = ga(n),
      r = lo(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = pa(n, r, i)),
      e !== null && (ss(e, n, i, t), Vm(e, n, i));
  },
};
function NE(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
        ? !ph(t, i) || !ph(r, s)
        : !0
  );
}
function JA(n, e, t) {
  var i = !1,
    r = wa,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Vr(s))
      : ((r = Qi(e) ? kl : Ti.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? Rc(n, r) : wa)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = tv),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function DE(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && tv.enqueueReplaceState(e, e.state, null);
}
function Y_(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = ZA), ZS(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = Vr(s))
    : ((s = Qi(e) ? kl : Ti.current), (r.context = Rc(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && ($_(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && tv.enqueueReplaceState(r, r.state, null),
      Mg(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function xd(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(Ie(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(Ie(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            a === ZA && (a = r.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(Ie(284));
    if (!t._owner) throw Error(Ie(290, n));
  }
  return n;
}
function Op(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      Ie(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n,
      ),
    ))
  );
}
function kE(n) {
  var e = n._init;
  return e(n._payload);
}
function eP(n) {
  function e(d, m) {
    if (n) {
      var g = d.deletions;
      g === null ? ((d.deletions = [m]), (d.flags |= 16)) : g.push(m);
    }
  }
  function t(d, m) {
    if (!n) return null;
    for (; m !== null; ) e(d, m), (m = m.sibling);
    return null;
  }
  function i(d, m) {
    for (d = new Map(); m !== null; )
      m.key !== null ? d.set(m.key, m) : d.set(m.index, m), (m = m.sibling);
    return d;
  }
  function r(d, m) {
    return (d = va(d, m)), (d.index = 0), (d.sibling = null), d;
  }
  function s(d, m, g) {
    return (
      (d.index = g),
      n
        ? ((g = d.alternate),
          g !== null
            ? ((g = g.index), g < m ? ((d.flags |= 2), m) : g)
            : ((d.flags |= 2), m))
        : ((d.flags |= 1048576), m)
    );
  }
  function o(d) {
    return n && d.alternate === null && (d.flags |= 2), d;
  }
  function a(d, m, g, w) {
    return m === null || m.tag !== 6
      ? ((m = _0(g, d.mode, w)), (m.return = d), m)
      : ((m = r(m, g)), (m.return = d), m);
  }
  function u(d, m, g, w) {
    var T = g.type;
    return T === Vu
      ? p(d, m, g.props.children, w, g.key)
      : m !== null &&
          (m.elementType === T ||
            (typeof T == "object" &&
              T !== null &&
              T.$$typeof === qo &&
              kE(T) === m.type))
        ? ((w = r(m, g.props)), (w.ref = xd(d, m, g)), (w.return = d), w)
        : ((w = $m(g.type, g.key, g.props, null, d.mode, w)),
          (w.ref = xd(d, m, g)),
          (w.return = d),
          w);
  }
  function h(d, m, g, w) {
    return m === null ||
      m.tag !== 4 ||
      m.stateNode.containerInfo !== g.containerInfo ||
      m.stateNode.implementation !== g.implementation
      ? ((m = x0(g, d.mode, w)), (m.return = d), m)
      : ((m = r(m, g.children || [])), (m.return = d), m);
  }
  function p(d, m, g, w, T) {
    return m === null || m.tag !== 7
      ? ((m = Al(g, d.mode, w, T)), (m.return = d), m)
      : ((m = r(m, g)), (m.return = d), m);
  }
  function v(d, m, g) {
    if ((typeof m == "string" && m !== "") || typeof m == "number")
      return (m = _0("" + m, d.mode, g)), (m.return = d), m;
    if (typeof m == "object" && m !== null) {
      switch (m.$$typeof) {
        case wp:
          return (
            (g = $m(m.type, m.key, m.props, null, d.mode, g)),
            (g.ref = xd(d, null, m)),
            (g.return = d),
            g
          );
        case Hu:
          return (m = x0(m, d.mode, g)), (m.return = d), m;
        case qo:
          var w = m._init;
          return v(d, w(m._payload), g);
      }
      if (Fd(m) || md(m))
        return (m = Al(m, d.mode, g, null)), (m.return = d), m;
      Op(d, m);
    }
    return null;
  }
  function y(d, m, g, w) {
    var T = m !== null ? m.key : null;
    if ((typeof g == "string" && g !== "") || typeof g == "number")
      return T !== null ? null : a(d, m, "" + g, w);
    if (typeof g == "object" && g !== null) {
      switch (g.$$typeof) {
        case wp:
          return g.key === T ? u(d, m, g, w) : null;
        case Hu:
          return g.key === T ? h(d, m, g, w) : null;
        case qo:
          return (T = g._init), y(d, m, T(g._payload), w);
      }
      if (Fd(g) || md(g)) return T !== null ? null : p(d, m, g, w, null);
      Op(d, g);
    }
    return null;
  }
  function S(d, m, g, w, T) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (d = d.get(g) || null), a(m, d, "" + w, T);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case wp:
          return (d = d.get(w.key === null ? g : w.key) || null), u(m, d, w, T);
        case Hu:
          return (d = d.get(w.key === null ? g : w.key) || null), h(m, d, w, T);
        case qo:
          var C = w._init;
          return S(d, m, g, C(w._payload), T);
      }
      if (Fd(w) || md(w)) return (d = d.get(g) || null), p(m, d, w, T, null);
      Op(m, w);
    }
    return null;
  }
  function x(d, m, g, w) {
    for (
      var T = null, C = null, A = m, L = (m = 0), N = null;
      A !== null && L < g.length;
      L++
    ) {
      A.index > L ? ((N = A), (A = null)) : (N = A.sibling);
      var P = y(d, A, g[L], w);
      if (P === null) {
        A === null && (A = N);
        break;
      }
      n && A && P.alternate === null && e(d, A),
        (m = s(P, m, L)),
        C === null ? (T = P) : (C.sibling = P),
        (C = P),
        (A = N);
    }
    if (L === g.length) return t(d, A), vn && rl(d, L), T;
    if (A === null) {
      for (; L < g.length; L++)
        (A = v(d, g[L], w)),
          A !== null &&
            ((m = s(A, m, L)), C === null ? (T = A) : (C.sibling = A), (C = A));
      return vn && rl(d, L), T;
    }
    for (A = i(d, A); L < g.length; L++)
      (N = S(A, d, L, g[L], w)),
        N !== null &&
          (n && N.alternate !== null && A.delete(N.key === null ? L : N.key),
          (m = s(N, m, L)),
          C === null ? (T = N) : (C.sibling = N),
          (C = N));
    return (
      n &&
        A.forEach(function (I) {
          return e(d, I);
        }),
      vn && rl(d, L),
      T
    );
  }
  function _(d, m, g, w) {
    var T = md(g);
    if (typeof T != "function") throw Error(Ie(150));
    if (((g = T.call(g)), g == null)) throw Error(Ie(151));
    for (
      var C = (T = null), A = m, L = (m = 0), N = null, P = g.next();
      A !== null && !P.done;
      L++, P = g.next()
    ) {
      A.index > L ? ((N = A), (A = null)) : (N = A.sibling);
      var I = y(d, A, P.value, w);
      if (I === null) {
        A === null && (A = N);
        break;
      }
      n && A && I.alternate === null && e(d, A),
        (m = s(I, m, L)),
        C === null ? (T = I) : (C.sibling = I),
        (C = I),
        (A = N);
    }
    if (P.done) return t(d, A), vn && rl(d, L), T;
    if (A === null) {
      for (; !P.done; L++, P = g.next())
        (P = v(d, P.value, w)),
          P !== null &&
            ((m = s(P, m, L)), C === null ? (T = P) : (C.sibling = P), (C = P));
      return vn && rl(d, L), T;
    }
    for (A = i(d, A); !P.done; L++, P = g.next())
      (P = S(A, d, L, P.value, w)),
        P !== null &&
          (n && P.alternate !== null && A.delete(P.key === null ? L : P.key),
          (m = s(P, m, L)),
          C === null ? (T = P) : (C.sibling = P),
          (C = P));
    return (
      n &&
        A.forEach(function (Q) {
          return e(d, Q);
        }),
      vn && rl(d, L),
      T
    );
  }
  function f(d, m, g, w) {
    if (
      (typeof g == "object" &&
        g !== null &&
        g.type === Vu &&
        g.key === null &&
        (g = g.props.children),
      typeof g == "object" && g !== null)
    ) {
      switch (g.$$typeof) {
        case wp:
          e: {
            for (var T = g.key, C = m; C !== null; ) {
              if (C.key === T) {
                if (((T = g.type), T === Vu)) {
                  if (C.tag === 7) {
                    t(d, C.sibling),
                      (m = r(C, g.props.children)),
                      (m.return = d),
                      (d = m);
                    break e;
                  }
                } else if (
                  C.elementType === T ||
                  (typeof T == "object" &&
                    T !== null &&
                    T.$$typeof === qo &&
                    kE(T) === C.type)
                ) {
                  t(d, C.sibling),
                    (m = r(C, g.props)),
                    (m.ref = xd(d, C, g)),
                    (m.return = d),
                    (d = m);
                  break e;
                }
                t(d, C);
                break;
              } else e(d, C);
              C = C.sibling;
            }
            g.type === Vu
              ? ((m = Al(g.props.children, d.mode, w, g.key)),
                (m.return = d),
                (d = m))
              : ((w = $m(g.type, g.key, g.props, null, d.mode, w)),
                (w.ref = xd(d, m, g)),
                (w.return = d),
                (d = w));
          }
          return o(d);
        case Hu:
          e: {
            for (C = g.key; m !== null; ) {
              if (m.key === C)
                if (
                  m.tag === 4 &&
                  m.stateNode.containerInfo === g.containerInfo &&
                  m.stateNode.implementation === g.implementation
                ) {
                  t(d, m.sibling),
                    (m = r(m, g.children || [])),
                    (m.return = d),
                    (d = m);
                  break e;
                } else {
                  t(d, m);
                  break;
                }
              else e(d, m);
              m = m.sibling;
            }
            (m = x0(g, d.mode, w)), (m.return = d), (d = m);
          }
          return o(d);
        case qo:
          return (C = g._init), f(d, m, C(g._payload), w);
      }
      if (Fd(g)) return x(d, m, g, w);
      if (md(g)) return _(d, m, g, w);
      Op(d, g);
    }
    return (typeof g == "string" && g !== "") || typeof g == "number"
      ? ((g = "" + g),
        m !== null && m.tag === 6
          ? (t(d, m.sibling), (m = r(m, g)), (m.return = d), (d = m))
          : (t(d, m), (m = _0(g, d.mode, w)), (m.return = d), (d = m)),
        o(d))
      : t(d, m);
  }
  return f;
}
var Ic = eP(!0),
  tP = eP(!1),
  hf = {},
  Ls = Aa(hf),
  yh = Aa(hf),
  _h = Aa(hf);
function fl(n) {
  if (n === hf) throw Error(Ie(174));
  return n;
}
function JS(n, e) {
  switch ((cn(_h, e), cn(yh, n), cn(Ls, hf), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : b_(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = b_(e, n));
  }
  pn(Ls), cn(Ls, e);
}
function Oc() {
  pn(Ls), pn(yh), pn(_h);
}
function nP(n) {
  fl(_h.current);
  var e = fl(Ls.current),
    t = b_(e, n.type);
  e !== t && (cn(yh, n), cn(Ls, t));
}
function ew(n) {
  yh.current === n && (pn(Ls), pn(yh));
}
var _n = Aa(0);
function Eg(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var f0 = [];
function tw() {
  for (var n = 0; n < f0.length; n++)
    f0[n]._workInProgressVersionPrimary = null;
  f0.length = 0;
}
var Gm = _o.ReactCurrentDispatcher,
  p0 = _o.ReactCurrentBatchConfig,
  Fl = 0,
  wn = null,
  Gn = null,
  Jn = null,
  Tg = !1,
  Kd = !1,
  xh = 0,
  NN = 0;
function vi() {
  throw Error(Ie(321));
}
function nw(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!os(n[t], e[t])) return !1;
  return !0;
}
function iw(n, e, t, i, r, s) {
  if (
    ((Fl = s),
    (wn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Gm.current = n === null || n.memoizedState === null ? FN : BN),
    (n = t(i, r)),
    Kd)
  ) {
    s = 0;
    do {
      if (((Kd = !1), (xh = 0), 25 <= s)) throw Error(Ie(301));
      (s += 1),
        (Jn = Gn = null),
        (e.updateQueue = null),
        (Gm.current = zN),
        (n = t(i, r));
    } while (Kd);
  }
  if (
    ((Gm.current = Cg),
    (e = Gn !== null && Gn.next !== null),
    (Fl = 0),
    (Jn = Gn = wn = null),
    (Tg = !1),
    e)
  )
    throw Error(Ie(300));
  return n;
}
function rw() {
  var n = xh !== 0;
  return (xh = 0), n;
}
function Ss() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Jn === null ? (wn.memoizedState = Jn = n) : (Jn = Jn.next = n), Jn;
}
function Gr() {
  if (Gn === null) {
    var n = wn.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Gn.next;
  var e = Jn === null ? wn.memoizedState : Jn.next;
  if (e !== null) (Jn = e), (Gn = n);
  else {
    if (n === null) throw Error(Ie(310));
    (Gn = n),
      (n = {
        memoizedState: Gn.memoizedState,
        baseState: Gn.baseState,
        baseQueue: Gn.baseQueue,
        queue: Gn.queue,
        next: null,
      }),
      Jn === null ? (wn.memoizedState = Jn = n) : (Jn = Jn.next = n);
  }
  return Jn;
}
function Sh(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function m0(n) {
  var e = Gr(),
    t = e.queue;
  if (t === null) throw Error(Ie(311));
  t.lastRenderedReducer = n;
  var i = Gn,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      u = null,
      h = s;
    do {
      var p = h.lane;
      if ((Fl & p) === p)
        u !== null &&
          (u = u.next =
            {
              lane: 0,
              action: h.action,
              hasEagerState: h.hasEagerState,
              eagerState: h.eagerState,
              next: null,
            }),
          (i = h.hasEagerState ? h.eagerState : n(i, h.action));
      else {
        var v = {
          lane: p,
          action: h.action,
          hasEagerState: h.hasEagerState,
          eagerState: h.eagerState,
          next: null,
        };
        u === null ? ((a = u = v), (o = i)) : (u = u.next = v),
          (wn.lanes |= p),
          (Bl |= p);
      }
      h = h.next;
    } while (h !== null && h !== s);
    u === null ? (o = i) : (u.next = a),
      os(i, e.memoizedState) || (Yi = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = u),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (wn.lanes |= s), (Bl |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function g0(n) {
  var e = Gr(),
    t = e.queue;
  if (t === null) throw Error(Ie(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    os(s, e.memoizedState) || (Yi = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function iP() {}
function rP(n, e) {
  var t = wn,
    i = Gr(),
    r = e(),
    s = !os(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (Yi = !0)),
    (i = i.queue),
    sw(aP.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (Jn !== null && Jn.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      wh(9, oP.bind(null, t, i, r, e), void 0, null),
      ti === null)
    )
      throw Error(Ie(349));
    Fl & 30 || sP(t, e, r);
  }
  return r;
}
function sP(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = wn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (wn.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function oP(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), lP(e) && uP(n);
}
function aP(n, e, t) {
  return t(function () {
    lP(e) && uP(n);
  });
}
function lP(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !os(n, t);
  } catch {
    return !0;
  }
}
function uP(n) {
  var e = fo(n, 1);
  e !== null && ss(e, n, 1, -1);
}
function UE(n) {
  var e = Ss();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Sh,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = UN.bind(null, wn, n)),
    [e.memoizedState, n]
  );
}
function wh(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = wn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (wn.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function cP() {
  return Gr().memoizedState;
}
function Wm(n, e, t, i) {
  var r = Ss();
  (wn.flags |= n),
    (r.memoizedState = wh(1 | e, t, void 0, i === void 0 ? null : i));
}
function nv(n, e, t, i) {
  var r = Gr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Gn !== null) {
    var o = Gn.memoizedState;
    if (((s = o.destroy), i !== null && nw(i, o.deps))) {
      r.memoizedState = wh(e, t, s, i);
      return;
    }
  }
  (wn.flags |= n), (r.memoizedState = wh(1 | e, t, s, i));
}
function FE(n, e) {
  return Wm(8390656, 8, n, e);
}
function sw(n, e) {
  return nv(2048, 8, n, e);
}
function dP(n, e) {
  return nv(4, 2, n, e);
}
function hP(n, e) {
  return nv(4, 4, n, e);
}
function fP(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function pP(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), nv(4, 4, fP.bind(null, e, n), t)
  );
}
function ow() {}
function mP(n, e) {
  var t = Gr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && nw(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function gP(n, e) {
  var t = Gr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && nw(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function vP(n, e, t) {
  return Fl & 21
    ? (os(t, e) || ((t = xA()), (wn.lanes |= t), (Bl |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (Yi = !0)), (n.memoizedState = t));
}
function DN(n, e) {
  var t = sn;
  (sn = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = p0.transition;
  p0.transition = {};
  try {
    n(!1), e();
  } finally {
    (sn = t), (p0.transition = i);
  }
}
function yP() {
  return Gr().memoizedState;
}
function kN(n, e, t) {
  var i = ga(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    _P(n))
  )
    xP(e, t);
  else if (((t = KA(n, e, t, i)), t !== null)) {
    var r = ki();
    ss(t, n, i, r), SP(t, e, i);
  }
}
function UN(n, e, t) {
  var i = ga(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (_P(n)) xP(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), os(a, o))) {
          var u = e.interleaved;
          u === null
            ? ((r.next = r), QS(e))
            : ((r.next = u.next), (u.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = KA(n, e, r, i)),
      t !== null && ((r = ki()), ss(t, n, i, r), SP(t, e, i));
  }
}
function _P(n) {
  var e = n.alternate;
  return n === wn || (e !== null && e === wn);
}
function xP(n, e) {
  Kd = Tg = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function SP(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), US(n, t);
  }
}
var Cg = {
    readContext: Vr,
    useCallback: vi,
    useContext: vi,
    useEffect: vi,
    useImperativeHandle: vi,
    useInsertionEffect: vi,
    useLayoutEffect: vi,
    useMemo: vi,
    useReducer: vi,
    useRef: vi,
    useState: vi,
    useDebugValue: vi,
    useDeferredValue: vi,
    useTransition: vi,
    useMutableSource: vi,
    useSyncExternalStore: vi,
    useId: vi,
    unstable_isNewReconciler: !1,
  },
  FN = {
    readContext: Vr,
    useCallback: function (n, e) {
      return (Ss().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: Vr,
    useEffect: FE,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Wm(4194308, 4, fP.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Wm(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Wm(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = Ss();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = Ss();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = kN.bind(null, wn, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = Ss();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: UE,
    useDebugValue: ow,
    useDeferredValue: function (n) {
      return (Ss().memoizedState = n);
    },
    useTransition: function () {
      var n = UE(!1),
        e = n[0];
      return (n = DN.bind(null, n[1])), (Ss().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = wn,
        r = Ss();
      if (vn) {
        if (t === void 0) throw Error(Ie(407));
        t = t();
      } else {
        if (((t = e()), ti === null)) throw Error(Ie(349));
        Fl & 30 || sP(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        FE(aP.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        wh(9, oP.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = Ss(),
        e = ti.identifierPrefix;
      if (vn) {
        var t = ro,
          i = io;
        (t = (i & ~(1 << (32 - rs(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = xh++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = NN++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  BN = {
    readContext: Vr,
    useCallback: mP,
    useContext: Vr,
    useEffect: sw,
    useImperativeHandle: pP,
    useInsertionEffect: dP,
    useLayoutEffect: hP,
    useMemo: gP,
    useReducer: m0,
    useRef: cP,
    useState: function () {
      return m0(Sh);
    },
    useDebugValue: ow,
    useDeferredValue: function (n) {
      var e = Gr();
      return vP(e, Gn.memoizedState, n);
    },
    useTransition: function () {
      var n = m0(Sh)[0],
        e = Gr().memoizedState;
      return [n, e];
    },
    useMutableSource: iP,
    useSyncExternalStore: rP,
    useId: yP,
    unstable_isNewReconciler: !1,
  },
  zN = {
    readContext: Vr,
    useCallback: mP,
    useContext: Vr,
    useEffect: sw,
    useImperativeHandle: pP,
    useInsertionEffect: dP,
    useLayoutEffect: hP,
    useMemo: gP,
    useReducer: g0,
    useRef: cP,
    useState: function () {
      return g0(Sh);
    },
    useDebugValue: ow,
    useDeferredValue: function (n) {
      var e = Gr();
      return Gn === null ? (e.memoizedState = n) : vP(e, Gn.memoizedState, n);
    },
    useTransition: function () {
      var n = g0(Sh)[0],
        e = Gr().memoizedState;
      return [n, e];
    },
    useMutableSource: iP,
    useSyncExternalStore: rP,
    useId: yP,
    unstable_isNewReconciler: !1,
  };
function Nc(n, e) {
  try {
    var t = "",
      i = e;
    do (t += pO(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function v0(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function K_(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var HN = typeof WeakMap == "function" ? WeakMap : Map;
function wP(n, e, t) {
  (t = lo(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      Ag || ((Ag = !0), (ox = i)), K_(n, e);
    }),
    t
  );
}
function MP(n, e, t) {
  (t = lo(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        K_(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        K_(n, e),
          typeof i != "function" &&
            (ma === null ? (ma = new Set([this])) : ma.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function BE(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new HN();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = tD.bind(null, n, e, t)), e.then(n, n));
}
function zE(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function HE(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = lo(-1, 1)), (e.tag = 2), pa(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var VN = _o.ReactCurrentOwner,
  Yi = !1;
function Oi(n, e, t, i) {
  e.child = n === null ? tP(e, null, t, i) : Ic(e, n.child, t, i);
}
function VE(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    uc(e, r),
    (i = iw(n, e, t, i, s, r)),
    (t = rw()),
    n !== null && !Yi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        po(n, e, r))
      : (vn && t && jS(e), (e.flags |= 1), Oi(n, e, i, r), e.child)
  );
}
function GE(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !pw(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), EP(n, e, s, i, r))
      : ((n = $m(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : ph), t(o, i) && n.ref === e.ref)
    )
      return po(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = va(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function EP(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (ph(s, i) && n.ref === e.ref)
      if (((Yi = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (Yi = !0);
      else return (e.lanes = n.lanes), po(n, e, r);
  }
  return Q_(n, e, t, i, r);
}
function TP(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        cn(Zu, ur),
        (ur |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          cn(Zu, ur),
          (ur |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        cn(Zu, ur),
        (ur |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      cn(Zu, ur),
      (ur |= i);
  return Oi(n, e, r, t), e.child;
}
function CP(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Q_(n, e, t, i, r) {
  var s = Qi(t) ? kl : Ti.current;
  return (
    (s = Rc(e, s)),
    uc(e, r),
    (t = iw(n, e, t, i, s, r)),
    (i = rw()),
    n !== null && !Yi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        po(n, e, r))
      : (vn && i && jS(e), (e.flags |= 1), Oi(n, e, t, r), e.child)
  );
}
function WE(n, e, t, i, r) {
  if (Qi(t)) {
    var s = !0;
    yg(e);
  } else s = !1;
  if ((uc(e, r), e.stateNode === null))
    jm(n, e), JA(e, t, i), Y_(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var u = o.context,
      h = t.contextType;
    typeof h == "object" && h !== null
      ? (h = Vr(h))
      : ((h = Qi(t) ? kl : Ti.current), (h = Rc(e, h)));
    var p = t.getDerivedStateFromProps,
      v =
        typeof p == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    v ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || u !== h) && DE(e, o, i, h)),
      ($o = !1);
    var y = e.memoizedState;
    (o.state = y),
      Mg(e, i, o, r),
      (u = e.memoizedState),
      a !== i || y !== u || Ki.current || $o
        ? (typeof p == "function" && ($_(e, t, p, i), (u = e.memoizedState)),
          (a = $o || NE(e, t, a, i, y, u, h))
            ? (v ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = u)),
          (o.props = i),
          (o.state = u),
          (o.context = h),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      QA(n, e),
      (a = e.memoizedProps),
      (h = e.type === e.elementType ? a : Zr(e.type, a)),
      (o.props = h),
      (v = e.pendingProps),
      (y = o.context),
      (u = t.contextType),
      typeof u == "object" && u !== null
        ? (u = Vr(u))
        : ((u = Qi(t) ? kl : Ti.current), (u = Rc(e, u)));
    var S = t.getDerivedStateFromProps;
    (p =
      typeof S == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== v || y !== u) && DE(e, o, i, u)),
      ($o = !1),
      (y = e.memoizedState),
      (o.state = y),
      Mg(e, i, o, r);
    var x = e.memoizedState;
    a !== v || y !== x || Ki.current || $o
      ? (typeof S == "function" && ($_(e, t, S, i), (x = e.memoizedState)),
        (h = $o || NE(e, t, h, i, y, x, u) || !1)
          ? (p ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, x, u),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, x, u)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && y === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && y === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = x)),
        (o.props = i),
        (o.state = x),
        (o.context = u),
        (i = h))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && y === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && y === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Z_(n, e, t, i, s, r);
}
function Z_(n, e, t, i, r, s) {
  CP(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && PE(e, t, !1), po(n, e, s);
  (i = e.stateNode), (VN.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = Ic(e, n.child, null, s)), (e.child = Ic(e, null, a, s)))
      : Oi(n, e, a, s),
    (e.memoizedState = i.state),
    r && PE(e, t, !0),
    e.child
  );
}
function bP(n) {
  var e = n.stateNode;
  e.pendingContext
    ? AE(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && AE(n, e.context, !1),
    JS(n, e.containerInfo);
}
function jE(n, e, t, i, r) {
  return Lc(), qS(r), (e.flags |= 256), Oi(n, e, t, i), e.child;
}
var J_ = { dehydrated: null, treeContext: null, retryLane: 0 };
function ex(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function AP(n, e, t) {
  var i = e.pendingProps,
    r = _n.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    cn(_n, r & 1),
    n === null)
  )
    return (
      X_(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = sv(o, i, 0, null)),
              (n = Al(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = ex(t)),
              (e.memoizedState = J_),
              n)
            : aw(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return GN(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var u = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = u),
          (e.deletions = null))
        : ((i = va(r, u)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = va(a, s)) : ((s = Al(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? ex(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = J_),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = va(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function aw(n, e) {
  return (
    (e = sv({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Np(n, e, t, i) {
  return (
    i !== null && qS(i),
    Ic(e, n.child, null, t),
    (n = aw(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function GN(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = v0(Error(Ie(422)))), Np(n, e, o, i))
      : e.memoizedState !== null
        ? ((e.child = n.child), (e.flags |= 128), null)
        : ((s = i.fallback),
          (r = e.mode),
          (i = sv({ mode: "visible", children: i.children }, r, 0, null)),
          (s = Al(s, r, o, null)),
          (s.flags |= 2),
          (i.return = e),
          (s.return = e),
          (i.sibling = s),
          (e.child = i),
          e.mode & 1 && Ic(e, n.child, null, o),
          (e.child.memoizedState = ex(o)),
          (e.memoizedState = J_),
          s);
  if (!(e.mode & 1)) return Np(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(Ie(419))), (i = v0(s, i, void 0)), Np(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), Yi || a)) {
    if (((i = ti), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), fo(n, r), ss(i, n, r, -1));
    }
    return fw(), (i = v0(Error(Ie(421)))), Np(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = nD.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (fr = fa(r.nextSibling)),
      (mr = e),
      (vn = !0),
      (ns = null),
      n !== null &&
        ((Ur[Fr++] = io),
        (Ur[Fr++] = ro),
        (Ur[Fr++] = Ul),
        (io = n.id),
        (ro = n.overflow),
        (Ul = e)),
      (e = aw(e, i.children)),
      (e.flags |= 4096),
      e);
}
function XE(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), q_(n.return, e, t);
}
function y0(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function PP(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((Oi(n, e, i.children, t), (i = _n.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && XE(n, t, e);
        else if (n.tag === 19) XE(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((cn(_n, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && Eg(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          y0(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && Eg(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        y0(e, !0, t, null, s);
        break;
      case "together":
        y0(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function jm(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function po(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (Bl |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(Ie(153));
  if (e.child !== null) {
    for (
      n = e.child, t = va(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = va(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function WN(n, e, t) {
  switch (e.tag) {
    case 3:
      bP(e), Lc();
      break;
    case 5:
      nP(e);
      break;
    case 1:
      Qi(e.type) && yg(e);
      break;
    case 4:
      JS(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      cn(Sg, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (cn(_n, _n.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
            ? AP(n, e, t)
            : (cn(_n, _n.current & 1),
              (n = po(n, e, t)),
              n !== null ? n.sibling : null);
      cn(_n, _n.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return PP(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        cn(_n, _n.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), TP(n, e, t);
  }
  return po(n, e, t);
}
var RP, tx, LP, IP;
RP = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
tx = function () {};
LP = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), fl(Ls.current);
    var s = null;
    switch (t) {
      case "input":
        (r = M_(n, r)), (i = M_(n, i)), (s = []);
        break;
      case "select":
        (r = En({}, r, { value: void 0 })),
          (i = En({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = C_(n, r)), (i = C_(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = gg);
    }
    A_(t, i);
    var o;
    t = null;
    for (h in r)
      if (!i.hasOwnProperty(h) && r.hasOwnProperty(h) && r[h] != null)
        if (h === "style") {
          var a = r[h];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          h !== "dangerouslySetInnerHTML" &&
            h !== "children" &&
            h !== "suppressContentEditableWarning" &&
            h !== "suppressHydrationWarning" &&
            h !== "autoFocus" &&
            (ah.hasOwnProperty(h)
              ? s || (s = [])
              : (s = s || []).push(h, null));
    for (h in i) {
      var u = i[h];
      if (
        ((a = r != null ? r[h] : void 0),
        i.hasOwnProperty(h) && u !== a && (u != null || a != null))
      )
        if (h === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (u && u.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in u)
              u.hasOwnProperty(o) &&
                a[o] !== u[o] &&
                (t || (t = {}), (t[o] = u[o]));
          } else t || (s || (s = []), s.push(h, t)), (t = u);
        else
          h === "dangerouslySetInnerHTML"
            ? ((u = u ? u.__html : void 0),
              (a = a ? a.__html : void 0),
              u != null && a !== u && (s = s || []).push(h, u))
            : h === "children"
              ? (typeof u != "string" && typeof u != "number") ||
                (s = s || []).push(h, "" + u)
              : h !== "suppressContentEditableWarning" &&
                h !== "suppressHydrationWarning" &&
                (ah.hasOwnProperty(h)
                  ? (u != null && h === "onScroll" && dn("scroll", n),
                    s || a === u || (s = []))
                  : (s = s || []).push(h, u));
    }
    t && (s = s || []).push("style", t);
    var h = s;
    (e.updateQueue = h) && (e.flags |= 4);
  }
};
IP = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Sd(n, e) {
  if (!vn)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function yi(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function jN(n, e, t) {
  var i = e.pendingProps;
  switch ((XS(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return yi(e), null;
    case 1:
      return Qi(e.type) && vg(), yi(e), null;
    case 3:
      return (
        (i = e.stateNode),
        Oc(),
        pn(Ki),
        pn(Ti),
        tw(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (Ip(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), ns !== null && (ux(ns), (ns = null)))),
        tx(n, e),
        yi(e),
        null
      );
    case 5:
      ew(e);
      var r = fl(_h.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        LP(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(Ie(166));
          return yi(e), null;
        }
        if (((n = fl(Ls.current)), Ip(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[Cs] = e), (i[vh] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              dn("cancel", i), dn("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              dn("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < zd.length; r++) dn(zd[r], i);
              break;
            case "source":
              dn("error", i);
              break;
            case "img":
            case "image":
            case "link":
              dn("error", i), dn("load", i);
              break;
            case "details":
              dn("toggle", i);
              break;
            case "input":
              tE(i, s), dn("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                dn("invalid", i);
              break;
            case "textarea":
              iE(i, s), dn("invalid", i);
          }
          A_(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Lp(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Lp(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : ah.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  dn("scroll", i);
            }
          switch (t) {
            case "input":
              Mp(i), nE(i, s, !0);
              break;
            case "textarea":
              Mp(i), rE(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = gg);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = sA(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                  ? (n = o.createElement(t, { is: i.is }))
                  : ((n = o.createElement(t)),
                    t === "select" &&
                      ((o = n),
                      i.multiple
                        ? (o.multiple = !0)
                        : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[Cs] = e),
            (n[vh] = i),
            RP(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = P_(t, i)), t)) {
              case "dialog":
                dn("cancel", n), dn("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                dn("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < zd.length; r++) dn(zd[r], n);
                r = i;
                break;
              case "source":
                dn("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                dn("error", n), dn("load", n), (r = i);
                break;
              case "details":
                dn("toggle", n), (r = i);
                break;
              case "input":
                tE(n, i), (r = M_(n, i)), dn("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = En({}, i, { value: void 0 })),
                  dn("invalid", n);
                break;
              case "textarea":
                iE(n, i), (r = C_(n, i)), dn("invalid", n);
                break;
              default:
                r = i;
            }
            A_(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var u = a[s];
                s === "style"
                  ? lA(n, u)
                  : s === "dangerouslySetInnerHTML"
                    ? ((u = u ? u.__html : void 0), u != null && oA(n, u))
                    : s === "children"
                      ? typeof u == "string"
                        ? (t !== "textarea" || u !== "") && lh(n, u)
                        : typeof u == "number" && lh(n, "" + u)
                      : s !== "suppressContentEditableWarning" &&
                        s !== "suppressHydrationWarning" &&
                        s !== "autoFocus" &&
                        (ah.hasOwnProperty(s)
                          ? u != null && s === "onScroll" && dn("scroll", n)
                          : u != null && LS(n, s, u, o));
              }
            switch (t) {
              case "input":
                Mp(n), nE(n, i, !1);
                break;
              case "textarea":
                Mp(n), rE(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + Sa(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? sc(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      sc(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = gg);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return yi(e), null;
    case 6:
      if (n && e.stateNode != null) IP(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(Ie(166));
        if (((t = fl(_h.current)), fl(Ls.current), Ip(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[Cs] = e),
            (s = i.nodeValue !== t) && ((n = mr), n !== null))
          )
            switch (n.tag) {
              case 3:
                Lp(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Lp(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[Cs] = e),
            (e.stateNode = i);
      }
      return yi(e), null;
    case 13:
      if (
        (pn(_n),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (vn && fr !== null && e.mode & 1 && !(e.flags & 128))
          YA(), Lc(), (e.flags |= 98560), (s = !1);
        else if (((s = Ip(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(Ie(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Ie(317));
            s[Cs] = e;
          } else
            Lc(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          yi(e), (s = !1);
        } else ns !== null && (ux(ns), (ns = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || _n.current & 1 ? jn === 0 && (jn = 3) : fw())),
          e.updateQueue !== null && (e.flags |= 4),
          yi(e),
          null);
    case 4:
      return (
        Oc(), tx(n, e), n === null && mh(e.stateNode.containerInfo), yi(e), null
      );
    case 10:
      return KS(e.type._context), yi(e), null;
    case 17:
      return Qi(e.type) && vg(), yi(e), null;
    case 19:
      if ((pn(_n), (s = e.memoizedState), s === null)) return yi(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Sd(s, !1);
        else {
          if (jn !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = Eg(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Sd(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return cn(_n, (_n.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            On() > Dc &&
            ((e.flags |= 128), (i = !0), Sd(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = Eg(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Sd(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !vn)
            )
              return yi(e), null;
          } else
            2 * On() - s.renderingStartTime > Dc &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Sd(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = On()),
          (e.sibling = null),
          (t = _n.current),
          cn(_n, i ? (t & 1) | 2 : t & 1),
          e)
        : (yi(e), null);
    case 22:
    case 23:
      return (
        hw(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? ur & 1073741824 && (yi(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : yi(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Ie(156, e.tag));
}
function XN(n, e) {
  switch ((XS(e), e.tag)) {
    case 1:
      return (
        Qi(e.type) && vg(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Oc(),
        pn(Ki),
        pn(Ti),
        tw(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return ew(e), null;
    case 13:
      if (
        (pn(_n), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Ie(340));
        Lc();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return pn(_n), null;
    case 4:
      return Oc(), null;
    case 10:
      return KS(e.type._context), null;
    case 22:
    case 23:
      return hw(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Dp = !1,
  wi = !1,
  qN = typeof WeakSet == "function" ? WeakSet : Set,
  it = null;
function Qu(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        bn(n, e, i);
      }
    else t.current = null;
}
function nx(n, e, t) {
  try {
    t();
  } catch (i) {
    bn(n, e, i);
  }
}
var qE = !1;
function $N(n, e) {
  if (((B_ = fg), (n = kA()), WS(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            u = -1,
            h = 0,
            p = 0,
            v = n,
            y = null;
          t: for (;;) {
            for (
              var S;
              v !== t || (r !== 0 && v.nodeType !== 3) || (a = o + r),
                v !== s || (i !== 0 && v.nodeType !== 3) || (u = o + i),
                v.nodeType === 3 && (o += v.nodeValue.length),
                (S = v.firstChild) !== null;

            )
              (y = v), (v = S);
            for (;;) {
              if (v === n) break t;
              if (
                (y === t && ++h === r && (a = o),
                y === s && ++p === i && (u = o),
                (S = v.nextSibling) !== null)
              )
                break;
              (v = y), (y = v.parentNode);
            }
            v = S;
          }
          t = a === -1 || u === -1 ? null : { start: a, end: u };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    z_ = { focusedElem: n, selectionRange: t }, fg = !1, it = e;
    it !== null;

  )
    if (((e = it), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (it = n);
    else
      for (; it !== null; ) {
        e = it;
        try {
          var x = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (x !== null) {
                  var _ = x.memoizedProps,
                    f = x.memoizedState,
                    d = e.stateNode,
                    m = d.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? _ : Zr(e.type, _),
                      f,
                    );
                  d.__reactInternalSnapshotBeforeUpdate = m;
                }
                break;
              case 3:
                var g = e.stateNode.containerInfo;
                g.nodeType === 1
                  ? (g.textContent = "")
                  : g.nodeType === 9 &&
                    g.documentElement &&
                    g.removeChild(g.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Ie(163));
            }
        } catch (w) {
          bn(e, e.return, w);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (it = n);
          break;
        }
        it = e.return;
      }
  return (x = qE), (qE = !1), x;
}
function Qd(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && nx(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function iv(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function ix(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function OP(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), OP(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[Cs], delete e[vh], delete e[G_], delete e[RN], delete e[LN])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function NP(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function $E(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || NP(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function rx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = gg));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (rx(n, e, t), n = n.sibling; n !== null; ) rx(n, e, t), (n = n.sibling);
}
function sx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (sx(n, e, t), n = n.sibling; n !== null; ) sx(n, e, t), (n = n.sibling);
}
var si = null,
  ts = !1;
function ko(n, e, t) {
  for (t = t.child; t !== null; ) DP(n, e, t), (t = t.sibling);
}
function DP(n, e, t) {
  if (Rs && typeof Rs.onCommitFiberUnmount == "function")
    try {
      Rs.onCommitFiberUnmount(Yg, t);
    } catch {}
  switch (t.tag) {
    case 5:
      wi || Qu(t, e);
    case 6:
      var i = si,
        r = ts;
      (si = null),
        ko(n, e, t),
        (si = i),
        (ts = r),
        si !== null &&
          (ts
            ? ((n = si),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : si.removeChild(t.stateNode));
      break;
    case 18:
      si !== null &&
        (ts
          ? ((n = si),
            (t = t.stateNode),
            n.nodeType === 8
              ? d0(n.parentNode, t)
              : n.nodeType === 1 && d0(n, t),
            hh(n))
          : d0(si, t.stateNode));
      break;
    case 4:
      (i = si),
        (r = ts),
        (si = t.stateNode.containerInfo),
        (ts = !0),
        ko(n, e, t),
        (si = i),
        (ts = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !wi &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && nx(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      ko(n, e, t);
      break;
    case 1:
      if (
        !wi &&
        (Qu(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          bn(t, e, a);
        }
      ko(n, e, t);
      break;
    case 21:
      ko(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((wi = (i = wi) || t.memoizedState !== null), ko(n, e, t), (wi = i))
        : ko(n, e, t);
      break;
    default:
      ko(n, e, t);
  }
}
function YE(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new qN()),
      e.forEach(function (i) {
        var r = iD.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function $r(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (si = a.stateNode), (ts = !1);
              break e;
            case 3:
              (si = a.stateNode.containerInfo), (ts = !0);
              break e;
            case 4:
              (si = a.stateNode.containerInfo), (ts = !0);
              break e;
          }
          a = a.return;
        }
        if (si === null) throw Error(Ie(160));
        DP(s, o, r), (si = null), (ts = !1);
        var u = r.alternate;
        u !== null && (u.return = null), (r.return = null);
      } catch (h) {
        bn(r, e, h);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) kP(e, n), (e = e.sibling);
}
function kP(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (($r(e, n), xs(n), i & 4)) {
        try {
          Qd(3, n, n.return), iv(3, n);
        } catch (_) {
          bn(n, n.return, _);
        }
        try {
          Qd(5, n, n.return);
        } catch (_) {
          bn(n, n.return, _);
        }
      }
      break;
    case 1:
      $r(e, n), xs(n), i & 512 && t !== null && Qu(t, t.return);
      break;
    case 5:
      if (
        ($r(e, n),
        xs(n),
        i & 512 && t !== null && Qu(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          lh(r, "");
        } catch (_) {
          bn(n, n.return, _);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          u = n.updateQueue;
        if (((n.updateQueue = null), u !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && iA(r, s),
              P_(a, o);
            var h = P_(a, s);
            for (o = 0; o < u.length; o += 2) {
              var p = u[o],
                v = u[o + 1];
              p === "style"
                ? lA(r, v)
                : p === "dangerouslySetInnerHTML"
                  ? oA(r, v)
                  : p === "children"
                    ? lh(r, v)
                    : LS(r, p, v, h);
            }
            switch (a) {
              case "input":
                E_(r, s);
                break;
              case "textarea":
                rA(r, s);
                break;
              case "select":
                var y = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var S = s.value;
                S != null
                  ? sc(r, !!s.multiple, S, !1)
                  : y !== !!s.multiple &&
                    (s.defaultValue != null
                      ? sc(r, !!s.multiple, s.defaultValue, !0)
                      : sc(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[vh] = s;
          } catch (_) {
            bn(n, n.return, _);
          }
      }
      break;
    case 6:
      if (($r(e, n), xs(n), i & 4)) {
        if (n.stateNode === null) throw Error(Ie(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (_) {
          bn(n, n.return, _);
        }
      }
      break;
    case 3:
      if (
        ($r(e, n), xs(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          hh(e.containerInfo);
        } catch (_) {
          bn(n, n.return, _);
        }
      break;
    case 4:
      $r(e, n), xs(n);
      break;
    case 13:
      $r(e, n),
        xs(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (cw = On())),
        i & 4 && YE(n);
      break;
    case 22:
      if (
        ((p = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((wi = (h = wi) || p), $r(e, n), (wi = h)) : $r(e, n),
        xs(n),
        i & 8192)
      ) {
        if (
          ((h = n.memoizedState !== null),
          (n.stateNode.isHidden = h) && !p && n.mode & 1)
        )
          for (it = n, p = n.child; p !== null; ) {
            for (v = it = p; it !== null; ) {
              switch (((y = it), (S = y.child), y.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qd(4, y, y.return);
                  break;
                case 1:
                  Qu(y, y.return);
                  var x = y.stateNode;
                  if (typeof x.componentWillUnmount == "function") {
                    (i = y), (t = y.return);
                    try {
                      (e = i),
                        (x.props = e.memoizedProps),
                        (x.state = e.memoizedState),
                        x.componentWillUnmount();
                    } catch (_) {
                      bn(i, t, _);
                    }
                  }
                  break;
                case 5:
                  Qu(y, y.return);
                  break;
                case 22:
                  if (y.memoizedState !== null) {
                    QE(v);
                    continue;
                  }
              }
              S !== null ? ((S.return = y), (it = S)) : QE(v);
            }
            p = p.sibling;
          }
        e: for (p = null, v = n; ; ) {
          if (v.tag === 5) {
            if (p === null) {
              p = v;
              try {
                (r = v.stateNode),
                  h
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = v.stateNode),
                      (u = v.memoizedProps.style),
                      (o =
                        u != null && u.hasOwnProperty("display")
                          ? u.display
                          : null),
                      (a.style.display = aA("display", o)));
              } catch (_) {
                bn(n, n.return, _);
              }
            }
          } else if (v.tag === 6) {
            if (p === null)
              try {
                v.stateNode.nodeValue = h ? "" : v.memoizedProps;
              } catch (_) {
                bn(n, n.return, _);
              }
          } else if (
            ((v.tag !== 22 && v.tag !== 23) ||
              v.memoizedState === null ||
              v === n) &&
            v.child !== null
          ) {
            (v.child.return = v), (v = v.child);
            continue;
          }
          if (v === n) break e;
          for (; v.sibling === null; ) {
            if (v.return === null || v.return === n) break e;
            p === v && (p = null), (v = v.return);
          }
          p === v && (p = null), (v.sibling.return = v.return), (v = v.sibling);
        }
      }
      break;
    case 19:
      $r(e, n), xs(n), i & 4 && YE(n);
      break;
    case 21:
      break;
    default:
      $r(e, n), xs(n);
  }
}
function xs(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (NP(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Ie(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (lh(r, ""), (i.flags &= -33));
          var s = $E(n);
          sx(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = $E(n);
          rx(n, a, o);
          break;
        default:
          throw Error(Ie(161));
      }
    } catch (u) {
      bn(n, n.return, u);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function YN(n, e, t) {
  (it = n), UP(n);
}
function UP(n, e, t) {
  for (var i = (n.mode & 1) !== 0; it !== null; ) {
    var r = it,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || Dp;
      if (!o) {
        var a = r.alternate,
          u = (a !== null && a.memoizedState !== null) || wi;
        a = Dp;
        var h = wi;
        if (((Dp = o), (wi = u) && !h))
          for (it = r; it !== null; )
            (o = it),
              (u = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? ZE(r)
                : u !== null
                  ? ((u.return = o), (it = u))
                  : ZE(r);
        for (; s !== null; ) (it = s), UP(s), (s = s.sibling);
        (it = r), (Dp = a), (wi = h);
      }
      KE(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (it = s)) : KE(n);
  }
}
function KE(n) {
  for (; it !== null; ) {
    var e = it;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              wi || iv(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !wi)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Zr(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate,
                  );
                }
              var s = e.updateQueue;
              s !== null && OE(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                OE(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var u = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    u.autoFocus && t.focus();
                    break;
                  case "img":
                    u.src && (t.src = u.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var h = e.alternate;
                if (h !== null) {
                  var p = h.memoizedState;
                  if (p !== null) {
                    var v = p.dehydrated;
                    v !== null && hh(v);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Ie(163));
          }
        wi || (e.flags & 512 && ix(e));
      } catch (y) {
        bn(e, e.return, y);
      }
    }
    if (e === n) {
      it = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (it = t);
      break;
    }
    it = e.return;
  }
}
function QE(n) {
  for (; it !== null; ) {
    var e = it;
    if (e === n) {
      it = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (it = t);
      break;
    }
    it = e.return;
  }
}
function ZE(n) {
  for (; it !== null; ) {
    var e = it;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            iv(4, e);
          } catch (u) {
            bn(e, t, u);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (u) {
              bn(e, r, u);
            }
          }
          var s = e.return;
          try {
            ix(e);
          } catch (u) {
            bn(e, s, u);
          }
          break;
        case 5:
          var o = e.return;
          try {
            ix(e);
          } catch (u) {
            bn(e, o, u);
          }
      }
    } catch (u) {
      bn(e, e.return, u);
    }
    if (e === n) {
      it = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (it = a);
      break;
    }
    it = e.return;
  }
}
var KN = Math.ceil,
  bg = _o.ReactCurrentDispatcher,
  lw = _o.ReactCurrentOwner,
  Hr = _o.ReactCurrentBatchConfig,
  jt = 0,
  ti = null,
  Fn = null,
  ai = 0,
  ur = 0,
  Zu = Aa(0),
  jn = 0,
  Mh = null,
  Bl = 0,
  rv = 0,
  uw = 0,
  Zd = null,
  $i = null,
  cw = 0,
  Dc = 1 / 0,
  eo = null,
  Ag = !1,
  ox = null,
  ma = null,
  kp = !1,
  la = null,
  Pg = 0,
  Jd = 0,
  ax = null,
  Xm = -1,
  qm = 0;
function ki() {
  return jt & 6 ? On() : Xm !== -1 ? Xm : (Xm = On());
}
function ga(n) {
  return n.mode & 1
    ? jt & 2 && ai !== 0
      ? ai & -ai
      : ON.transition !== null
        ? (qm === 0 && (qm = xA()), qm)
        : ((n = sn),
          n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : bA(n.type))),
          n)
    : 1;
}
function ss(n, e, t, i) {
  if (50 < Jd) throw ((Jd = 0), (ax = null), Error(Ie(185)));
  uf(n, t, i),
    (!(jt & 2) || n !== ti) &&
      (n === ti && (!(jt & 2) && (rv |= t), jn === 4 && Qo(n, ai)),
      Zi(n, i),
      t === 1 && jt === 0 && !(e.mode & 1) && ((Dc = On() + 500), ev && Pa()));
}
function Zi(n, e) {
  var t = n.callbackNode;
  OO(n, e);
  var i = hg(n, n === ti ? ai : 0);
  if (i === 0)
    t !== null && aE(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && aE(t), e === 1))
      n.tag === 0 ? IN(JE.bind(null, n)) : XA(JE.bind(null, n)),
        AN(function () {
          !(jt & 6) && Pa();
        }),
        (t = null);
    else {
      switch (SA(i)) {
        case 1:
          t = kS;
          break;
        case 4:
          t = yA;
          break;
        case 16:
          t = dg;
          break;
        case 536870912:
          t = _A;
          break;
        default:
          t = dg;
      }
      t = jP(t, FP.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function FP(n, e) {
  if (((Xm = -1), (qm = 0), jt & 6)) throw Error(Ie(327));
  var t = n.callbackNode;
  if (cc() && n.callbackNode !== t) return null;
  var i = hg(n, n === ti ? ai : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = Rg(n, i);
  else {
    e = i;
    var r = jt;
    jt |= 2;
    var s = zP();
    (ti !== n || ai !== e) && ((eo = null), (Dc = On() + 500), bl(n, e));
    do
      try {
        JN();
        break;
      } catch (a) {
        BP(n, a);
      }
    while (1);
    YS(),
      (bg.current = s),
      (jt = r),
      Fn !== null ? (e = 0) : ((ti = null), (ai = 0), (e = jn));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = N_(n)), r !== 0 && ((i = r), (e = lx(n, r)))), e === 1)
    )
      throw ((t = Mh), bl(n, 0), Qo(n, i), Zi(n, On()), t);
    if (e === 6) Qo(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !QN(r) &&
          ((e = Rg(n, i)),
          e === 2 && ((s = N_(n)), s !== 0 && ((i = s), (e = lx(n, s)))),
          e === 1))
      )
        throw ((t = Mh), bl(n, 0), Qo(n, i), Zi(n, On()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(Ie(345));
        case 2:
          sl(n, $i, eo);
          break;
        case 3:
          if (
            (Qo(n, i), (i & 130023424) === i && ((e = cw + 500 - On()), 10 < e))
          ) {
            if (hg(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              ki(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = V_(sl.bind(null, n, $i, eo), e);
            break;
          }
          sl(n, $i, eo);
          break;
        case 4:
          if ((Qo(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - rs(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = On() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                  ? 480
                  : 1080 > i
                    ? 1080
                    : 1920 > i
                      ? 1920
                      : 3e3 > i
                        ? 3e3
                        : 4320 > i
                          ? 4320
                          : 1960 * KN(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = V_(sl.bind(null, n, $i, eo), i);
            break;
          }
          sl(n, $i, eo);
          break;
        case 5:
          sl(n, $i, eo);
          break;
        default:
          throw Error(Ie(329));
      }
    }
  }
  return Zi(n, On()), n.callbackNode === t ? FP.bind(null, n) : null;
}
function lx(n, e) {
  var t = Zd;
  return (
    n.current.memoizedState.isDehydrated && (bl(n, e).flags |= 256),
    (n = Rg(n, e)),
    n !== 2 && ((e = $i), ($i = t), e !== null && ux(e)),
    n
  );
}
function ux(n) {
  $i === null ? ($i = n) : $i.push.apply($i, n);
}
function QN(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!os(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Qo(n, e) {
  for (
    e &= ~uw,
      e &= ~rv,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - rs(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function JE(n) {
  if (jt & 6) throw Error(Ie(327));
  cc();
  var e = hg(n, 0);
  if (!(e & 1)) return Zi(n, On()), null;
  var t = Rg(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = N_(n);
    i !== 0 && ((e = i), (t = lx(n, i)));
  }
  if (t === 1) throw ((t = Mh), bl(n, 0), Qo(n, e), Zi(n, On()), t);
  if (t === 6) throw Error(Ie(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    sl(n, $i, eo),
    Zi(n, On()),
    null
  );
}
function dw(n, e) {
  var t = jt;
  jt |= 1;
  try {
    return n(e);
  } finally {
    (jt = t), jt === 0 && ((Dc = On() + 500), ev && Pa());
  }
}
function zl(n) {
  la !== null && la.tag === 0 && !(jt & 6) && cc();
  var e = jt;
  jt |= 1;
  var t = Hr.transition,
    i = sn;
  try {
    if (((Hr.transition = null), (sn = 1), n)) return n();
  } finally {
    (sn = i), (Hr.transition = t), (jt = e), !(jt & 6) && Pa();
  }
}
function hw() {
  (ur = Zu.current), pn(Zu);
}
function bl(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), bN(t)), Fn !== null))
    for (t = Fn.return; t !== null; ) {
      var i = t;
      switch ((XS(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && vg();
          break;
        case 3:
          Oc(), pn(Ki), pn(Ti), tw();
          break;
        case 5:
          ew(i);
          break;
        case 4:
          Oc();
          break;
        case 13:
          pn(_n);
          break;
        case 19:
          pn(_n);
          break;
        case 10:
          KS(i.type._context);
          break;
        case 22:
        case 23:
          hw();
      }
      t = t.return;
    }
  if (
    ((ti = n),
    (Fn = n = va(n.current, null)),
    (ai = ur = e),
    (jn = 0),
    (Mh = null),
    (uw = rv = Bl = 0),
    ($i = Zd = null),
    hl !== null)
  ) {
    for (e = 0; e < hl.length; e++)
      if (((t = hl[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    hl = null;
  }
  return n;
}
function BP(n, e) {
  do {
    var t = Fn;
    try {
      if ((YS(), (Gm.current = Cg), Tg)) {
        for (var i = wn.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        Tg = !1;
      }
      if (
        ((Fl = 0),
        (Jn = Gn = wn = null),
        (Kd = !1),
        (xh = 0),
        (lw.current = null),
        t === null || t.return === null)
      ) {
        (jn = 1), (Mh = e), (Fn = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          u = e;
        if (
          ((e = ai),
          (a.flags |= 32768),
          u !== null && typeof u == "object" && typeof u.then == "function")
        ) {
          var h = u,
            p = a,
            v = p.tag;
          if (!(p.mode & 1) && (v === 0 || v === 11 || v === 15)) {
            var y = p.alternate;
            y
              ? ((p.updateQueue = y.updateQueue),
                (p.memoizedState = y.memoizedState),
                (p.lanes = y.lanes))
              : ((p.updateQueue = null), (p.memoizedState = null));
          }
          var S = zE(o);
          if (S !== null) {
            (S.flags &= -257),
              HE(S, o, a, s, e),
              S.mode & 1 && BE(s, h, e),
              (e = S),
              (u = h);
            var x = e.updateQueue;
            if (x === null) {
              var _ = new Set();
              _.add(u), (e.updateQueue = _);
            } else x.add(u);
            break e;
          } else {
            if (!(e & 1)) {
              BE(s, h, e), fw();
              break e;
            }
            u = Error(Ie(426));
          }
        } else if (vn && a.mode & 1) {
          var f = zE(o);
          if (f !== null) {
            !(f.flags & 65536) && (f.flags |= 256),
              HE(f, o, a, s, e),
              qS(Nc(u, a));
            break e;
          }
        }
        (s = u = Nc(u, a)),
          jn !== 4 && (jn = 2),
          Zd === null ? (Zd = [s]) : Zd.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var d = wP(s, u, e);
              IE(s, d);
              break e;
            case 1:
              a = u;
              var m = s.type,
                g = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof m.getDerivedStateFromError == "function" ||
                  (g !== null &&
                    typeof g.componentDidCatch == "function" &&
                    (ma === null || !ma.has(g))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var w = MP(s, a, e);
                IE(s, w);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      VP(t);
    } catch (T) {
      (e = T), Fn === t && t !== null && (Fn = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function zP() {
  var n = bg.current;
  return (bg.current = Cg), n === null ? Cg : n;
}
function fw() {
  (jn === 0 || jn === 3 || jn === 2) && (jn = 4),
    ti === null || (!(Bl & 268435455) && !(rv & 268435455)) || Qo(ti, ai);
}
function Rg(n, e) {
  var t = jt;
  jt |= 2;
  var i = zP();
  (ti !== n || ai !== e) && ((eo = null), bl(n, e));
  do
    try {
      ZN();
      break;
    } catch (r) {
      BP(n, r);
    }
  while (1);
  if ((YS(), (jt = t), (bg.current = i), Fn !== null)) throw Error(Ie(261));
  return (ti = null), (ai = 0), jn;
}
function ZN() {
  for (; Fn !== null; ) HP(Fn);
}
function JN() {
  for (; Fn !== null && !EO(); ) HP(Fn);
}
function HP(n) {
  var e = WP(n.alternate, n, ur);
  (n.memoizedProps = n.pendingProps),
    e === null ? VP(n) : (Fn = e),
    (lw.current = null);
}
function VP(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = XN(t, e)), t !== null)) {
        (t.flags &= 32767), (Fn = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (jn = 6), (Fn = null);
        return;
      }
    } else if (((t = jN(t, e, ur)), t !== null)) {
      Fn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Fn = e;
      return;
    }
    Fn = e = n;
  } while (e !== null);
  jn === 0 && (jn = 5);
}
function sl(n, e, t) {
  var i = sn,
    r = Hr.transition;
  try {
    (Hr.transition = null), (sn = 1), eD(n, e, t, i);
  } finally {
    (Hr.transition = r), (sn = i);
  }
  return null;
}
function eD(n, e, t, i) {
  do cc();
  while (la !== null);
  if (jt & 6) throw Error(Ie(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(Ie(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (NO(n, s),
    n === ti && ((Fn = ti = null), (ai = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      kp ||
      ((kp = !0),
      jP(dg, function () {
        return cc(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Hr.transition), (Hr.transition = null);
    var o = sn;
    sn = 1;
    var a = jt;
    (jt |= 4),
      (lw.current = null),
      $N(n, t),
      kP(t, n),
      xN(z_),
      (fg = !!B_),
      (z_ = B_ = null),
      (n.current = t),
      YN(t),
      TO(),
      (jt = a),
      (sn = o),
      (Hr.transition = s);
  } else n.current = t;
  if (
    (kp && ((kp = !1), (la = n), (Pg = r)),
    (s = n.pendingLanes),
    s === 0 && (ma = null),
    AO(t.stateNode),
    Zi(n, On()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Ag) throw ((Ag = !1), (n = ox), (ox = null), n);
  return (
    Pg & 1 && n.tag !== 0 && cc(),
    (s = n.pendingLanes),
    s & 1 ? (n === ax ? Jd++ : ((Jd = 0), (ax = n))) : (Jd = 0),
    Pa(),
    null
  );
}
function cc() {
  if (la !== null) {
    var n = SA(Pg),
      e = Hr.transition,
      t = sn;
    try {
      if (((Hr.transition = null), (sn = 16 > n ? 16 : n), la === null))
        var i = !1;
      else {
        if (((n = la), (la = null), (Pg = 0), jt & 6)) throw Error(Ie(331));
        var r = jt;
        for (jt |= 4, it = n.current; it !== null; ) {
          var s = it,
            o = s.child;
          if (it.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var u = 0; u < a.length; u++) {
                var h = a[u];
                for (it = h; it !== null; ) {
                  var p = it;
                  switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qd(8, p, s);
                  }
                  var v = p.child;
                  if (v !== null) (v.return = p), (it = v);
                  else
                    for (; it !== null; ) {
                      p = it;
                      var y = p.sibling,
                        S = p.return;
                      if ((OP(p), p === h)) {
                        it = null;
                        break;
                      }
                      if (y !== null) {
                        (y.return = S), (it = y);
                        break;
                      }
                      it = S;
                    }
                }
              }
              var x = s.alternate;
              if (x !== null) {
                var _ = x.child;
                if (_ !== null) {
                  x.child = null;
                  do {
                    var f = _.sibling;
                    (_.sibling = null), (_ = f);
                  } while (_ !== null);
                }
              }
              it = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (it = o);
          else
            e: for (; it !== null; ) {
              if (((s = it), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qd(9, s, s.return);
                }
              var d = s.sibling;
              if (d !== null) {
                (d.return = s.return), (it = d);
                break e;
              }
              it = s.return;
            }
        }
        var m = n.current;
        for (it = m; it !== null; ) {
          o = it;
          var g = o.child;
          if (o.subtreeFlags & 2064 && g !== null) (g.return = o), (it = g);
          else
            e: for (o = m; it !== null; ) {
              if (((a = it), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      iv(9, a);
                  }
                } catch (T) {
                  bn(a, a.return, T);
                }
              if (a === o) {
                it = null;
                break e;
              }
              var w = a.sibling;
              if (w !== null) {
                (w.return = a.return), (it = w);
                break e;
              }
              it = a.return;
            }
        }
        if (
          ((jt = r), Pa(), Rs && typeof Rs.onPostCommitFiberRoot == "function")
        )
          try {
            Rs.onPostCommitFiberRoot(Yg, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (sn = t), (Hr.transition = e);
    }
  }
  return !1;
}
function eT(n, e, t) {
  (e = Nc(t, e)),
    (e = wP(n, e, 1)),
    (n = pa(n, e, 1)),
    (e = ki()),
    n !== null && (uf(n, 1, e), Zi(n, e));
}
function bn(n, e, t) {
  if (n.tag === 3) eT(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        eT(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (ma === null || !ma.has(i)))
        ) {
          (n = Nc(t, n)),
            (n = MP(e, n, 1)),
            (e = pa(e, n, 1)),
            (n = ki()),
            e !== null && (uf(e, 1, n), Zi(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function tD(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = ki()),
    (n.pingedLanes |= n.suspendedLanes & t),
    ti === n &&
      (ai & t) === t &&
      (jn === 4 || (jn === 3 && (ai & 130023424) === ai && 500 > On() - cw)
        ? bl(n, 0)
        : (uw |= t)),
    Zi(n, e);
}
function GP(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Cp), (Cp <<= 1), !(Cp & 130023424) && (Cp = 4194304))
      : (e = 1));
  var t = ki();
  (n = fo(n, e)), n !== null && (uf(n, e, t), Zi(n, t));
}
function nD(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), GP(n, t);
}
function iD(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(Ie(314));
  }
  i !== null && i.delete(e), GP(n, t);
}
var WP;
WP = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Ki.current) Yi = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (Yi = !1), WN(n, e, t);
      Yi = !!(n.flags & 131072);
    }
  else (Yi = !1), vn && e.flags & 1048576 && qA(e, xg, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      jm(n, e), (n = e.pendingProps);
      var r = Rc(e, Ti.current);
      uc(e, t), (r = iw(null, e, i, n, r, t));
      var s = rw();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Qi(i) ? ((s = !0), yg(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            ZS(e),
            (r.updater = tv),
            (e.stateNode = r),
            (r._reactInternals = e),
            Y_(e, i, n, t),
            (e = Z_(null, e, i, !0, s, t)))
          : ((e.tag = 0), vn && s && jS(e), Oi(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (jm(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = sD(i)),
          (n = Zr(i, n)),
          r)
        ) {
          case 0:
            e = Q_(null, e, i, n, t);
            break e;
          case 1:
            e = WE(null, e, i, n, t);
            break e;
          case 11:
            e = VE(null, e, i, n, t);
            break e;
          case 14:
            e = GE(null, e, i, Zr(i.type, n), t);
            break e;
        }
        throw Error(Ie(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Zr(i, r)),
        Q_(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Zr(i, r)),
        WE(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((bP(e), n === null)) throw Error(Ie(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          QA(n, e),
          Mg(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = Nc(Error(Ie(423)), e)), (e = jE(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = Nc(Error(Ie(424)), e)), (e = jE(n, e, i, t, r));
            break e;
          } else
            for (
              fr = fa(e.stateNode.containerInfo.firstChild),
                mr = e,
                vn = !0,
                ns = null,
                t = tP(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Lc(), i === r)) {
            e = po(n, e, t);
            break e;
          }
          Oi(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        nP(e),
        n === null && X_(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        H_(i, r) ? (o = null) : s !== null && H_(i, s) && (e.flags |= 32),
        CP(n, e),
        Oi(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && X_(e), null;
    case 13:
      return AP(n, e, t);
    case 4:
      return (
        JS(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = Ic(e, null, i, t)) : Oi(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Zr(i, r)),
        VE(n, e, i, r, t)
      );
    case 7:
      return Oi(n, e, e.pendingProps, t), e.child;
    case 8:
      return Oi(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return Oi(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          cn(Sg, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (os(s.value, o)) {
            if (s.children === r.children && !Ki.current) {
              e = po(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var u = a.firstContext; u !== null; ) {
                  if (u.context === i) {
                    if (s.tag === 1) {
                      (u = lo(-1, t & -t)), (u.tag = 2);
                      var h = s.updateQueue;
                      if (h !== null) {
                        h = h.shared;
                        var p = h.pending;
                        p === null
                          ? (u.next = u)
                          : ((u.next = p.next), (p.next = u)),
                          (h.pending = u);
                      }
                    }
                    (s.lanes |= t),
                      (u = s.alternate),
                      u !== null && (u.lanes |= t),
                      q_(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  u = u.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(Ie(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  q_(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        Oi(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        uc(e, t),
        (r = Vr(r)),
        (i = i(r)),
        (e.flags |= 1),
        Oi(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = Zr(i, e.pendingProps)),
        (r = Zr(i.type, r)),
        GE(n, e, i, r, t)
      );
    case 15:
      return EP(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Zr(i, r)),
        jm(n, e),
        (e.tag = 1),
        Qi(i) ? ((n = !0), yg(e)) : (n = !1),
        uc(e, t),
        JA(e, i, r),
        Y_(e, i, r, t),
        Z_(null, e, i, !0, n, t)
      );
    case 19:
      return PP(n, e, t);
    case 22:
      return TP(n, e, t);
  }
  throw Error(Ie(156, e.tag));
};
function jP(n, e) {
  return vA(n, e);
}
function rD(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function zr(n, e, t, i) {
  return new rD(n, e, t, i);
}
function pw(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function sD(n) {
  if (typeof n == "function") return pw(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === OS)) return 11;
    if (n === NS) return 14;
  }
  return 2;
}
function va(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = zr(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function $m(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) pw(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case Vu:
        return Al(t.children, r, s, e);
      case IS:
        (o = 8), (r |= 8);
        break;
      case __:
        return (
          (n = zr(12, t, e, r | 2)), (n.elementType = __), (n.lanes = s), n
        );
      case x_:
        return (n = zr(13, t, e, r)), (n.elementType = x_), (n.lanes = s), n;
      case S_:
        return (n = zr(19, t, e, r)), (n.elementType = S_), (n.lanes = s), n;
      case eA:
        return sv(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Zb:
              o = 10;
              break e;
            case Jb:
              o = 9;
              break e;
            case OS:
              o = 11;
              break e;
            case NS:
              o = 14;
              break e;
            case qo:
              (o = 16), (i = null);
              break e;
          }
        throw Error(Ie(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = zr(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function Al(n, e, t, i) {
  return (n = zr(7, n, i, e)), (n.lanes = t), n;
}
function sv(n, e, t, i) {
  return (
    (n = zr(22, n, i, e)),
    (n.elementType = eA),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function _0(n, e, t) {
  return (n = zr(6, n, null, e)), (n.lanes = t), n;
}
function x0(n, e, t) {
  return (
    (e = zr(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function oD(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = e0(0)),
    (this.expirationTimes = e0(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = e0(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function mw(n, e, t, i, r, s, o, a, u) {
  return (
    (n = new oD(n, e, t, a, u)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = zr(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    ZS(s),
    n
  );
}
function aD(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Hu,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function XP(n) {
  if (!n) return wa;
  n = n._reactInternals;
  e: {
    if (jl(n) !== n || n.tag !== 1) throw Error(Ie(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Qi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Ie(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Qi(t)) return jA(n, t, e);
  }
  return e;
}
function qP(n, e, t, i, r, s, o, a, u) {
  return (
    (n = mw(t, i, !0, n, r, s, o, a, u)),
    (n.context = XP(null)),
    (t = n.current),
    (i = ki()),
    (r = ga(t)),
    (s = lo(i, r)),
    (s.callback = e ?? null),
    pa(t, s, r),
    (n.current.lanes = r),
    uf(n, r, i),
    Zi(n, i),
    n
  );
}
function ov(n, e, t, i) {
  var r = e.current,
    s = ki(),
    o = ga(r);
  return (
    (t = XP(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = lo(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = pa(r, e, o)),
    n !== null && (ss(n, r, o, s), Vm(n, r, o)),
    o
  );
}
function Lg(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function tT(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function gw(n, e) {
  tT(n, e), (n = n.alternate) && tT(n, e);
}
function lD() {
  return null;
}
var $P =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function vw(n) {
  this._internalRoot = n;
}
av.prototype.render = vw.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(Ie(409));
  ov(n, e, null, null);
};
av.prototype.unmount = vw.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    zl(function () {
      ov(null, n, null, null);
    }),
      (e[ho] = null);
  }
};
function av(n) {
  this._internalRoot = n;
}
av.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = EA();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < Ko.length && e !== 0 && e < Ko[t].priority; t++);
    Ko.splice(t, 0, n), t === 0 && CA(n);
  }
};
function yw(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function lv(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function nT() {}
function uD(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var h = Lg(o);
        s.call(h);
      };
    }
    var o = qP(e, i, n, 0, null, !1, !1, "", nT);
    return (
      (n._reactRootContainer = o),
      (n[ho] = o.current),
      mh(n.nodeType === 8 ? n.parentNode : n),
      zl(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var h = Lg(u);
      a.call(h);
    };
  }
  var u = mw(n, 0, !1, null, null, !1, !1, "", nT);
  return (
    (n._reactRootContainer = u),
    (n[ho] = u.current),
    mh(n.nodeType === 8 ? n.parentNode : n),
    zl(function () {
      ov(e, u, t, i);
    }),
    u
  );
}
function uv(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var u = Lg(o);
        a.call(u);
      };
    }
    ov(e, o, n, r);
  } else o = uD(t, e, n, r, i);
  return Lg(o);
}
wA = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Bd(e.pendingLanes);
        t !== 0 &&
          (US(e, t | 1), Zi(e, On()), !(jt & 6) && ((Dc = On() + 500), Pa()));
      }
      break;
    case 13:
      zl(function () {
        var i = fo(n, 1);
        if (i !== null) {
          var r = ki();
          ss(i, n, 1, r);
        }
      }),
        gw(n, 1);
  }
};
FS = function (n) {
  if (n.tag === 13) {
    var e = fo(n, 134217728);
    if (e !== null) {
      var t = ki();
      ss(e, n, 134217728, t);
    }
    gw(n, 134217728);
  }
};
MA = function (n) {
  if (n.tag === 13) {
    var e = ga(n),
      t = fo(n, e);
    if (t !== null) {
      var i = ki();
      ss(t, n, e, i);
    }
    gw(n, e);
  }
};
EA = function () {
  return sn;
};
TA = function (n, e) {
  var t = sn;
  try {
    return (sn = n), e();
  } finally {
    sn = t;
  }
};
L_ = function (n, e, t) {
  switch (e) {
    case "input":
      if ((E_(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]',
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = Jg(i);
            if (!r) throw Error(Ie(90));
            nA(i), E_(i, r);
          }
        }
      }
      break;
    case "textarea":
      rA(n, t);
      break;
    case "select":
      (e = t.value), e != null && sc(n, !!t.multiple, e, !1);
  }
};
dA = dw;
hA = zl;
var cD = { usingClientEntryPoint: !1, Events: [df, Xu, Jg, uA, cA, dw] },
  wd = {
    findFiberByHostInstance: dl,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  dD = {
    bundleType: wd.bundleType,
    version: wd.version,
    rendererPackageName: wd.rendererPackageName,
    rendererConfig: wd.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: _o.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = mA(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: wd.findFiberByHostInstance || lD,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Up = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Up.isDisabled && Up.supportsFiber)
    try {
      (Yg = Up.inject(dD)), (Rs = Up);
    } catch {}
}
_r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cD;
_r.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!yw(e)) throw Error(Ie(200));
  return aD(n, e, null, t);
};
_r.createRoot = function (n, e) {
  if (!yw(n)) throw Error(Ie(299));
  var t = !1,
    i = "",
    r = $P;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = mw(n, 1, !1, null, null, t, !1, i, r)),
    (n[ho] = e.current),
    mh(n.nodeType === 8 ? n.parentNode : n),
    new vw(e)
  );
};
_r.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(Ie(188))
      : ((n = Object.keys(n).join(",")), Error(Ie(268, n)));
  return (n = mA(e)), (n = n === null ? null : n.stateNode), n;
};
_r.flushSync = function (n) {
  return zl(n);
};
_r.hydrate = function (n, e, t) {
  if (!lv(e)) throw Error(Ie(200));
  return uv(null, n, e, !0, t);
};
_r.hydrateRoot = function (n, e, t) {
  if (!yw(n)) throw Error(Ie(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = $P;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = qP(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[ho] = e.current),
    mh(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new av(e);
};
_r.render = function (n, e, t) {
  if (!lv(e)) throw Error(Ie(200));
  return uv(null, n, e, !1, t);
};
_r.unmountComponentAtNode = function (n) {
  if (!lv(n)) throw Error(Ie(40));
  return n._reactRootContainer
    ? (zl(function () {
        uv(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[ho] = null);
        });
      }),
      !0)
    : !1;
};
_r.unstable_batchedUpdates = dw;
_r.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!lv(t)) throw Error(Ie(200));
  if (n == null || n._reactInternals === void 0) throw Error(Ie(38));
  return uv(n, e, t, !1, i);
};
_r.version = "18.2.0-next-9e3b772b8-20220608";
function YP() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(YP);
    } catch (n) {
      console.error(n);
    }
}
YP(), (qb.exports = _r);
var hD = qb.exports,
  iT = hD;
(v_.createRoot = iT.createRoot), (v_.hydrateRoot = iT.hydrateRoot);
var ff = class {
    constructor() {
      (this.listeners = new Set()),
        (this.subscribe = this.subscribe.bind(this));
    }
    subscribe(n) {
      return (
        this.listeners.add(n),
        this.onSubscribe(),
        () => {
          this.listeners.delete(n), this.onUnsubscribe();
        }
      );
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  kc = typeof window > "u" || "Deno" in window;
function Dr() {}
function fD(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function cx(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
function KP(n, e) {
  return Math.max(n + (e || 0) - Date.now(), 0);
}
function rT(n, e) {
  const {
    type: t = "all",
    exact: i,
    fetchStatus: r,
    predicate: s,
    queryKey: o,
    stale: a,
  } = n;
  if (o) {
    if (i) {
      if (e.queryHash !== _w(o, e.options)) return !1;
    } else if (!Th(e.queryKey, o)) return !1;
  }
  if (t !== "all") {
    const u = e.isActive();
    if ((t === "active" && !u) || (t === "inactive" && u)) return !1;
  }
  return !(
    (typeof a == "boolean" && e.isStale() !== a) ||
    (typeof r < "u" && r !== e.state.fetchStatus) ||
    (s && !s(e))
  );
}
function sT(n, e) {
  const { exact: t, status: i, predicate: r, mutationKey: s } = n;
  if (s) {
    if (!e.options.mutationKey) return !1;
    if (t) {
      if (Eh(e.options.mutationKey) !== Eh(s)) return !1;
    } else if (!Th(e.options.mutationKey, s)) return !1;
  }
  return !((i && e.state.status !== i) || (r && !r(e)));
}
function _w(n, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Eh)(n);
}
function Eh(n) {
  return JSON.stringify(n, (e, t) =>
    hx(t)
      ? Object.keys(t)
          .sort()
          .reduce((i, r) => ((i[r] = t[r]), i), {})
      : t,
  );
}
function Th(n, e) {
  return n === e
    ? !0
    : typeof n != typeof e
      ? !1
      : n && e && typeof n == "object" && typeof e == "object"
        ? !Object.keys(e).some((t) => !Th(n[t], e[t]))
        : !1;
}
function QP(n, e) {
  if (n === e) return n;
  const t = oT(n) && oT(e);
  if (t || (hx(n) && hx(e))) {
    const i = t ? n : Object.keys(n),
      r = i.length,
      s = t ? e : Object.keys(e),
      o = s.length,
      a = t ? [] : {};
    let u = 0;
    for (let h = 0; h < o; h++) {
      const p = t ? h : s[h];
      !t && n[p] === void 0 && e[p] === void 0 && i.includes(p)
        ? ((a[p] = void 0), u++)
        : ((a[p] = QP(n[p], e[p])), a[p] === n[p] && n[p] !== void 0 && u++);
    }
    return r === o && u === r ? n : a;
  }
  return e;
}
function dx(n, e) {
  if ((n && !e) || (e && !n)) return !1;
  for (const t in n) if (n[t] !== e[t]) return !1;
  return !0;
}
function oT(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function hx(n) {
  if (!aT(n)) return !1;
  const e = n.constructor;
  if (typeof e > "u") return !0;
  const t = e.prototype;
  return !(!aT(t) || !t.hasOwnProperty("isPrototypeOf"));
}
function aT(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function pD(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function fx(n, e, t) {
  return typeof t.structuralSharing == "function"
    ? t.structuralSharing(n, e)
    : t.structuralSharing !== !1
      ? QP(n, e)
      : e;
}
function mD(n, e, t = 0) {
  const i = [...n, e];
  return t && i.length > t ? i.slice(1) : i;
}
function gD(n, e, t = 0) {
  const i = [e, ...n];
  return t && i.length > t ? i.slice(0, -1) : i;
}
var _l,
  ea,
  hc,
  pb,
  vD =
    ((pb = class extends ff {
      constructor() {
        super();
        ct(this, _l, void 0);
        ct(this, ea, void 0);
        ct(this, hc, void 0);
        Je(this, hc, (e) => {
          if (!kc && window.addEventListener) {
            const t = () => e();
            return (
              window.addEventListener("visibilitychange", t, !1),
              () => {
                window.removeEventListener("visibilitychange", t);
              }
            );
          }
        });
      }
      onSubscribe() {
        re(this, ea) || this.setEventListener(re(this, hc));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = re(this, ea)) == null || e.call(this), Je(this, ea, void 0));
      }
      setEventListener(e) {
        var t;
        Je(this, hc, e),
          (t = re(this, ea)) == null || t.call(this),
          Je(
            this,
            ea,
            e((i) => {
              typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
            }),
          );
      }
      setFocused(e) {
        re(this, _l) !== e && (Je(this, _l, e), this.onFocus());
      }
      onFocus() {
        this.listeners.forEach((e) => {
          e();
        });
      }
      isFocused() {
        var e;
        return typeof re(this, _l) == "boolean"
          ? re(this, _l)
          : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !==
              "hidden";
      }
    }),
    (_l = new WeakMap()),
    (ea = new WeakMap()),
    (hc = new WeakMap()),
    pb),
  Ig = new vD(),
  fc,
  ta,
  pc,
  mb,
  yD =
    ((mb = class extends ff {
      constructor() {
        super();
        ct(this, fc, !0);
        ct(this, ta, void 0);
        ct(this, pc, void 0);
        Je(this, pc, (e) => {
          if (!kc && window.addEventListener) {
            const t = () => e(!0),
              i = () => e(!1);
            return (
              window.addEventListener("online", t, !1),
              window.addEventListener("offline", i, !1),
              () => {
                window.removeEventListener("online", t),
                  window.removeEventListener("offline", i);
              }
            );
          }
        });
      }
      onSubscribe() {
        re(this, ta) || this.setEventListener(re(this, pc));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = re(this, ta)) == null || e.call(this), Je(this, ta, void 0));
      }
      setEventListener(e) {
        var t;
        Je(this, pc, e),
          (t = re(this, ta)) == null || t.call(this),
          Je(this, ta, e(this.setOnline.bind(this)));
      }
      setOnline(e) {
        re(this, fc) !== e &&
          (Je(this, fc, e),
          this.listeners.forEach((i) => {
            i(e);
          }));
      }
      isOnline() {
        return re(this, fc);
      }
    }),
    (fc = new WeakMap()),
    (ta = new WeakMap()),
    (pc = new WeakMap()),
    mb),
  Og = new yD();
function _D(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
function cv(n) {
  return (n ?? "online") === "online" ? Og.isOnline() : !0;
}
var ZP = class {
  constructor(n) {
    (this.revert = n == null ? void 0 : n.revert),
      (this.silent = n == null ? void 0 : n.silent);
  }
};
function S0(n) {
  return n instanceof ZP;
}
function JP(n) {
  let e = !1,
    t = 0,
    i = !1,
    r,
    s,
    o;
  const a = new Promise((f, d) => {
      (s = f), (o = d);
    }),
    u = (f) => {
      var d;
      i || (S(new ZP(f)), (d = n.abort) == null || d.call(n));
    },
    h = () => {
      e = !0;
    },
    p = () => {
      e = !1;
    },
    v = () => !Ig.isFocused() || (n.networkMode !== "always" && !Og.isOnline()),
    y = (f) => {
      var d;
      i ||
        ((i = !0),
        (d = n.onSuccess) == null || d.call(n, f),
        r == null || r(),
        s(f));
    },
    S = (f) => {
      var d;
      i ||
        ((i = !0),
        (d = n.onError) == null || d.call(n, f),
        r == null || r(),
        o(f));
    },
    x = () =>
      new Promise((f) => {
        var d;
        (r = (m) => {
          const g = i || !v();
          return g && f(m), g;
        }),
          (d = n.onPause) == null || d.call(n);
      }).then(() => {
        var f;
        (r = void 0), i || (f = n.onContinue) == null || f.call(n);
      }),
    _ = () => {
      if (i) return;
      let f;
      try {
        f = n.fn();
      } catch (d) {
        f = Promise.reject(d);
      }
      Promise.resolve(f)
        .then(y)
        .catch((d) => {
          var C;
          if (i) return;
          const m = n.retry ?? (kc ? 0 : 3),
            g = n.retryDelay ?? _D,
            w = typeof g == "function" ? g(t, d) : g,
            T =
              m === !0 ||
              (typeof m == "number" && t < m) ||
              (typeof m == "function" && m(t, d));
          if (e || !T) {
            S(d);
            return;
          }
          t++,
            (C = n.onFail) == null || C.call(n, t, d),
            pD(w)
              .then(() => {
                if (v()) return x();
              })
              .then(() => {
                e ? S(d) : _();
              });
        });
    };
  return (
    cv(n.networkMode) ? _() : x().then(_),
    {
      promise: a,
      cancel: u,
      continue: () => ((r == null ? void 0 : r()) ? a : Promise.resolve()),
      cancelRetry: h,
      continueRetry: p,
    }
  );
}
function xD() {
  let n = [],
    e = 0,
    t = (y) => {
      y();
    },
    i = (y) => {
      y();
    },
    r = (y) => setTimeout(y, 0);
  const s = (y) => {
      r = y;
    },
    o = (y) => {
      let S;
      e++;
      try {
        S = y();
      } finally {
        e--, e || h();
      }
      return S;
    },
    a = (y) => {
      e
        ? n.push(y)
        : r(() => {
            t(y);
          });
    },
    u =
      (y) =>
      (...S) => {
        a(() => {
          y(...S);
        });
      },
    h = () => {
      const y = n;
      (n = []),
        y.length &&
          r(() => {
            i(() => {
              y.forEach((S) => {
                t(S);
              });
            });
          });
    };
  return {
    batch: o,
    batchCalls: u,
    schedule: a,
    setNotifyFunction: (y) => {
      t = y;
    },
    setBatchNotifyFunction: (y) => {
      i = y;
    },
    setScheduler: s,
  };
}
var oi = xD(),
  xl,
  gb,
  e2 =
    ((gb = class {
      constructor() {
        ct(this, xl, void 0);
      }
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout(),
          cx(this.gcTime) &&
            Je(
              this,
              xl,
              setTimeout(() => {
                this.optionalRemove();
              }, this.gcTime),
            );
      }
      updateGcTime(n) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          n ?? (kc ? 1 / 0 : 5 * 60 * 1e3),
        );
      }
      clearGcTimeout() {
        re(this, xl) && (clearTimeout(re(this, xl)), Je(this, xl, void 0));
      }
    }),
    (xl = new WeakMap()),
    gb),
  mc,
  gc,
  Ir,
  na,
  Or,
  Zn,
  Yh,
  Sl,
  vc,
  Ym,
  es,
  Js,
  vb,
  SD =
    ((vb = class extends e2 {
      constructor(e) {
        super();
        ct(this, vc);
        ct(this, es);
        ct(this, mc, void 0);
        ct(this, gc, void 0);
        ct(this, Ir, void 0);
        ct(this, na, void 0);
        ct(this, Or, void 0);
        ct(this, Zn, void 0);
        ct(this, Yh, void 0);
        ct(this, Sl, void 0);
        Je(this, Sl, !1),
          Je(this, Yh, e.defaultOptions),
          Ft(this, vc, Ym).call(this, e.options),
          Je(this, Zn, []),
          Je(this, Ir, e.cache),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          Je(this, mc, e.state || wD(this.options)),
          (this.state = re(this, mc)),
          this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      optionalRemove() {
        !re(this, Zn).length &&
          this.state.fetchStatus === "idle" &&
          re(this, Ir).remove(this);
      }
      setData(e, t) {
        const i = fx(this.state.data, e, this.options);
        return (
          Ft(this, es, Js).call(this, {
            data: i,
            type: "success",
            dataUpdatedAt: t == null ? void 0 : t.updatedAt,
            manual: t == null ? void 0 : t.manual,
          }),
          i
        );
      }
      setState(e, t) {
        Ft(this, es, Js).call(this, {
          type: "setState",
          state: e,
          setStateOptions: t,
        });
      }
      cancel(e) {
        var i;
        const t = re(this, na);
        return (
          (i = re(this, Or)) == null || i.cancel(e),
          t ? t.then(Dr).catch(Dr) : Promise.resolve()
        );
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 });
      }
      reset() {
        this.destroy(), this.setState(re(this, mc));
      }
      isActive() {
        return re(this, Zn).some((e) => e.options.enabled !== !1);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return (
          this.state.isInvalidated ||
          !this.state.dataUpdatedAt ||
          re(this, Zn).some((e) => e.getCurrentResult().isStale)
        );
      }
      isStaleByTime(e = 0) {
        return (
          this.state.isInvalidated ||
          !this.state.dataUpdatedAt ||
          !KP(this.state.dataUpdatedAt, e)
        );
      }
      onFocus() {
        var t;
        const e = re(this, Zn).find((i) => i.shouldFetchOnWindowFocus());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (t = re(this, Or)) == null || t.continue();
      }
      onOnline() {
        var t;
        const e = re(this, Zn).find((i) => i.shouldFetchOnReconnect());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (t = re(this, Or)) == null || t.continue();
      }
      addObserver(e) {
        re(this, Zn).includes(e) ||
          (re(this, Zn).push(e),
          this.clearGcTimeout(),
          re(this, Ir).notify({
            type: "observerAdded",
            query: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        re(this, Zn).includes(e) &&
          (Je(
            this,
            Zn,
            re(this, Zn).filter((t) => t !== e),
          ),
          re(this, Zn).length ||
            (re(this, Or) &&
              (re(this, Sl)
                ? re(this, Or).cancel({ revert: !0 })
                : re(this, Or).cancelRetry()),
            this.scheduleGc()),
          re(this, Ir).notify({
            type: "observerRemoved",
            query: this,
            observer: e,
          }));
      }
      getObserversCount() {
        return re(this, Zn).length;
      }
      invalidate() {
        this.state.isInvalidated ||
          Ft(this, es, Js).call(this, { type: "invalidate" });
      }
      fetch(e, t) {
        var h, p, v, y;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && t != null && t.cancelRefetch)
            this.cancel({ silent: !0 });
          else if (re(this, na))
            return (
              (h = re(this, Or)) == null || h.continueRetry(), re(this, na)
            );
        }
        if ((e && Ft(this, vc, Ym).call(this, e), !this.options.queryFn)) {
          const S = re(this, Zn).find((x) => x.options.queryFn);
          S && Ft(this, vc, Ym).call(this, S.options);
        }
        const i = new AbortController(),
          r = { queryKey: this.queryKey, meta: this.meta },
          s = (S) => {
            Object.defineProperty(S, "signal", {
              enumerable: !0,
              get: () => (Je(this, Sl, !0), i.signal),
            });
          };
        s(r);
        const o = () =>
            this.options.queryFn
              ? (Je(this, Sl, !1),
                this.options.persister
                  ? this.options.persister(this.options.queryFn, r, this)
                  : this.options.queryFn(r))
              : Promise.reject(
                  new Error(`Missing queryFn: '${this.options.queryHash}'`),
                ),
          a = {
            fetchOptions: t,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: o,
          };
        s(a),
          (p = this.options.behavior) == null || p.onFetch(a, this),
          Je(this, gc, this.state),
          (this.state.fetchStatus === "idle" ||
            this.state.fetchMeta !==
              ((v = a.fetchOptions) == null ? void 0 : v.meta)) &&
            Ft(this, es, Js).call(this, {
              type: "fetch",
              meta: (y = a.fetchOptions) == null ? void 0 : y.meta,
            });
        const u = (S) => {
          var x, _, f, d;
          (S0(S) && S.silent) ||
            Ft(this, es, Js).call(this, { type: "error", error: S }),
            S0(S) ||
              ((_ = (x = re(this, Ir).config).onError) == null ||
                _.call(x, S, this),
              (d = (f = re(this, Ir).config).onSettled) == null ||
                d.call(f, this.state.data, S, this)),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1);
        };
        return (
          Je(
            this,
            Or,
            JP({
              fn: a.fetchFn,
              abort: i.abort.bind(i),
              onSuccess: (S) => {
                var x, _, f, d;
                if (typeof S > "u") {
                  u(new Error(`${this.queryHash} data is undefined`));
                  return;
                }
                this.setData(S),
                  (_ = (x = re(this, Ir).config).onSuccess) == null ||
                    _.call(x, S, this),
                  (d = (f = re(this, Ir).config).onSettled) == null ||
                    d.call(f, S, this.state.error, this),
                  this.isFetchingOptimistic || this.scheduleGc(),
                  (this.isFetchingOptimistic = !1);
              },
              onError: u,
              onFail: (S, x) => {
                Ft(this, es, Js).call(this, {
                  type: "failed",
                  failureCount: S,
                  error: x,
                });
              },
              onPause: () => {
                Ft(this, es, Js).call(this, { type: "pause" });
              },
              onContinue: () => {
                Ft(this, es, Js).call(this, { type: "continue" });
              },
              retry: a.options.retry,
              retryDelay: a.options.retryDelay,
              networkMode: a.options.networkMode,
            }),
          ),
          Je(this, na, re(this, Or).promise),
          re(this, na)
        );
      }
    }),
    (mc = new WeakMap()),
    (gc = new WeakMap()),
    (Ir = new WeakMap()),
    (na = new WeakMap()),
    (Or = new WeakMap()),
    (Zn = new WeakMap()),
    (Yh = new WeakMap()),
    (Sl = new WeakMap()),
    (vc = new WeakSet()),
    (Ym = function (e) {
      (this.options = { ...re(this, Yh), ...e }),
        this.updateGcTime(this.options.gcTime);
    }),
    (es = new WeakSet()),
    (Js = function (e) {
      const t = (i) => {
        switch (e.type) {
          case "failed":
            return {
              ...i,
              fetchFailureCount: e.failureCount,
              fetchFailureReason: e.error,
            };
          case "pause":
            return { ...i, fetchStatus: "paused" };
          case "continue":
            return { ...i, fetchStatus: "fetching" };
          case "fetch":
            return {
              ...i,
              fetchFailureCount: 0,
              fetchFailureReason: null,
              fetchMeta: e.meta ?? null,
              fetchStatus: cv(this.options.networkMode) ? "fetching" : "paused",
              ...(!i.dataUpdatedAt && { error: null, status: "pending" }),
            };
          case "success":
            return {
              ...i,
              data: e.data,
              dataUpdateCount: i.dataUpdateCount + 1,
              dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: "success",
              ...(!e.manual && {
                fetchStatus: "idle",
                fetchFailureCount: 0,
                fetchFailureReason: null,
              }),
            };
          case "error":
            const r = e.error;
            return S0(r) && r.revert && re(this, gc)
              ? { ...re(this, gc), fetchStatus: "idle" }
              : {
                  ...i,
                  error: r,
                  errorUpdateCount: i.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: i.fetchFailureCount + 1,
                  fetchFailureReason: r,
                  fetchStatus: "idle",
                  status: "error",
                };
          case "invalidate":
            return { ...i, isInvalidated: !0 };
          case "setState":
            return { ...i, ...e.state };
        }
      };
      (this.state = t(this.state)),
        oi.batch(() => {
          re(this, Zn).forEach((i) => {
            i.onQueryUpdate();
          }),
            re(this, Ir).notify({ query: this, type: "updated", action: e });
        });
    }),
    vb);
function wD(n) {
  const e =
      typeof n.initialData == "function" ? n.initialData() : n.initialData,
    t = typeof e < "u",
    i = t
      ? typeof n.initialDataUpdatedAt == "function"
        ? n.initialDataUpdatedAt()
        : n.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? "success" : "pending",
    fetchStatus: "idle",
  };
}
var ws,
  yb,
  MD =
    ((yb = class extends ff {
      constructor(e = {}) {
        super();
        ct(this, ws, void 0);
        (this.config = e), Je(this, ws, new Map());
      }
      build(e, t, i) {
        const r = t.queryKey,
          s = t.queryHash ?? _w(r, t);
        let o = this.get(s);
        return (
          o ||
            ((o = new SD({
              cache: this,
              queryKey: r,
              queryHash: s,
              options: e.defaultQueryOptions(t),
              state: i,
              defaultOptions: e.getQueryDefaults(r),
            })),
            this.add(o)),
          o
        );
      }
      add(e) {
        re(this, ws).has(e.queryHash) ||
          (re(this, ws).set(e.queryHash, e),
          this.notify({ type: "added", query: e }));
      }
      remove(e) {
        const t = re(this, ws).get(e.queryHash);
        t &&
          (e.destroy(),
          t === e && re(this, ws).delete(e.queryHash),
          this.notify({ type: "removed", query: e }));
      }
      clear() {
        oi.batch(() => {
          this.getAll().forEach((e) => {
            this.remove(e);
          });
        });
      }
      get(e) {
        return re(this, ws).get(e);
      }
      getAll() {
        return [...re(this, ws).values()];
      }
      find(e) {
        const t = { exact: !0, ...e };
        return this.getAll().find((i) => rT(t, i));
      }
      findAll(e = {}) {
        const t = this.getAll();
        return Object.keys(e).length > 0 ? t.filter((i) => rT(e, i)) : t;
      }
      notify(e) {
        oi.batch(() => {
          this.listeners.forEach((t) => {
            t(e);
          });
        });
      }
      onFocus() {
        oi.batch(() => {
          this.getAll().forEach((e) => {
            e.onFocus();
          });
        });
      }
      onOnline() {
        oi.batch(() => {
          this.getAll().forEach((e) => {
            e.onOnline();
          });
        });
      }
    }),
    (ws = new WeakMap()),
    yb),
  Ms,
  Kh,
  lr,
  yc,
  Es,
  Xo,
  _b,
  ED =
    ((_b = class extends e2 {
      constructor(e) {
        super();
        ct(this, Es);
        ct(this, Ms, void 0);
        ct(this, Kh, void 0);
        ct(this, lr, void 0);
        ct(this, yc, void 0);
        (this.mutationId = e.mutationId),
          Je(this, Kh, e.defaultOptions),
          Je(this, lr, e.mutationCache),
          Je(this, Ms, []),
          (this.state = e.state || TD()),
          this.setOptions(e.options),
          this.scheduleGc();
      }
      setOptions(e) {
        (this.options = { ...re(this, Kh), ...e }),
          this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(e) {
        re(this, Ms).includes(e) ||
          (re(this, Ms).push(e),
          this.clearGcTimeout(),
          re(this, lr).notify({
            type: "observerAdded",
            mutation: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        Je(
          this,
          Ms,
          re(this, Ms).filter((t) => t !== e),
        ),
          this.scheduleGc(),
          re(this, lr).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e,
          });
      }
      optionalRemove() {
        re(this, Ms).length ||
          (this.state.status === "pending"
            ? this.scheduleGc()
            : re(this, lr).remove(this));
      }
      continue() {
        var e;
        return (
          ((e = re(this, yc)) == null ? void 0 : e.continue()) ??
          this.execute(this.state.variables)
        );
      }
      async execute(e) {
        var r, s, o, a, u, h, p, v, y, S, x, _, f, d, m, g, w, T, C, A;
        const t = () => (
            Je(
              this,
              yc,
              JP({
                fn: () =>
                  this.options.mutationFn
                    ? this.options.mutationFn(e)
                    : Promise.reject(new Error("No mutationFn found")),
                onFail: (L, N) => {
                  Ft(this, Es, Xo).call(this, {
                    type: "failed",
                    failureCount: L,
                    error: N,
                  });
                },
                onPause: () => {
                  Ft(this, Es, Xo).call(this, { type: "pause" });
                },
                onContinue: () => {
                  Ft(this, Es, Xo).call(this, { type: "continue" });
                },
                retry: this.options.retry ?? 0,
                retryDelay: this.options.retryDelay,
                networkMode: this.options.networkMode,
              }),
            ),
            re(this, yc).promise
          ),
          i = this.state.status === "pending";
        try {
          if (!i) {
            Ft(this, Es, Xo).call(this, { type: "pending", variables: e }),
              await ((s = (r = re(this, lr).config).onMutate) == null
                ? void 0
                : s.call(r, e, this));
            const N = await ((a = (o = this.options).onMutate) == null
              ? void 0
              : a.call(o, e));
            N !== this.state.context &&
              Ft(this, Es, Xo).call(this, {
                type: "pending",
                context: N,
                variables: e,
              });
          }
          const L = await t();
          return (
            await ((h = (u = re(this, lr).config).onSuccess) == null
              ? void 0
              : h.call(u, L, e, this.state.context, this)),
            await ((v = (p = this.options).onSuccess) == null
              ? void 0
              : v.call(p, L, e, this.state.context)),
            await ((S = (y = re(this, lr).config).onSettled) == null
              ? void 0
              : S.call(
                  y,
                  L,
                  null,
                  this.state.variables,
                  this.state.context,
                  this,
                )),
            await ((_ = (x = this.options).onSettled) == null
              ? void 0
              : _.call(x, L, null, e, this.state.context)),
            Ft(this, Es, Xo).call(this, { type: "success", data: L }),
            L
          );
        } catch (L) {
          try {
            throw (
              (await ((d = (f = re(this, lr).config).onError) == null
                ? void 0
                : d.call(f, L, e, this.state.context, this)),
              await ((g = (m = this.options).onError) == null
                ? void 0
                : g.call(m, L, e, this.state.context)),
              await ((T = (w = re(this, lr).config).onSettled) == null
                ? void 0
                : T.call(
                    w,
                    void 0,
                    L,
                    this.state.variables,
                    this.state.context,
                    this,
                  )),
              await ((A = (C = this.options).onSettled) == null
                ? void 0
                : A.call(C, void 0, L, e, this.state.context)),
              L)
            );
          } finally {
            Ft(this, Es, Xo).call(this, { type: "error", error: L });
          }
        }
      }
    }),
    (Ms = new WeakMap()),
    (Kh = new WeakMap()),
    (lr = new WeakMap()),
    (yc = new WeakMap()),
    (Es = new WeakSet()),
    (Xo = function (e) {
      const t = (i) => {
        switch (e.type) {
          case "failed":
            return {
              ...i,
              failureCount: e.failureCount,
              failureReason: e.error,
            };
          case "pause":
            return { ...i, isPaused: !0 };
          case "continue":
            return { ...i, isPaused: !1 };
          case "pending":
            return {
              ...i,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: !cv(this.options.networkMode),
              status: "pending",
              variables: e.variables,
              submittedAt: Date.now(),
            };
          case "success":
            return {
              ...i,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: !1,
            };
          case "error":
            return {
              ...i,
              data: void 0,
              error: e.error,
              failureCount: i.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: "error",
            };
        }
      };
      (this.state = t(this.state)),
        oi.batch(() => {
          re(this, Ms).forEach((i) => {
            i.onMutationUpdate(e);
          }),
            re(this, lr).notify({ mutation: this, type: "updated", action: e });
        });
    }),
    _b);
function TD() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0,
  };
}
var Nr,
  Qh,
  wl,
  xb,
  CD =
    ((xb = class extends ff {
      constructor(e = {}) {
        super();
        ct(this, Nr, void 0);
        ct(this, Qh, void 0);
        ct(this, wl, void 0);
        (this.config = e), Je(this, Nr, []), Je(this, Qh, 0);
      }
      build(e, t, i) {
        const r = new ED({
          mutationCache: this,
          mutationId: ++xp(this, Qh)._,
          options: e.defaultMutationOptions(t),
          state: i,
        });
        return this.add(r), r;
      }
      add(e) {
        re(this, Nr).push(e), this.notify({ type: "added", mutation: e });
      }
      remove(e) {
        Je(
          this,
          Nr,
          re(this, Nr).filter((t) => t !== e),
        ),
          this.notify({ type: "removed", mutation: e });
      }
      clear() {
        oi.batch(() => {
          re(this, Nr).forEach((e) => {
            this.remove(e);
          });
        });
      }
      getAll() {
        return re(this, Nr);
      }
      find(e) {
        const t = { exact: !0, ...e };
        return re(this, Nr).find((i) => sT(t, i));
      }
      findAll(e = {}) {
        return re(this, Nr).filter((t) => sT(e, t));
      }
      notify(e) {
        oi.batch(() => {
          this.listeners.forEach((t) => {
            t(e);
          });
        });
      }
      resumePausedMutations() {
        return (
          Je(
            this,
            wl,
            (re(this, wl) ?? Promise.resolve())
              .then(() => {
                const e = re(this, Nr).filter((t) => t.state.isPaused);
                return oi.batch(() =>
                  e.reduce(
                    (t, i) => t.then(() => i.continue().catch(Dr)),
                    Promise.resolve(),
                  ),
                );
              })
              .then(() => {
                Je(this, wl, void 0);
              }),
          ),
          re(this, wl)
        );
      }
    }),
    (Nr = new WeakMap()),
    (Qh = new WeakMap()),
    (wl = new WeakMap()),
    xb);
function bD(n) {
  return {
    onFetch: (e, t) => {
      const i = async () => {
        var x, _, f, d, m;
        const r = e.options,
          s =
            (f =
              (_ = (x = e.fetchOptions) == null ? void 0 : x.meta) == null
                ? void 0
                : _.fetchMore) == null
              ? void 0
              : f.direction,
          o = ((d = e.state.data) == null ? void 0 : d.pages) || [],
          a = ((m = e.state.data) == null ? void 0 : m.pageParams) || [],
          u = { pages: [], pageParams: [] };
        let h = !1;
        const p = (g) => {
            Object.defineProperty(g, "signal", {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (h = !0)
                  : e.signal.addEventListener("abort", () => {
                      h = !0;
                    }),
                e.signal
              ),
            });
          },
          v =
            e.options.queryFn ||
            (() =>
              Promise.reject(
                new Error(`Missing queryFn: '${e.options.queryHash}'`),
              )),
          y = async (g, w, T) => {
            if (h) return Promise.reject();
            if (w == null && g.pages.length) return Promise.resolve(g);
            const C = {
              queryKey: e.queryKey,
              pageParam: w,
              direction: T ? "backward" : "forward",
              meta: e.options.meta,
            };
            p(C);
            const A = await v(C),
              { maxPages: L } = e.options,
              N = T ? gD : mD;
            return {
              pages: N(g.pages, A, L),
              pageParams: N(g.pageParams, w, L),
            };
          };
        let S;
        if (s && o.length) {
          const g = s === "backward",
            w = g ? AD : lT,
            T = { pages: o, pageParams: a },
            C = w(r, T);
          S = await y(T, C, g);
        } else {
          S = await y(u, a[0] ?? r.initialPageParam);
          const g = n ?? o.length;
          for (let w = 1; w < g; w++) {
            const T = lT(r, S);
            S = await y(S, T);
          }
        }
        return S;
      };
      e.options.persister
        ? (e.fetchFn = () => {
            var r, s;
            return (s = (r = e.options).persister) == null
              ? void 0
              : s.call(
                  r,
                  i,
                  {
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal,
                  },
                  t,
                );
          })
        : (e.fetchFn = i);
    },
  };
}
function lT(n, { pages: e, pageParams: t }) {
  const i = e.length - 1;
  return n.getNextPageParam(e[i], e, t[i], t);
}
function AD(n, { pages: e, pageParams: t }) {
  var i;
  return (i = n.getPreviousPageParam) == null
    ? void 0
    : i.call(n, e[0], e, t[0], t);
}
var Vn,
  ia,
  ra,
  _c,
  xc,
  sa,
  Sc,
  wc,
  Sb,
  PD =
    ((Sb = class {
      constructor(n = {}) {
        ct(this, Vn, void 0);
        ct(this, ia, void 0);
        ct(this, ra, void 0);
        ct(this, _c, void 0);
        ct(this, xc, void 0);
        ct(this, sa, void 0);
        ct(this, Sc, void 0);
        ct(this, wc, void 0);
        Je(this, Vn, n.queryCache || new MD()),
          Je(this, ia, n.mutationCache || new CD()),
          Je(this, ra, n.defaultOptions || {}),
          Je(this, _c, new Map()),
          Je(this, xc, new Map()),
          Je(this, sa, 0);
      }
      mount() {
        xp(this, sa)._++,
          re(this, sa) === 1 &&
            (Je(
              this,
              Sc,
              Ig.subscribe(() => {
                Ig.isFocused() &&
                  (this.resumePausedMutations(), re(this, Vn).onFocus());
              }),
            ),
            Je(
              this,
              wc,
              Og.subscribe(() => {
                Og.isOnline() &&
                  (this.resumePausedMutations(), re(this, Vn).onOnline());
              }),
            ));
      }
      unmount() {
        var n, e;
        xp(this, sa)._--,
          re(this, sa) === 0 &&
            ((n = re(this, Sc)) == null || n.call(this),
            Je(this, Sc, void 0),
            (e = re(this, wc)) == null || e.call(this),
            Je(this, wc, void 0));
      }
      isFetching(n) {
        return re(this, Vn).findAll({ ...n, fetchStatus: "fetching" }).length;
      }
      isMutating(n) {
        return re(this, ia).findAll({ ...n, status: "pending" }).length;
      }
      getQueryData(n) {
        var e;
        return (e = re(this, Vn).find({ queryKey: n })) == null
          ? void 0
          : e.state.data;
      }
      ensureQueryData(n) {
        const e = this.getQueryData(n.queryKey);
        return e !== void 0 ? Promise.resolve(e) : this.fetchQuery(n);
      }
      getQueriesData(n) {
        return this.getQueryCache()
          .findAll(n)
          .map(({ queryKey: e, state: t }) => {
            const i = t.data;
            return [e, i];
          });
      }
      setQueryData(n, e, t) {
        const i = re(this, Vn).find({ queryKey: n }),
          r = i == null ? void 0 : i.state.data,
          s = fD(e, r);
        if (typeof s > "u") return;
        const o = this.defaultQueryOptions({ queryKey: n });
        return re(this, Vn)
          .build(this, o)
          .setData(s, { ...t, manual: !0 });
      }
      setQueriesData(n, e, t) {
        return oi.batch(() =>
          this.getQueryCache()
            .findAll(n)
            .map(({ queryKey: i }) => [i, this.setQueryData(i, e, t)]),
        );
      }
      getQueryState(n) {
        var e;
        return (e = re(this, Vn).find({ queryKey: n })) == null
          ? void 0
          : e.state;
      }
      removeQueries(n) {
        const e = re(this, Vn);
        oi.batch(() => {
          e.findAll(n).forEach((t) => {
            e.remove(t);
          });
        });
      }
      resetQueries(n, e) {
        const t = re(this, Vn),
          i = { type: "active", ...n };
        return oi.batch(
          () => (
            t.findAll(n).forEach((r) => {
              r.reset();
            }),
            this.refetchQueries(i, e)
          ),
        );
      }
      cancelQueries(n = {}, e = {}) {
        const t = { revert: !0, ...e },
          i = oi.batch(() =>
            re(this, Vn)
              .findAll(n)
              .map((r) => r.cancel(t)),
          );
        return Promise.all(i).then(Dr).catch(Dr);
      }
      invalidateQueries(n = {}, e = {}) {
        return oi.batch(() => {
          if (
            (re(this, Vn)
              .findAll(n)
              .forEach((i) => {
                i.invalidate();
              }),
            n.refetchType === "none")
          )
            return Promise.resolve();
          const t = { ...n, type: n.refetchType ?? n.type ?? "active" };
          return this.refetchQueries(t, e);
        });
      }
      refetchQueries(n = {}, e) {
        const t = {
            ...e,
            cancelRefetch: (e == null ? void 0 : e.cancelRefetch) ?? !0,
          },
          i = oi.batch(() =>
            re(this, Vn)
              .findAll(n)
              .filter((r) => !r.isDisabled())
              .map((r) => {
                let s = r.fetch(void 0, t);
                return (
                  t.throwOnError || (s = s.catch(Dr)),
                  r.state.fetchStatus === "paused" ? Promise.resolve() : s
                );
              }),
          );
        return Promise.all(i).then(Dr);
      }
      fetchQuery(n) {
        const e = this.defaultQueryOptions(n);
        typeof e.retry > "u" && (e.retry = !1);
        const t = re(this, Vn).build(this, e);
        return t.isStaleByTime(e.staleTime)
          ? t.fetch(e)
          : Promise.resolve(t.state.data);
      }
      prefetchQuery(n) {
        return this.fetchQuery(n).then(Dr).catch(Dr);
      }
      fetchInfiniteQuery(n) {
        return (n.behavior = bD(n.pages)), this.fetchQuery(n);
      }
      prefetchInfiniteQuery(n) {
        return this.fetchInfiniteQuery(n).then(Dr).catch(Dr);
      }
      resumePausedMutations() {
        return re(this, ia).resumePausedMutations();
      }
      getQueryCache() {
        return re(this, Vn);
      }
      getMutationCache() {
        return re(this, ia);
      }
      getDefaultOptions() {
        return re(this, ra);
      }
      setDefaultOptions(n) {
        Je(this, ra, n);
      }
      setQueryDefaults(n, e) {
        re(this, _c).set(Eh(n), { queryKey: n, defaultOptions: e });
      }
      getQueryDefaults(n) {
        const e = [...re(this, _c).values()];
        let t = {};
        return (
          e.forEach((i) => {
            Th(n, i.queryKey) && (t = { ...t, ...i.defaultOptions });
          }),
          t
        );
      }
      setMutationDefaults(n, e) {
        re(this, xc).set(Eh(n), { mutationKey: n, defaultOptions: e });
      }
      getMutationDefaults(n) {
        const e = [...re(this, xc).values()];
        let t = {};
        return (
          e.forEach((i) => {
            Th(n, i.mutationKey) && (t = { ...t, ...i.defaultOptions });
          }),
          t
        );
      }
      defaultQueryOptions(n) {
        if (n != null && n._defaulted) return n;
        const e = {
          ...re(this, ra).queries,
          ...((n == null ? void 0 : n.queryKey) &&
            this.getQueryDefaults(n.queryKey)),
          ...n,
          _defaulted: !0,
        };
        return (
          e.queryHash || (e.queryHash = _w(e.queryKey, e)),
          typeof e.refetchOnReconnect > "u" &&
            (e.refetchOnReconnect = e.networkMode !== "always"),
          typeof e.throwOnError > "u" && (e.throwOnError = !!e.suspense),
          typeof e.networkMode > "u" &&
            e.persister &&
            (e.networkMode = "offlineFirst"),
          e
        );
      }
      defaultMutationOptions(n) {
        return n != null && n._defaulted
          ? n
          : {
              ...re(this, ra).mutations,
              ...((n == null ? void 0 : n.mutationKey) &&
                this.getMutationDefaults(n.mutationKey)),
              ...n,
              _defaulted: !0,
            };
      }
      clear() {
        re(this, Vn).clear(), re(this, ia).clear();
      }
    }),
    (Vn = new WeakMap()),
    (ia = new WeakMap()),
    (ra = new WeakMap()),
    (_c = new WeakMap()),
    (xc = new WeakMap()),
    (sa = new WeakMap()),
    (Sc = new WeakMap()),
    (wc = new WeakMap()),
    Sb),
  qi,
  hn,
  Zh,
  Ii,
  Ml,
  Mc,
  Ts,
  Jh,
  Ec,
  Tc,
  El,
  Tl,
  oa,
  Cc,
  Cl,
  Hd,
  ef,
  px,
  tf,
  mx,
  nf,
  gx,
  rf,
  vx,
  sf,
  yx,
  of,
  _x,
  af,
  xx,
  Gg,
  t2,
  wb,
  RD =
    ((wb = class extends ff {
      constructor(e, t) {
        super();
        ct(this, Cl);
        ct(this, ef);
        ct(this, tf);
        ct(this, nf);
        ct(this, rf);
        ct(this, sf);
        ct(this, of);
        ct(this, af);
        ct(this, Gg);
        ct(this, qi, void 0);
        ct(this, hn, void 0);
        ct(this, Zh, void 0);
        ct(this, Ii, void 0);
        ct(this, Ml, void 0);
        ct(this, Mc, void 0);
        ct(this, Ts, void 0);
        ct(this, Jh, void 0);
        ct(this, Ec, void 0);
        ct(this, Tc, void 0);
        ct(this, El, void 0);
        ct(this, Tl, void 0);
        ct(this, oa, void 0);
        ct(this, Cc, new Set());
        (this.options = t),
          Je(this, qi, e),
          Je(this, Ts, null),
          this.bindMethods(),
          this.setOptions(t);
      }
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        this.listeners.size === 1 &&
          (re(this, hn).addObserver(this),
          uT(re(this, hn), this.options)
            ? Ft(this, Cl, Hd).call(this)
            : this.updateResult(),
          Ft(this, rf, vx).call(this));
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy();
      }
      shouldFetchOnReconnect() {
        return Sx(re(this, hn), this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return Sx(
          re(this, hn),
          this.options,
          this.options.refetchOnWindowFocus,
        );
      }
      destroy() {
        (this.listeners = new Set()),
          Ft(this, sf, yx).call(this),
          Ft(this, of, _x).call(this),
          re(this, hn).removeObserver(this);
      }
      setOptions(e, t) {
        const i = this.options,
          r = re(this, hn);
        if (
          ((this.options = re(this, qi).defaultQueryOptions(e)),
          dx(i, this.options) ||
            re(this, qi)
              .getQueryCache()
              .notify({
                type: "observerOptionsUpdated",
                query: re(this, hn),
                observer: this,
              }),
          typeof this.options.enabled < "u" &&
            typeof this.options.enabled != "boolean")
        )
          throw new Error("Expected enabled to be a boolean");
        this.options.queryKey || (this.options.queryKey = i.queryKey),
          Ft(this, af, xx).call(this);
        const s = this.hasListeners();
        s &&
          cT(re(this, hn), r, this.options, i) &&
          Ft(this, Cl, Hd).call(this),
          this.updateResult(t),
          s &&
            (re(this, hn) !== r ||
              this.options.enabled !== i.enabled ||
              this.options.staleTime !== i.staleTime) &&
            Ft(this, ef, px).call(this);
        const o = Ft(this, tf, mx).call(this);
        s &&
          (re(this, hn) !== r ||
            this.options.enabled !== i.enabled ||
            o !== re(this, oa)) &&
          Ft(this, nf, gx).call(this, o);
      }
      getOptimisticResult(e) {
        const t = re(this, qi).getQueryCache().build(re(this, qi), e),
          i = this.createResult(t, e);
        return (
          ID(this, i) &&
            (Je(this, Ii, i),
            Je(this, Mc, this.options),
            Je(this, Ml, re(this, hn).state)),
          i
        );
      }
      getCurrentResult() {
        return re(this, Ii);
      }
      trackResult(e) {
        const t = {};
        return (
          Object.keys(e).forEach((i) => {
            Object.defineProperty(t, i, {
              configurable: !1,
              enumerable: !0,
              get: () => (re(this, Cc).add(i), e[i]),
            });
          }),
          t
        );
      }
      getCurrentQuery() {
        return re(this, hn);
      }
      refetch({ ...e } = {}) {
        return this.fetch({ ...e });
      }
      fetchOptimistic(e) {
        const t = re(this, qi).defaultQueryOptions(e),
          i = re(this, qi).getQueryCache().build(re(this, qi), t);
        return (
          (i.isFetchingOptimistic = !0),
          i.fetch().then(() => this.createResult(i, t))
        );
      }
      fetch(e) {
        return Ft(this, Cl, Hd)
          .call(this, { ...e, cancelRefetch: e.cancelRefetch ?? !0 })
          .then(() => (this.updateResult(), re(this, Ii)));
      }
      createResult(e, t) {
        var C;
        const i = re(this, hn),
          r = this.options,
          s = re(this, Ii),
          o = re(this, Ml),
          a = re(this, Mc),
          h = e !== i ? e.state : re(this, Zh),
          { state: p } = e;
        let { error: v, errorUpdatedAt: y, fetchStatus: S, status: x } = p,
          _ = !1,
          f;
        if (t._optimisticResults) {
          const A = this.hasListeners(),
            L = !A && uT(e, t),
            N = A && cT(e, i, t, r);
          (L || N) &&
            ((S = cv(e.options.networkMode) ? "fetching" : "paused"),
            p.dataUpdatedAt || (x = "pending")),
            t._optimisticResults === "isRestoring" && (S = "idle");
        }
        if (t.select && typeof p.data < "u")
          if (
            s &&
            p.data === (o == null ? void 0 : o.data) &&
            t.select === re(this, Jh)
          )
            f = re(this, Ec);
          else
            try {
              Je(this, Jh, t.select),
                (f = t.select(p.data)),
                (f = fx(s == null ? void 0 : s.data, f, t)),
                Je(this, Ec, f),
                Je(this, Ts, null);
            } catch (A) {
              Je(this, Ts, A);
            }
        else f = p.data;
        if (
          typeof t.placeholderData < "u" &&
          typeof f > "u" &&
          x === "pending"
        ) {
          let A;
          if (
            s != null &&
            s.isPlaceholderData &&
            t.placeholderData === (a == null ? void 0 : a.placeholderData)
          )
            A = s.data;
          else if (
            ((A =
              typeof t.placeholderData == "function"
                ? t.placeholderData(
                    (C = re(this, Tc)) == null ? void 0 : C.state.data,
                    re(this, Tc),
                  )
                : t.placeholderData),
            t.select && typeof A < "u")
          )
            try {
              (A = t.select(A)), Je(this, Ts, null);
            } catch (L) {
              Je(this, Ts, L);
            }
          typeof A < "u" &&
            ((x = "success"),
            (f = fx(s == null ? void 0 : s.data, A, t)),
            (_ = !0));
        }
        re(this, Ts) &&
          ((v = re(this, Ts)),
          (f = re(this, Ec)),
          (y = Date.now()),
          (x = "error"));
        const d = S === "fetching",
          m = x === "pending",
          g = x === "error",
          w = m && d;
        return {
          status: x,
          fetchStatus: S,
          isPending: m,
          isSuccess: x === "success",
          isError: g,
          isInitialLoading: w,
          isLoading: w,
          data: f,
          dataUpdatedAt: p.dataUpdatedAt,
          error: v,
          errorUpdatedAt: y,
          failureCount: p.fetchFailureCount,
          failureReason: p.fetchFailureReason,
          errorUpdateCount: p.errorUpdateCount,
          isFetched: p.dataUpdateCount > 0 || p.errorUpdateCount > 0,
          isFetchedAfterMount:
            p.dataUpdateCount > h.dataUpdateCount ||
            p.errorUpdateCount > h.errorUpdateCount,
          isFetching: d,
          isRefetching: d && !m,
          isLoadingError: g && p.dataUpdatedAt === 0,
          isPaused: S === "paused",
          isPlaceholderData: _,
          isRefetchError: g && p.dataUpdatedAt !== 0,
          isStale: xw(e, t),
          refetch: this.refetch,
        };
      }
      updateResult(e) {
        const t = re(this, Ii),
          i = this.createResult(re(this, hn), this.options);
        if (
          (Je(this, Ml, re(this, hn).state),
          Je(this, Mc, this.options),
          re(this, Ml).data !== void 0 && Je(this, Tc, re(this, hn)),
          dx(i, t))
        )
          return;
        Je(this, Ii, i);
        const r = {},
          s = () => {
            if (!t) return !0;
            const { notifyOnChangeProps: o } = this.options,
              a = typeof o == "function" ? o() : o;
            if (a === "all" || (!a && !re(this, Cc).size)) return !0;
            const u = new Set(a ?? re(this, Cc));
            return (
              this.options.throwOnError && u.add("error"),
              Object.keys(re(this, Ii)).some((h) => {
                const p = h;
                return re(this, Ii)[p] !== t[p] && u.has(p);
              })
            );
          };
        (e == null ? void 0 : e.listeners) !== !1 && s() && (r.listeners = !0),
          Ft(this, Gg, t2).call(this, { ...r, ...e });
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && Ft(this, rf, vx).call(this);
      }
    }),
    (qi = new WeakMap()),
    (hn = new WeakMap()),
    (Zh = new WeakMap()),
    (Ii = new WeakMap()),
    (Ml = new WeakMap()),
    (Mc = new WeakMap()),
    (Ts = new WeakMap()),
    (Jh = new WeakMap()),
    (Ec = new WeakMap()),
    (Tc = new WeakMap()),
    (El = new WeakMap()),
    (Tl = new WeakMap()),
    (oa = new WeakMap()),
    (Cc = new WeakMap()),
    (Cl = new WeakSet()),
    (Hd = function (e) {
      Ft(this, af, xx).call(this);
      let t = re(this, hn).fetch(this.options, e);
      return (e != null && e.throwOnError) || (t = t.catch(Dr)), t;
    }),
    (ef = new WeakSet()),
    (px = function () {
      if (
        (Ft(this, sf, yx).call(this),
        kc || re(this, Ii).isStale || !cx(this.options.staleTime))
      )
        return;
      const t = KP(re(this, Ii).dataUpdatedAt, this.options.staleTime) + 1;
      Je(
        this,
        El,
        setTimeout(() => {
          re(this, Ii).isStale || this.updateResult();
        }, t),
      );
    }),
    (tf = new WeakSet()),
    (mx = function () {
      return (
        (typeof this.options.refetchInterval == "function"
          ? this.options.refetchInterval(re(this, hn))
          : this.options.refetchInterval) ?? !1
      );
    }),
    (nf = new WeakSet()),
    (gx = function (e) {
      Ft(this, of, _x).call(this),
        Je(this, oa, e),
        !(
          kc ||
          this.options.enabled === !1 ||
          !cx(re(this, oa)) ||
          re(this, oa) === 0
        ) &&
          Je(
            this,
            Tl,
            setInterval(
              () => {
                (this.options.refetchIntervalInBackground || Ig.isFocused()) &&
                  Ft(this, Cl, Hd).call(this);
              },
              re(this, oa),
            ),
          );
    }),
    (rf = new WeakSet()),
    (vx = function () {
      Ft(this, ef, px).call(this),
        Ft(this, nf, gx).call(this, Ft(this, tf, mx).call(this));
    }),
    (sf = new WeakSet()),
    (yx = function () {
      re(this, El) && (clearTimeout(re(this, El)), Je(this, El, void 0));
    }),
    (of = new WeakSet()),
    (_x = function () {
      re(this, Tl) && (clearInterval(re(this, Tl)), Je(this, Tl, void 0));
    }),
    (af = new WeakSet()),
    (xx = function () {
      const e = re(this, qi).getQueryCache().build(re(this, qi), this.options);
      if (e === re(this, hn)) return;
      const t = re(this, hn);
      Je(this, hn, e),
        Je(this, Zh, e.state),
        this.hasListeners() &&
          (t == null || t.removeObserver(this), e.addObserver(this));
    }),
    (Gg = new WeakSet()),
    (t2 = function (e) {
      oi.batch(() => {
        e.listeners &&
          this.listeners.forEach((t) => {
            t(re(this, Ii));
          }),
          re(this, qi)
            .getQueryCache()
            .notify({ query: re(this, hn), type: "observerResultsUpdated" });
      });
    }),
    wb);
function LD(n, e) {
  return (
    e.enabled !== !1 &&
    !n.state.dataUpdatedAt &&
    !(n.state.status === "error" && e.retryOnMount === !1)
  );
}
function uT(n, e) {
  return LD(n, e) || (n.state.dataUpdatedAt > 0 && Sx(n, e, e.refetchOnMount));
}
function Sx(n, e, t) {
  if (e.enabled !== !1) {
    const i = typeof t == "function" ? t(n) : t;
    return i === "always" || (i !== !1 && xw(n, e));
  }
  return !1;
}
function cT(n, e, t, i) {
  return (
    t.enabled !== !1 &&
    (n !== e || i.enabled === !1) &&
    (!t.suspense || n.state.status !== "error") &&
    xw(n, t)
  );
}
function xw(n, e) {
  return n.isStaleByTime(e.staleTime);
}
function ID(n, e) {
  return !dx(n.getCurrentResult(), e);
}
var n2 = se.createContext(void 0),
  OD = (n) => {
    const e = se.useContext(n2);
    if (n) return n;
    if (!e)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e;
  },
  ND = ({ client: n, children: e }) => (
    se.useEffect(
      () => (
        n.mount(),
        () => {
          n.unmount();
        }
      ),
      [n],
    ),
    se.createElement(n2.Provider, { value: n }, e)
  ),
  i2 = se.createContext(!1),
  DD = () => se.useContext(i2);
i2.Provider;
function kD() {
  let n = !1;
  return {
    clearReset: () => {
      n = !1;
    },
    reset: () => {
      n = !0;
    },
    isReset: () => n,
  };
}
var UD = se.createContext(kD()),
  FD = () => se.useContext(UD);
function BD(n, e) {
  return typeof n == "function" ? n(...e) : !!n;
}
var zD = (n, e) => {
    (n.suspense || n.throwOnError) && (e.isReset() || (n.retryOnMount = !1));
  },
  HD = (n) => {
    se.useEffect(() => {
      n.clearReset();
    }, [n]);
  },
  VD = ({ result: n, errorResetBoundary: e, throwOnError: t, query: i }) =>
    n.isError && !e.isReset() && !n.isFetching && i && BD(t, [n.error, i]),
  GD = (n) => {
    n.suspense && typeof n.staleTime != "number" && (n.staleTime = 1e3);
  },
  WD = (n, e) => (n == null ? void 0 : n.suspense) && e.isPending,
  jD = (n, e, t) =>
    e.fetchOptimistic(n).catch(() => {
      t.clearReset();
    });
function XD(n, e, t) {
  const i = OD(t),
    r = DD(),
    s = FD(),
    o = i.defaultQueryOptions(n);
  (o._optimisticResults = r ? "isRestoring" : "optimistic"),
    GD(o),
    zD(o, s),
    HD(s);
  const [a] = se.useState(() => new e(i, o)),
    u = a.getOptimisticResult(o);
  if (
    (se.useSyncExternalStore(
      se.useCallback(
        (h) => {
          const p = r ? () => {} : a.subscribe(oi.batchCalls(h));
          return a.updateResult(), p;
        },
        [a, r],
      ),
      () => a.getCurrentResult(),
      () => a.getCurrentResult(),
    ),
    se.useEffect(() => {
      a.setOptions(o, { listeners: !1 });
    }, [o, a]),
    WD(o, u))
  )
    throw jD(o, a, s);
  if (
    VD({
      result: u,
      errorResetBoundary: s,
      throwOnError: o.throwOnError,
      query: i.getQueryCache().get(o.queryHash),
    })
  )
    throw u.error;
  return o.notifyOnChangeProps ? u : a.trackResult(u);
}
function r2(n, e) {
  return XD(n, RD, e);
}
var qD = function () {
    return null;
  },
  $D = { exports: {} };
(function (n, e) {
  (function (t, i) {
    n.exports = i();
  })(self, () =>
    (() => {
      var t = {
          492: (o, a, u) => {
            u.r(a),
              u.d(a, {
                afterMain: () => Q,
                afterRead: () => N,
                afterWrite: () => X,
                applyStyles: () => ae,
                arrow: () => Re,
                auto: () => S,
                basePlacements: () => x,
                beforeMain: () => P,
                beforeRead: () => A,
                beforeWrite: () => ue,
                bottom: () => p,
                clippingParents: () => d,
                computeStyles: () => Be,
                createPopper: () => hs,
                createPopperBase: () => wo,
                createPopperLite: () => Mo,
                detectOverflow: () => Oe,
                end: () => f,
                eventListeners: () => mt,
                flip: () => De,
                hide: () => Vt,
                left: () => y,
                main: () => I,
                modifierPhases: () => G,
                offset: () => Xt,
                placements: () => C,
                popper: () => g,
                popperGenerator: () => ds,
                popperOffsets: () => mn,
                preventOverflow: () => $n,
                read: () => L,
                reference: () => w,
                right: () => v,
                start: () => _,
                top: () => h,
                variationPlacements: () => T,
                viewport: () => m,
                write: () => F,
              });
            var h = "top",
              p = "bottom",
              v = "right",
              y = "left",
              S = "auto",
              x = [h, p, v, y],
              _ = "start",
              f = "end",
              d = "clippingParents",
              m = "viewport",
              g = "popper",
              w = "reference",
              T = x.reduce(function (Z, K) {
                return Z.concat([K + "-" + _, K + "-" + f]);
              }, []),
              C = [].concat(x, [S]).reduce(function (Z, K) {
                return Z.concat([K, K + "-" + _, K + "-" + f]);
              }, []),
              A = "beforeRead",
              L = "read",
              N = "afterRead",
              P = "beforeMain",
              I = "main",
              Q = "afterMain",
              ue = "beforeWrite",
              F = "write",
              X = "afterWrite",
              G = [A, L, N, P, I, Q, ue, F, X];
            function ne(Z) {
              return Z ? (Z.nodeName || "").toLowerCase() : null;
            }
            function k(Z) {
              if (Z == null) return window;
              if (Z.toString() !== "[object Window]") {
                var K = Z.ownerDocument;
                return (K && K.defaultView) || window;
              }
              return Z;
            }
            function W(Z) {
              return Z instanceof k(Z).Element || Z instanceof Element;
            }
            function H(Z) {
              return Z instanceof k(Z).HTMLElement || Z instanceof HTMLElement;
            }
            function ee(Z) {
              return (
                typeof ShadowRoot < "u" &&
                (Z instanceof k(Z).ShadowRoot || Z instanceof ShadowRoot)
              );
            }
            const ae = {
              name: "applyStyles",
              enabled: !0,
              phase: "write",
              fn: function (Z) {
                var K = Z.state;
                Object.keys(K.elements).forEach(function (fe) {
                  var we = K.styles[fe] || {},
                    Xe = K.attributes[fe] || {},
                    O = K.elements[fe];
                  H(O) &&
                    ne(O) &&
                    (Object.assign(O.style, we),
                    Object.keys(Xe).forEach(function (q) {
                      var $ = Xe[q];
                      $ === !1
                        ? O.removeAttribute(q)
                        : O.setAttribute(q, $ === !0 ? "" : $);
                    }));
                });
              },
              effect: function (Z) {
                var K = Z.state,
                  fe = {
                    popper: {
                      position: K.options.strategy,
                      left: "0",
                      top: "0",
                      margin: "0",
                    },
                    arrow: { position: "absolute" },
                    reference: {},
                  };
                return (
                  Object.assign(K.elements.popper.style, fe.popper),
                  (K.styles = fe),
                  K.elements.arrow &&
                    Object.assign(K.elements.arrow.style, fe.arrow),
                  function () {
                    Object.keys(K.elements).forEach(function (we) {
                      var Xe = K.elements[we],
                        O = K.attributes[we] || {},
                        q = Object.keys(
                          K.styles.hasOwnProperty(we) ? K.styles[we] : fe[we],
                        ).reduce(function ($, Y) {
                          return ($[Y] = ""), $;
                        }, {});
                      H(Xe) &&
                        ne(Xe) &&
                        (Object.assign(Xe.style, q),
                        Object.keys(O).forEach(function ($) {
                          Xe.removeAttribute($);
                        }));
                    });
                  }
                );
              },
              requires: ["computeStyles"],
            };
            function xe(Z) {
              return Z.split("-")[0];
            }
            var te = Math.max,
              de = Math.min,
              ye = Math.round;
            function Ce() {
              var Z = navigator.userAgentData;
              return Z != null && Z.brands && Array.isArray(Z.brands)
                ? Z.brands
                    .map(function (K) {
                      return K.brand + "/" + K.version;
                    })
                    .join(" ")
                : navigator.userAgent;
            }
            function Ze() {
              return !/^((?!chrome|android).)*safari/i.test(Ce());
            }
            function ze(Z, K, fe) {
              K === void 0 && (K = !1), fe === void 0 && (fe = !1);
              var we = Z.getBoundingClientRect(),
                Xe = 1,
                O = 1;
              K &&
                H(Z) &&
                ((Xe =
                  (Z.offsetWidth > 0 && ye(we.width) / Z.offsetWidth) || 1),
                (O =
                  (Z.offsetHeight > 0 && ye(we.height) / Z.offsetHeight) || 1));
              var q = (W(Z) ? k(Z) : window).visualViewport,
                $ = !Ze() && fe,
                Y = (we.left + ($ && q ? q.offsetLeft : 0)) / Xe,
                J = (we.top + ($ && q ? q.offsetTop : 0)) / O,
                ve = we.width / Xe,
                _e = we.height / O;
              return {
                width: ve,
                height: _e,
                top: J,
                right: Y + ve,
                bottom: J + _e,
                left: Y,
                x: Y,
                y: J,
              };
            }
            function tt(Z) {
              var K = ze(Z),
                fe = Z.offsetWidth,
                we = Z.offsetHeight;
              return (
                Math.abs(K.width - fe) <= 1 && (fe = K.width),
                Math.abs(K.height - we) <= 1 && (we = K.height),
                { x: Z.offsetLeft, y: Z.offsetTop, width: fe, height: we }
              );
            }
            function Ge(Z, K) {
              var fe = K.getRootNode && K.getRootNode();
              if (Z.contains(K)) return !0;
              if (fe && ee(fe)) {
                var we = K;
                do {
                  if (we && Z.isSameNode(we)) return !0;
                  we = we.parentNode || we.host;
                } while (we);
              }
              return !1;
            }
            function V(Z) {
              return k(Z).getComputedStyle(Z);
            }
            function be(Z) {
              return ["table", "td", "th"].indexOf(ne(Z)) >= 0;
            }
            function ge(Z) {
              return ((W(Z) ? Z.ownerDocument : Z.document) || window.document)
                .documentElement;
            }
            function Le(Z) {
              return ne(Z) === "html"
                ? Z
                : Z.assignedSlot ||
                    Z.parentNode ||
                    (ee(Z) ? Z.host : null) ||
                    ge(Z);
            }
            function Se(Z) {
              return H(Z) && V(Z).position !== "fixed" ? Z.offsetParent : null;
            }
            function at(Z) {
              for (
                var K = k(Z), fe = Se(Z);
                fe && be(fe) && V(fe).position === "static";

              )
                fe = Se(fe);
              return fe &&
                (ne(fe) === "html" ||
                  (ne(fe) === "body" && V(fe).position === "static"))
                ? K
                : fe ||
                    (function (we) {
                      var Xe = /firefox/i.test(Ce());
                      if (
                        /Trident/i.test(Ce()) &&
                        H(we) &&
                        V(we).position === "fixed"
                      )
                        return null;
                      var O = Le(we);
                      for (
                        ee(O) && (O = O.host);
                        H(O) && ["html", "body"].indexOf(ne(O)) < 0;

                      ) {
                        var q = V(O);
                        if (
                          q.transform !== "none" ||
                          q.perspective !== "none" ||
                          q.contain === "paint" ||
                          ["transform", "perspective"].indexOf(q.willChange) !==
                            -1 ||
                          (Xe && q.willChange === "filter") ||
                          (Xe && q.filter && q.filter !== "none")
                        )
                          return O;
                        O = O.parentNode;
                      }
                      return null;
                    })(Z) ||
                    K;
            }
            function We(Z) {
              return ["top", "bottom"].indexOf(Z) >= 0 ? "x" : "y";
            }
            function U(Z, K, fe) {
              return te(Z, de(K, fe));
            }
            function D(Z) {
              return Object.assign(
                {},
                { top: 0, right: 0, bottom: 0, left: 0 },
                Z,
              );
            }
            function le(Z, K) {
              return K.reduce(function (fe, we) {
                return (fe[we] = Z), fe;
              }, {});
            }
            const Re = {
              name: "arrow",
              enabled: !0,
              phase: "main",
              fn: function (Z) {
                var K,
                  fe = Z.state,
                  we = Z.name,
                  Xe = Z.options,
                  O = fe.elements.arrow,
                  q = fe.modifiersData.popperOffsets,
                  $ = xe(fe.placement),
                  Y = We($),
                  J = [y, v].indexOf($) >= 0 ? "height" : "width";
                if (O && q) {
                  var ve = (function (et, gt) {
                      return D(
                        typeof (et =
                          typeof et == "function"
                            ? et(
                                Object.assign({}, gt.rects, {
                                  placement: gt.placement,
                                }),
                              )
                            : et) != "number"
                          ? et
                          : le(et, x),
                      );
                    })(Xe.padding, fe),
                    _e = tt(O),
                    Ve = Y === "y" ? h : y,
                    Ue = Y === "y" ? p : v,
                    $e =
                      fe.rects.reference[J] +
                      fe.rects.reference[Y] -
                      q[Y] -
                      fe.rects.popper[J],
                    je = q[Y] - fe.rects.reference[Y],
                    Fe = at(O),
                    St = Fe
                      ? Y === "y"
                        ? Fe.clientHeight || 0
                        : Fe.clientWidth || 0
                      : 0,
                    bt = $e / 2 - je / 2,
                    pt = ve[Ve],
                    xt = St - _e[J] - ve[Ue],
                    Ne = St / 2 - _e[J] / 2 + bt,
                    Pe = U(pt, Ne, xt),
                    At = Y;
                  fe.modifiersData[we] =
                    (((K = {})[At] = Pe), (K.centerOffset = Pe - Ne), K);
                }
              },
              effect: function (Z) {
                var K = Z.state,
                  fe = Z.options.element,
                  we = fe === void 0 ? "[data-popper-arrow]" : fe;
                we != null &&
                  (typeof we != "string" ||
                    (we = K.elements.popper.querySelector(we))) &&
                  Ge(K.elements.popper, we) &&
                  (K.elements.arrow = we);
              },
              requires: ["popperOffsets"],
              requiresIfExists: ["preventOverflow"],
            };
            function Ee(Z) {
              return Z.split("-")[1];
            }
            var Te = {
              top: "auto",
              right: "auto",
              bottom: "auto",
              left: "auto",
            };
            function rt(Z) {
              var K,
                fe = Z.popper,
                we = Z.popperRect,
                Xe = Z.placement,
                O = Z.variation,
                q = Z.offsets,
                $ = Z.position,
                Y = Z.gpuAcceleration,
                J = Z.adaptive,
                ve = Z.roundOffsets,
                _e = Z.isFixed,
                Ve = q.x,
                Ue = Ve === void 0 ? 0 : Ve,
                $e = q.y,
                je = $e === void 0 ? 0 : $e,
                Fe =
                  typeof ve == "function"
                    ? ve({ x: Ue, y: je })
                    : { x: Ue, y: je };
              (Ue = Fe.x), (je = Fe.y);
              var St = q.hasOwnProperty("x"),
                bt = q.hasOwnProperty("y"),
                pt = y,
                xt = h,
                Ne = window;
              if (J) {
                var Pe = at(fe),
                  At = "clientHeight",
                  et = "clientWidth";
                Pe === k(fe) &&
                  V((Pe = ge(fe))).position !== "static" &&
                  $ === "absolute" &&
                  ((At = "scrollHeight"), (et = "scrollWidth")),
                  (Xe === h || ((Xe === y || Xe === v) && O === f)) &&
                    ((xt = p),
                    (je -=
                      (_e && Pe === Ne && Ne.visualViewport
                        ? Ne.visualViewport.height
                        : Pe[At]) - we.height),
                    (je *= Y ? 1 : -1)),
                  (Xe === y || ((Xe === h || Xe === p) && O === f)) &&
                    ((pt = v),
                    (Ue -=
                      (_e && Pe === Ne && Ne.visualViewport
                        ? Ne.visualViewport.width
                        : Pe[et]) - we.width),
                    (Ue *= Y ? 1 : -1));
              }
              var gt,
                qt = Object.assign({ position: $ }, J && Te),
                on =
                  ve === !0
                    ? (function (tn, Gt) {
                        var Nn = tn.x,
                          ni = tn.y,
                          Bt = Gt.devicePixelRatio || 1;
                        return {
                          x: ye(Nn * Bt) / Bt || 0,
                          y: ye(ni * Bt) / Bt || 0,
                        };
                      })({ x: Ue, y: je }, k(fe))
                    : { x: Ue, y: je };
              return (
                (Ue = on.x),
                (je = on.y),
                Y
                  ? Object.assign(
                      {},
                      qt,
                      (((gt = {})[xt] = bt ? "0" : ""),
                      (gt[pt] = St ? "0" : ""),
                      (gt.transform =
                        (Ne.devicePixelRatio || 1) <= 1
                          ? "translate(" + Ue + "px, " + je + "px)"
                          : "translate3d(" + Ue + "px, " + je + "px, 0)"),
                      gt),
                    )
                  : Object.assign(
                      {},
                      qt,
                      (((K = {})[xt] = bt ? je + "px" : ""),
                      (K[pt] = St ? Ue + "px" : ""),
                      (K.transform = ""),
                      K),
                    )
              );
            }
            const Be = {
              name: "computeStyles",
              enabled: !0,
              phase: "beforeWrite",
              fn: function (Z) {
                var K = Z.state,
                  fe = Z.options,
                  we = fe.gpuAcceleration,
                  Xe = we === void 0 || we,
                  O = fe.adaptive,
                  q = O === void 0 || O,
                  $ = fe.roundOffsets,
                  Y = $ === void 0 || $,
                  J = {
                    placement: xe(K.placement),
                    variation: Ee(K.placement),
                    popper: K.elements.popper,
                    popperRect: K.rects.popper,
                    gpuAcceleration: Xe,
                    isFixed: K.options.strategy === "fixed",
                  };
                K.modifiersData.popperOffsets != null &&
                  (K.styles.popper = Object.assign(
                    {},
                    K.styles.popper,
                    rt(
                      Object.assign({}, J, {
                        offsets: K.modifiersData.popperOffsets,
                        position: K.options.strategy,
                        adaptive: q,
                        roundOffsets: Y,
                      }),
                    ),
                  )),
                  K.modifiersData.arrow != null &&
                    (K.styles.arrow = Object.assign(
                      {},
                      K.styles.arrow,
                      rt(
                        Object.assign({}, J, {
                          offsets: K.modifiersData.arrow,
                          position: "absolute",
                          adaptive: !1,
                          roundOffsets: Y,
                        }),
                      ),
                    )),
                  (K.attributes.popper = Object.assign(
                    {},
                    K.attributes.popper,
                    { "data-popper-placement": K.placement },
                  ));
              },
              data: {},
            };
            var Ke = { passive: !0 };
            const mt = {
              name: "eventListeners",
              enabled: !0,
              phase: "write",
              fn: function () {},
              effect: function (Z) {
                var K = Z.state,
                  fe = Z.instance,
                  we = Z.options,
                  Xe = we.scroll,
                  O = Xe === void 0 || Xe,
                  q = we.resize,
                  $ = q === void 0 || q,
                  Y = k(K.elements.popper),
                  J = [].concat(
                    K.scrollParents.reference,
                    K.scrollParents.popper,
                  );
                return (
                  O &&
                    J.forEach(function (ve) {
                      ve.addEventListener("scroll", fe.update, Ke);
                    }),
                  $ && Y.addEventListener("resize", fe.update, Ke),
                  function () {
                    O &&
                      J.forEach(function (ve) {
                        ve.removeEventListener("scroll", fe.update, Ke);
                      }),
                      $ && Y.removeEventListener("resize", fe.update, Ke);
                  }
                );
              },
              data: {},
            };
            var wt = {
              left: "right",
              right: "left",
              bottom: "top",
              top: "bottom",
            };
            function Ae(Z) {
              return Z.replace(/left|right|bottom|top/g, function (K) {
                return wt[K];
              });
            }
            var Ht = { start: "end", end: "start" };
            function Ct(Z) {
              return Z.replace(/start|end/g, function (K) {
                return Ht[K];
              });
            }
            function yt(Z) {
              var K = k(Z);
              return { scrollLeft: K.pageXOffset, scrollTop: K.pageYOffset };
            }
            function dt(Z) {
              return ze(ge(Z)).left + yt(Z).scrollLeft;
            }
            function nt(Z) {
              var K = V(Z),
                fe = K.overflow,
                we = K.overflowX,
                Xe = K.overflowY;
              return /auto|scroll|overlay|hidden/.test(fe + Xe + we);
            }
            function Mt(Z) {
              return ["html", "body", "#document"].indexOf(ne(Z)) >= 0
                ? Z.ownerDocument.body
                : H(Z) && nt(Z)
                  ? Z
                  : Mt(Le(Z));
            }
            function kt(Z, K) {
              var fe;
              K === void 0 && (K = []);
              var we = Mt(Z),
                Xe = we === ((fe = Z.ownerDocument) == null ? void 0 : fe.body),
                O = k(we),
                q = Xe
                  ? [O].concat(O.visualViewport || [], nt(we) ? we : [])
                  : we,
                $ = K.concat(q);
              return Xe ? $ : $.concat(kt(Le(q)));
            }
            function Qt(Z) {
              return Object.assign({}, Z, {
                left: Z.x,
                top: Z.y,
                right: Z.x + Z.width,
                bottom: Z.y + Z.height,
              });
            }
            function Lt(Z, K, fe) {
              return K === m
                ? Qt(
                    (function (we, Xe) {
                      var O = k(we),
                        q = ge(we),
                        $ = O.visualViewport,
                        Y = q.clientWidth,
                        J = q.clientHeight,
                        ve = 0,
                        _e = 0;
                      if ($) {
                        (Y = $.width), (J = $.height);
                        var Ve = Ze();
                        (Ve || (!Ve && Xe === "fixed")) &&
                          ((ve = $.offsetLeft), (_e = $.offsetTop));
                      }
                      return { width: Y, height: J, x: ve + dt(we), y: _e };
                    })(Z, fe),
                  )
                : W(K)
                  ? (function (we, Xe) {
                      var O = ze(we, !1, Xe === "fixed");
                      return (
                        (O.top = O.top + we.clientTop),
                        (O.left = O.left + we.clientLeft),
                        (O.bottom = O.top + we.clientHeight),
                        (O.right = O.left + we.clientWidth),
                        (O.width = we.clientWidth),
                        (O.height = we.clientHeight),
                        (O.x = O.left),
                        (O.y = O.top),
                        O
                      );
                    })(K, fe)
                  : Qt(
                      (function (we) {
                        var Xe,
                          O = ge(we),
                          q = yt(we),
                          $ =
                            (Xe = we.ownerDocument) == null ? void 0 : Xe.body,
                          Y = te(
                            O.scrollWidth,
                            O.clientWidth,
                            $ ? $.scrollWidth : 0,
                            $ ? $.clientWidth : 0,
                          ),
                          J = te(
                            O.scrollHeight,
                            O.clientHeight,
                            $ ? $.scrollHeight : 0,
                            $ ? $.clientHeight : 0,
                          ),
                          ve = -q.scrollLeft + dt(we),
                          _e = -q.scrollTop;
                        return (
                          V($ || O).direction === "rtl" &&
                            (ve +=
                              te(O.clientWidth, $ ? $.clientWidth : 0) - Y),
                          { width: Y, height: J, x: ve, y: _e }
                        );
                      })(ge(Z)),
                    );
            }
            function Zt(Z, K, fe, we) {
              var Xe =
                  K === "clippingParents"
                    ? (function (Y) {
                        var J = kt(Le(Y)),
                          ve =
                            ["absolute", "fixed"].indexOf(V(Y).position) >= 0 &&
                            H(Y)
                              ? at(Y)
                              : Y;
                        return W(ve)
                          ? J.filter(function (_e) {
                              return W(_e) && Ge(_e, ve) && ne(_e) !== "body";
                            })
                          : [];
                      })(Z)
                    : [].concat(K),
                O = [].concat(Xe, [fe]),
                q = O[0],
                $ = O.reduce(
                  function (Y, J) {
                    var ve = Lt(Z, J, we);
                    return (
                      (Y.top = te(ve.top, Y.top)),
                      (Y.right = de(ve.right, Y.right)),
                      (Y.bottom = de(ve.bottom, Y.bottom)),
                      (Y.left = te(ve.left, Y.left)),
                      Y
                    );
                  },
                  Lt(Z, q, we),
                );
              return (
                ($.width = $.right - $.left),
                ($.height = $.bottom - $.top),
                ($.x = $.left),
                ($.y = $.top),
                $
              );
            }
            function j(Z) {
              var K,
                fe = Z.reference,
                we = Z.element,
                Xe = Z.placement,
                O = Xe ? xe(Xe) : null,
                q = Xe ? Ee(Xe) : null,
                $ = fe.x + fe.width / 2 - we.width / 2,
                Y = fe.y + fe.height / 2 - we.height / 2;
              switch (O) {
                case h:
                  K = { x: $, y: fe.y - we.height };
                  break;
                case p:
                  K = { x: $, y: fe.y + fe.height };
                  break;
                case v:
                  K = { x: fe.x + fe.width, y: Y };
                  break;
                case y:
                  K = { x: fe.x - we.width, y: Y };
                  break;
                default:
                  K = { x: fe.x, y: fe.y };
              }
              var J = O ? We(O) : null;
              if (J != null) {
                var ve = J === "y" ? "height" : "width";
                switch (q) {
                  case _:
                    K[J] = K[J] - (fe[ve] / 2 - we[ve] / 2);
                    break;
                  case f:
                    K[J] = K[J] + (fe[ve] / 2 - we[ve] / 2);
                }
              }
              return K;
            }
            function Oe(Z, K) {
              K === void 0 && (K = {});
              var fe = K,
                we = fe.placement,
                Xe = we === void 0 ? Z.placement : we,
                O = fe.strategy,
                q = O === void 0 ? Z.strategy : O,
                $ = fe.boundary,
                Y = $ === void 0 ? d : $,
                J = fe.rootBoundary,
                ve = J === void 0 ? m : J,
                _e = fe.elementContext,
                Ve = _e === void 0 ? g : _e,
                Ue = fe.altBoundary,
                $e = Ue !== void 0 && Ue,
                je = fe.padding,
                Fe = je === void 0 ? 0 : je,
                St = D(typeof Fe != "number" ? Fe : le(Fe, x)),
                bt = Ve === g ? w : g,
                pt = Z.rects.popper,
                xt = Z.elements[$e ? bt : Ve],
                Ne = Zt(
                  W(xt) ? xt : xt.contextElement || ge(Z.elements.popper),
                  Y,
                  ve,
                  q,
                ),
                Pe = ze(Z.elements.reference),
                At = j({
                  reference: Pe,
                  element: pt,
                  strategy: "absolute",
                  placement: Xe,
                }),
                et = Qt(Object.assign({}, pt, At)),
                gt = Ve === g ? et : Pe,
                qt = {
                  top: Ne.top - gt.top + St.top,
                  bottom: gt.bottom - Ne.bottom + St.bottom,
                  left: Ne.left - gt.left + St.left,
                  right: gt.right - Ne.right + St.right,
                },
                on = Z.modifiersData.offset;
              if (Ve === g && on) {
                var tn = on[Xe];
                Object.keys(qt).forEach(function (Gt) {
                  var Nn = [v, p].indexOf(Gt) >= 0 ? 1 : -1,
                    ni = [h, p].indexOf(Gt) >= 0 ? "y" : "x";
                  qt[Gt] += tn[ni] * Nn;
                });
              }
              return qt;
            }
            const De = {
              name: "flip",
              enabled: !0,
              phase: "main",
              fn: function (Z) {
                var K = Z.state,
                  fe = Z.options,
                  we = Z.name;
                if (!K.modifiersData[we]._skip) {
                  for (
                    var Xe = fe.mainAxis,
                      O = Xe === void 0 || Xe,
                      q = fe.altAxis,
                      $ = q === void 0 || q,
                      Y = fe.fallbackPlacements,
                      J = fe.padding,
                      ve = fe.boundary,
                      _e = fe.rootBoundary,
                      Ve = fe.altBoundary,
                      Ue = fe.flipVariations,
                      $e = Ue === void 0 || Ue,
                      je = fe.allowedAutoPlacements,
                      Fe = K.options.placement,
                      St = xe(Fe),
                      bt =
                        Y ||
                        (St === Fe || !$e
                          ? [Ae(Fe)]
                          : (function (er) {
                              if (xe(er) === S) return [];
                              var di = Ae(er);
                              return [Ct(er), di, Ct(di)];
                            })(Fe)),
                      pt = [Fe].concat(bt).reduce(function (er, di) {
                        return er.concat(
                          xe(di) === S
                            ? (function (Wr, Vi) {
                                Vi === void 0 && (Vi = {});
                                var hi = Vi,
                                  Ql = hi.placement,
                                  Zl = hi.boundary,
                                  fs = hi.rootBoundary,
                                  Da = hi.padding,
                                  Fs = hi.flipVariations,
                                  To = hi.allowedAutoPlacements,
                                  ka = To === void 0 ? C : To,
                                  Ut = Ee(Ql),
                                  Ua = Ut
                                    ? Fs
                                      ? T
                                      : T.filter(function (Sr) {
                                          return Ee(Sr) === Ut;
                                        })
                                    : x,
                                  ps = Ua.filter(function (Sr) {
                                    return ka.indexOf(Sr) >= 0;
                                  });
                                ps.length === 0 && (ps = Ua);
                                var Bs = ps.reduce(function (Sr, zs) {
                                  return (
                                    (Sr[zs] = Oe(Wr, {
                                      placement: zs,
                                      boundary: Zl,
                                      rootBoundary: fs,
                                      padding: Da,
                                    })[xe(zs)]),
                                    Sr
                                  );
                                }, {});
                                return Object.keys(Bs).sort(function (Sr, zs) {
                                  return Bs[Sr] - Bs[zs];
                                });
                              })(K, {
                                placement: di,
                                boundary: ve,
                                rootBoundary: _e,
                                padding: J,
                                flipVariations: $e,
                                allowedAutoPlacements: je,
                              })
                            : di,
                        );
                      }, []),
                      xt = K.rects.reference,
                      Ne = K.rects.popper,
                      Pe = new Map(),
                      At = !0,
                      et = pt[0],
                      gt = 0;
                    gt < pt.length;
                    gt++
                  ) {
                    var qt = pt[gt],
                      on = xe(qt),
                      tn = Ee(qt) === _,
                      Gt = [h, p].indexOf(on) >= 0,
                      Nn = Gt ? "width" : "height",
                      ni = Oe(K, {
                        placement: qt,
                        boundary: ve,
                        rootBoundary: _e,
                        altBoundary: Ve,
                        padding: J,
                      }),
                      Bt = Gt ? (tn ? v : y) : tn ? p : h;
                    xt[Nn] > Ne[Nn] && (Bt = Ae(Bt));
                    var bi = Ae(Bt),
                      Pn = [];
                    if (
                      (O && Pn.push(ni[on] <= 0),
                      $ && Pn.push(ni[Bt] <= 0, ni[bi] <= 0),
                      Pn.every(function (er) {
                        return er;
                      }))
                    ) {
                      (et = qt), (At = !1);
                      break;
                    }
                    Pe.set(qt, Pn);
                  }
                  if (At)
                    for (
                      var Us = function (er) {
                          var di = pt.find(function (Wr) {
                            var Vi = Pe.get(Wr);
                            if (Vi)
                              return Vi.slice(0, er).every(function (hi) {
                                return hi;
                              });
                          });
                          if (di) return (et = di), "break";
                        },
                        Eo = $e ? 3 : 1;
                      Eo > 0 && Us(Eo) !== "break";
                      Eo--
                    );
                  K.placement !== et &&
                    ((K.modifiersData[we]._skip = !0),
                    (K.placement = et),
                    (K.reset = !0));
                }
              },
              requiresIfExists: ["offset"],
              data: { _skip: !1 },
            };
            function ot(Z, K, fe) {
              return (
                fe === void 0 && (fe = { x: 0, y: 0 }),
                {
                  top: Z.top - K.height - fe.y,
                  right: Z.right - K.width + fe.x,
                  bottom: Z.bottom - K.height + fe.y,
                  left: Z.left - K.width - fe.x,
                }
              );
            }
            function ft(Z) {
              return [h, v, p, y].some(function (K) {
                return Z[K] >= 0;
              });
            }
            const Vt = {
                name: "hide",
                enabled: !0,
                phase: "main",
                requiresIfExists: ["preventOverflow"],
                fn: function (Z) {
                  var K = Z.state,
                    fe = Z.name,
                    we = K.rects.reference,
                    Xe = K.rects.popper,
                    O = K.modifiersData.preventOverflow,
                    q = Oe(K, { elementContext: "reference" }),
                    $ = Oe(K, { altBoundary: !0 }),
                    Y = ot(q, we),
                    J = ot($, Xe, O),
                    ve = ft(Y),
                    _e = ft(J);
                  (K.modifiersData[fe] = {
                    referenceClippingOffsets: Y,
                    popperEscapeOffsets: J,
                    isReferenceHidden: ve,
                    hasPopperEscaped: _e,
                  }),
                    (K.attributes.popper = Object.assign(
                      {},
                      K.attributes.popper,
                      {
                        "data-popper-reference-hidden": ve,
                        "data-popper-escaped": _e,
                      },
                    ));
                },
              },
              Xt = {
                name: "offset",
                enabled: !0,
                phase: "main",
                requires: ["popperOffsets"],
                fn: function (Z) {
                  var K = Z.state,
                    fe = Z.options,
                    we = Z.name,
                    Xe = fe.offset,
                    O = Xe === void 0 ? [0, 0] : Xe,
                    q = C.reduce(function (ve, _e) {
                      return (
                        (ve[_e] = (function (Ve, Ue, $e) {
                          var je = xe(Ve),
                            Fe = [y, h].indexOf(je) >= 0 ? -1 : 1,
                            St =
                              typeof $e == "function"
                                ? $e(Object.assign({}, Ue, { placement: Ve }))
                                : $e,
                            bt = St[0],
                            pt = St[1];
                          return (
                            (bt = bt || 0),
                            (pt = (pt || 0) * Fe),
                            [y, v].indexOf(je) >= 0
                              ? { x: pt, y: bt }
                              : { x: bt, y: pt }
                          );
                        })(_e, K.rects, O)),
                        ve
                      );
                    }, {}),
                    $ = q[K.placement],
                    Y = $.x,
                    J = $.y;
                  K.modifiersData.popperOffsets != null &&
                    ((K.modifiersData.popperOffsets.x += Y),
                    (K.modifiersData.popperOffsets.y += J)),
                    (K.modifiersData[we] = q);
                },
              },
              mn = {
                name: "popperOffsets",
                enabled: !0,
                phase: "read",
                fn: function (Z) {
                  var K = Z.state,
                    fe = Z.name;
                  K.modifiersData[fe] = j({
                    reference: K.rects.reference,
                    element: K.rects.popper,
                    strategy: "absolute",
                    placement: K.placement,
                  });
                },
                data: {},
              },
              $n = {
                name: "preventOverflow",
                enabled: !0,
                phase: "main",
                fn: function (Z) {
                  var K = Z.state,
                    fe = Z.options,
                    we = Z.name,
                    Xe = fe.mainAxis,
                    O = Xe === void 0 || Xe,
                    q = fe.altAxis,
                    $ = q !== void 0 && q,
                    Y = fe.boundary,
                    J = fe.rootBoundary,
                    ve = fe.altBoundary,
                    _e = fe.padding,
                    Ve = fe.tether,
                    Ue = Ve === void 0 || Ve,
                    $e = fe.tetherOffset,
                    je = $e === void 0 ? 0 : $e,
                    Fe = Oe(K, {
                      boundary: Y,
                      rootBoundary: J,
                      padding: _e,
                      altBoundary: ve,
                    }),
                    St = xe(K.placement),
                    bt = Ee(K.placement),
                    pt = !bt,
                    xt = We(St),
                    Ne = xt === "x" ? "y" : "x",
                    Pe = K.modifiersData.popperOffsets,
                    At = K.rects.reference,
                    et = K.rects.popper,
                    gt =
                      typeof je == "function"
                        ? je(
                            Object.assign({}, K.rects, {
                              placement: K.placement,
                            }),
                          )
                        : je,
                    qt =
                      typeof gt == "number"
                        ? { mainAxis: gt, altAxis: gt }
                        : Object.assign({ mainAxis: 0, altAxis: 0 }, gt),
                    on = K.modifiersData.offset
                      ? K.modifiersData.offset[K.placement]
                      : null,
                    tn = { x: 0, y: 0 };
                  if (Pe) {
                    if (O) {
                      var Gt,
                        Nn = xt === "y" ? h : y,
                        ni = xt === "y" ? p : v,
                        Bt = xt === "y" ? "height" : "width",
                        bi = Pe[xt],
                        Pn = bi + Fe[Nn],
                        Us = bi - Fe[ni],
                        Eo = Ue ? -et[Bt] / 2 : 0,
                        er = bt === _ ? At[Bt] : et[Bt],
                        di = bt === _ ? -et[Bt] : -At[Bt],
                        Wr = K.elements.arrow,
                        Vi = Ue && Wr ? tt(Wr) : { width: 0, height: 0 },
                        hi = K.modifiersData["arrow#persistent"]
                          ? K.modifiersData["arrow#persistent"].padding
                          : { top: 0, right: 0, bottom: 0, left: 0 },
                        Ql = hi[Nn],
                        Zl = hi[ni],
                        fs = U(0, At[Bt], Vi[Bt]),
                        Da = pt
                          ? At[Bt] / 2 - Eo - fs - Ql - qt.mainAxis
                          : er - fs - Ql - qt.mainAxis,
                        Fs = pt
                          ? -At[Bt] / 2 + Eo + fs + Zl + qt.mainAxis
                          : di + fs + Zl + qt.mainAxis,
                        To = K.elements.arrow && at(K.elements.arrow),
                        ka = To
                          ? xt === "y"
                            ? To.clientTop || 0
                            : To.clientLeft || 0
                          : 0,
                        Ut =
                          (Gt = on == null ? void 0 : on[xt]) != null ? Gt : 0,
                        Ua = bi + Fs - Ut,
                        ps = U(
                          Ue ? de(Pn, bi + Da - Ut - ka) : Pn,
                          bi,
                          Ue ? te(Us, Ua) : Us,
                        );
                      (Pe[xt] = ps), (tn[xt] = ps - bi);
                    }
                    if ($) {
                      var Bs,
                        Sr = xt === "x" ? h : y,
                        zs = xt === "x" ? p : v,
                        ln = Pe[Ne],
                        Co = Ne === "y" ? "height" : "width",
                        Rf = ln + Fe[Sr],
                        Jl = ln - Fe[zs],
                        Qc = [h, y].indexOf(St) !== -1,
                        Fa =
                          (Bs = on == null ? void 0 : on[Ne]) != null ? Bs : 0,
                        tr = Qc ? Rf : ln - At[Co] - et[Co] - Fa + qt.altAxis,
                        Lf = Qc ? ln + At[Co] + et[Co] - Fa - qt.altAxis : Jl,
                        If =
                          Ue && Qc
                            ? (function (wr, jr, bo) {
                                var eu = U(wr, jr, bo);
                                return eu > bo ? bo : eu;
                              })(tr, ln, Lf)
                            : U(Ue ? tr : Rf, ln, Ue ? Lf : Jl);
                      (Pe[Ne] = If), (tn[Ne] = If - ln);
                    }
                    K.modifiersData[we] = tn;
                  }
                },
                requiresIfExists: ["offset"],
              };
            function en(Z, K, fe) {
              fe === void 0 && (fe = !1);
              var we,
                Xe,
                O = H(K),
                q =
                  H(K) &&
                  (function (_e) {
                    var Ve = _e.getBoundingClientRect(),
                      Ue = ye(Ve.width) / _e.offsetWidth || 1,
                      $e = ye(Ve.height) / _e.offsetHeight || 1;
                    return Ue !== 1 || $e !== 1;
                  })(K),
                $ = ge(K),
                Y = ze(Z, q, fe),
                J = { scrollLeft: 0, scrollTop: 0 },
                ve = { x: 0, y: 0 };
              return (
                (O || (!O && !fe)) &&
                  ((ne(K) !== "body" || nt($)) &&
                    (J =
                      (we = K) !== k(we) && H(we)
                        ? {
                            scrollLeft: (Xe = we).scrollLeft,
                            scrollTop: Xe.scrollTop,
                          }
                        : yt(we)),
                  H(K)
                    ? (((ve = ze(K, !0)).x += K.clientLeft),
                      (ve.y += K.clientTop))
                    : $ && (ve.x = dt($))),
                {
                  x: Y.left + J.scrollLeft - ve.x,
                  y: Y.top + J.scrollTop - ve.y,
                  width: Y.width,
                  height: Y.height,
                }
              );
            }
            function zn(Z) {
              var K = new Map(),
                fe = new Set(),
                we = [];
              function Xe(O) {
                fe.add(O.name),
                  []
                    .concat(O.requires || [], O.requiresIfExists || [])
                    .forEach(function (q) {
                      if (!fe.has(q)) {
                        var $ = K.get(q);
                        $ && Xe($);
                      }
                    }),
                  we.push(O);
              }
              return (
                Z.forEach(function (O) {
                  K.set(O.name, O);
                }),
                Z.forEach(function (O) {
                  fe.has(O.name) || Xe(O);
                }),
                we
              );
            }
            var Ci = {
              placement: "bottom",
              modifiers: [],
              strategy: "absolute",
            };
            function So() {
              for (
                var Z = arguments.length, K = new Array(Z), fe = 0;
                fe < Z;
                fe++
              )
                K[fe] = arguments[fe];
              return !K.some(function (we) {
                return !(we && typeof we.getBoundingClientRect == "function");
              });
            }
            function ds(Z) {
              Z === void 0 && (Z = {});
              var K = Z,
                fe = K.defaultModifiers,
                we = fe === void 0 ? [] : fe,
                Xe = K.defaultOptions,
                O = Xe === void 0 ? Ci : Xe;
              return function (q, $, Y) {
                Y === void 0 && (Y = O);
                var J,
                  ve,
                  _e = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, Ci, O),
                    modifiersData: {},
                    elements: { reference: q, popper: $ },
                    attributes: {},
                    styles: {},
                  },
                  Ve = [],
                  Ue = !1,
                  $e = {
                    state: _e,
                    setOptions: function (Fe) {
                      var St = typeof Fe == "function" ? Fe(_e.options) : Fe;
                      je(),
                        (_e.options = Object.assign({}, O, _e.options, St)),
                        (_e.scrollParents = {
                          reference: W(q)
                            ? kt(q)
                            : q.contextElement
                              ? kt(q.contextElement)
                              : [],
                          popper: kt($),
                        });
                      var bt,
                        pt,
                        xt = (function (Ne) {
                          var Pe = zn(Ne);
                          return G.reduce(function (At, et) {
                            return At.concat(
                              Pe.filter(function (gt) {
                                return gt.phase === et;
                              }),
                            );
                          }, []);
                        })(
                          ((bt = [].concat(we, _e.options.modifiers)),
                          (pt = bt.reduce(function (Ne, Pe) {
                            var At = Ne[Pe.name];
                            return (
                              (Ne[Pe.name] = At
                                ? Object.assign({}, At, Pe, {
                                    options: Object.assign(
                                      {},
                                      At.options,
                                      Pe.options,
                                    ),
                                    data: Object.assign({}, At.data, Pe.data),
                                  })
                                : Pe),
                              Ne
                            );
                          }, {})),
                          Object.keys(pt).map(function (Ne) {
                            return pt[Ne];
                          })),
                        );
                      return (
                        (_e.orderedModifiers = xt.filter(function (Ne) {
                          return Ne.enabled;
                        })),
                        _e.orderedModifiers.forEach(function (Ne) {
                          var Pe = Ne.name,
                            At = Ne.options,
                            et = At === void 0 ? {} : At,
                            gt = Ne.effect;
                          if (typeof gt == "function") {
                            var qt = gt({
                                state: _e,
                                name: Pe,
                                instance: $e,
                                options: et,
                              }),
                              on = function () {};
                            Ve.push(qt || on);
                          }
                        }),
                        $e.update()
                      );
                    },
                    forceUpdate: function () {
                      if (!Ue) {
                        var Fe = _e.elements,
                          St = Fe.reference,
                          bt = Fe.popper;
                        if (So(St, bt)) {
                          (_e.rects = {
                            reference: en(
                              St,
                              at(bt),
                              _e.options.strategy === "fixed",
                            ),
                            popper: tt(bt),
                          }),
                            (_e.reset = !1),
                            (_e.placement = _e.options.placement),
                            _e.orderedModifiers.forEach(function (gt) {
                              return (_e.modifiersData[gt.name] = Object.assign(
                                {},
                                gt.data,
                              ));
                            });
                          for (
                            var pt = 0;
                            pt < _e.orderedModifiers.length;
                            pt++
                          )
                            if (_e.reset !== !0) {
                              var xt = _e.orderedModifiers[pt],
                                Ne = xt.fn,
                                Pe = xt.options,
                                At = Pe === void 0 ? {} : Pe,
                                et = xt.name;
                              typeof Ne == "function" &&
                                (_e =
                                  Ne({
                                    state: _e,
                                    options: At,
                                    name: et,
                                    instance: $e,
                                  }) || _e);
                            } else (_e.reset = !1), (pt = -1);
                        }
                      }
                    },
                    update:
                      ((J = function () {
                        return new Promise(function (Fe) {
                          $e.forceUpdate(), Fe(_e);
                        });
                      }),
                      function () {
                        return (
                          ve ||
                            (ve = new Promise(function (Fe) {
                              Promise.resolve().then(function () {
                                (ve = void 0), Fe(J());
                              });
                            })),
                          ve
                        );
                      }),
                    destroy: function () {
                      je(), (Ue = !0);
                    },
                  };
                if (!So(q, $)) return $e;
                function je() {
                  Ve.forEach(function (Fe) {
                    return Fe();
                  }),
                    (Ve = []);
                }
                return (
                  $e.setOptions(Y).then(function (Fe) {
                    !Ue && Y.onFirstUpdate && Y.onFirstUpdate(Fe);
                  }),
                  $e
                );
              };
            }
            var wo = ds(),
              hs = ds({
                defaultModifiers: [mt, mn, Be, ae, Xt, De, $n, Re, Vt],
              }),
              Mo = ds({ defaultModifiers: [mt, mn, Be, ae] });
          },
          190: (o, a) => {
            Object.defineProperty(a, "__esModule", { value: !0 }),
              (a.COMBO_BOX_ACCESSIBILITY_KEY_SET =
                a.SELECT_ACCESSIBILITY_KEY_SET =
                a.TABS_ACCESSIBILITY_KEY_SET =
                a.OVERLAY_ACCESSIBILITY_KEY_SET =
                a.DROPDOWN_ACCESSIBILITY_KEY_SET =
                a.POSITIONS =
                  void 0),
              (a.POSITIONS = {
                auto: "auto",
                "auto-start": "auto-start",
                "auto-end": "auto-end",
                top: "top",
                "top-left": "top-start",
                "top-right": "top-end",
                bottom: "bottom",
                "bottom-left": "bottom-start",
                "bottom-right": "bottom-end",
                right: "right",
                "right-start": "right-start",
                "right-end": "right-end",
                left: "left",
                "left-start": "left-start",
                "left-end": "left-end",
              }),
              (a.DROPDOWN_ACCESSIBILITY_KEY_SET = [
                "Escape",
                "ArrowUp",
                "ArrowDown",
                "Home",
                "End",
                "Enter",
              ]),
              (a.OVERLAY_ACCESSIBILITY_KEY_SET = ["Escape", "Tab"]),
              (a.TABS_ACCESSIBILITY_KEY_SET = [
                "ArrowUp",
                "ArrowLeft",
                "ArrowDown",
                "ArrowRight",
                "Home",
                "End",
              ]),
              (a.SELECT_ACCESSIBILITY_KEY_SET = [
                "ArrowUp",
                "ArrowLeft",
                "ArrowDown",
                "ArrowRight",
                "Home",
                "End",
                "Escape",
                "Enter",
                "Tab",
              ]),
              (a.COMBO_BOX_ACCESSIBILITY_KEY_SET = [
                "ArrowUp",
                "ArrowLeft",
                "ArrowDown",
                "ArrowRight",
                "Home",
                "End",
                "Escape",
                "Enter",
              ]);
          },
          460: function (o, a, u) {
            /*
             * HSAccordion
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                });
            Object.defineProperty(a, "__esModule", { value: !0 });
            var v = u(969),
              y = (function (S) {
                function x(_, f, d) {
                  var m = S.call(this, _, f, d) || this;
                  return (
                    (m.toggle =
                      m.el.querySelector(".hs-accordion-toggle") || null),
                    (m.content =
                      m.el.querySelector(".hs-accordion-content") || null),
                    (m.group = m.el.closest(".hs-accordion-group") || null),
                    (m.isAlwaysOpened =
                      m.group.hasAttribute("data-hs-accordion-always-open") ||
                      !1),
                    m.toggle && m.content && m.init(),
                    m
                  );
                }
                return (
                  p(x, S),
                  (x.prototype.init = function () {
                    var _ = this;
                    this.createCollection(window.$hsAccordionCollection, this),
                      this.toggle.addEventListener("click", function () {
                        _.el.classList.contains("active") ? _.hide() : _.show();
                      });
                  }),
                  (x.prototype.show = function () {
                    var _ = this;
                    if (
                      (this.group &&
                        !this.isAlwaysOpened &&
                        this.group.querySelector(".hs-accordion.active") &&
                        this.group.querySelector(".hs-accordion.active") !==
                          this.el &&
                        window.$hsAccordionCollection
                          .find(function (f) {
                            return (
                              f.element.el ===
                              _.group.querySelector(".hs-accordion.active")
                            );
                          })
                          .element.hide(),
                      this.el.classList.contains("active"))
                    )
                      return !1;
                    this.el.classList.add("active"),
                      (this.content.style.display = "block"),
                      (this.content.style.height = "0"),
                      setTimeout(function () {
                        _.content.style.height = "".concat(
                          _.content.scrollHeight,
                          "px",
                        );
                      }),
                      (0, v.afterTransition)(this.content, function () {
                        (_.content.style.display = "block"),
                          (_.content.style.height = ""),
                          _.fireEvent("open", _.el),
                          (0, v.dispatch)("open.hs.accordion", _.el, _.el);
                      });
                  }),
                  (x.prototype.hide = function () {
                    var _ = this;
                    if (!this.el.classList.contains("active")) return !1;
                    this.el.classList.remove("active"),
                      (this.content.style.height = "".concat(
                        this.content.scrollHeight,
                        "px",
                      )),
                      setTimeout(function () {
                        _.content.style.height = "0";
                      }),
                      (0, v.afterTransition)(this.content, function () {
                        (_.content.style.display = ""),
                          (_.content.style.height = "0"),
                          _.fireEvent("close", _.el),
                          (0, v.dispatch)("close.hs.accordion", _.el, _.el);
                      });
                  }),
                  (x.getInstance = function (_, f) {
                    var d = window.$hsAccordionCollection.find(function (m) {
                      return (
                        m.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    return d ? (f ? d : d.element.el) : null;
                  }),
                  (x.show = function (_) {
                    var f = window.$hsAccordionCollection.find(function (d) {
                      return (
                        d.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    f &&
                      f.element.content.style.display !== "block" &&
                      f.element.show();
                  }),
                  (x.hide = function (_) {
                    var f = window.$hsAccordionCollection.find(function (d) {
                      return (
                        d.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    f &&
                      f.element.content.style.display === "block" &&
                      f.element.hide();
                  }),
                  (x.autoInit = function () {
                    window.$hsAccordionCollection ||
                      (window.$hsAccordionCollection = []),
                      document
                        .querySelectorAll(
                          ".hs-accordion:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (_) {
                          window.$hsAccordionCollection.find(function (f) {
                            var d;
                            return (
                              ((d = f == null ? void 0 : f.element) === null ||
                              d === void 0
                                ? void 0
                                : d.el) === _
                            );
                          }) || new x(_);
                        });
                  }),
                  (x.on = function (_, f, d) {
                    var m = window.$hsAccordionCollection.find(function (g) {
                      return (
                        g.element.el ===
                        (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    m && (m.element.events[_] = d);
                  }),
                  x
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              typeof window < "u" && (window.HSAccordion = y),
              (a.default = y);
          },
          737: (o, a) => {
            /*
             * HSBasePlugin
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ Object.defineProperty(a, "__esModule", { value: !0 });
            var u = (function () {
              function h(p, v, y) {
                (this.el = p),
                  (this.options = v),
                  (this.events = y),
                  (this.el = p),
                  (this.options = v),
                  (this.events = {});
              }
              return (
                (h.prototype.createCollection = function (p, v) {
                  var y;
                  p.push({
                    id:
                      ((y = v == null ? void 0 : v.el) === null || y === void 0
                        ? void 0
                        : y.id) || p.length + 1,
                    element: v,
                  });
                }),
                (h.prototype.fireEvent = function (p, v) {
                  if (
                    (v === void 0 && (v = null), this.events.hasOwnProperty(p))
                  )
                    return this.events[p](v);
                }),
                (h.prototype.on = function (p, v) {
                  this.events[p] = v;
                }),
                h
              );
            })();
            a.default = u;
          },
          629: function (o, a, u) {
            /*
             * HSCarousel
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (S) {
                        for (var x, _ = 1, f = arguments.length; _ < f; _++)
                          for (var d in (x = arguments[_]))
                            Object.prototype.hasOwnProperty.call(x, d) &&
                              (S[d] = x[d]);
                        return S;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = (function (S) {
              function x(_, f) {
                var d,
                  m,
                  g,
                  w = S.call(this, _, f) || this,
                  T = _.getAttribute("data-hs-carousel"),
                  C = T ? JSON.parse(T) : {},
                  A = v(v({}, C), f);
                return (
                  (w.currentIndex = A.currentIndex || 0),
                  (w.loadingClasses = A.loadingClasses
                    ? "".concat(A.loadingClasses).split(",")
                    : null),
                  (w.loadingClassesRemove =
                    !((d = w.loadingClasses) === null || d === void 0) && d[0]
                      ? w.loadingClasses[0].split(" ")
                      : "opacity-0"),
                  (w.loadingClassesAdd =
                    !((m = w.loadingClasses) === null || m === void 0) && m[1]
                      ? w.loadingClasses[1].split(" ")
                      : ""),
                  (w.afterLoadingClassesAdd =
                    !((g = w.loadingClasses) === null || g === void 0) && g[2]
                      ? w.loadingClasses[2].split(" ")
                      : ""),
                  (w.isAutoPlay = A.isAutoPlay !== void 0 && A.isAutoPlay),
                  (w.speed = A.speed || 4e3),
                  (w.isInfiniteLoop =
                    A.isInfiniteLoop === void 0 || A.isInfiniteLoop),
                  (w.inner = w.el.querySelector(".hs-carousel-body") || null),
                  (w.slides =
                    w.el.querySelectorAll(".hs-carousel-slide") || []),
                  (w.prev = w.el.querySelector(".hs-carousel-prev") || null),
                  (w.next = w.el.querySelector(".hs-carousel-next") || null),
                  (w.dots =
                    w.el.querySelectorAll(".hs-carousel-pagination > *") ||
                    null),
                  (w.sliderWidth = w.inner.parentElement.clientWidth),
                  (w.touchX = { start: 0, end: 0 }),
                  w.init(),
                  w
                );
              }
              return (
                p(x, S),
                (x.prototype.init = function () {
                  var _,
                    f,
                    d = this;
                  this.createCollection(window.$hsCarouselCollection, this),
                    this.inner &&
                      (this.calculateWidth(),
                      this.loadingClassesRemove &&
                        (typeof this.loadingClassesRemove == "string"
                          ? this.inner.classList.remove(
                              this.loadingClassesRemove,
                            )
                          : (_ = this.inner.classList).remove.apply(
                              _,
                              this.loadingClassesRemove,
                            )),
                      this.loadingClassesAdd &&
                        (typeof this.loadingClassesAdd == "string"
                          ? this.inner.classList.add(this.loadingClassesAdd)
                          : (f = this.inner.classList).add.apply(
                              f,
                              this.loadingClassesAdd,
                            ))),
                    this.prev &&
                      this.prev.addEventListener("click", function () {
                        d.goToPrev(),
                          d.isAutoPlay && (d.resetTimer(), d.setTimer());
                      }),
                    this.next &&
                      this.next.addEventListener("click", function () {
                        d.goToNext(),
                          d.isAutoPlay && (d.resetTimer(), d.setTimer());
                      }),
                    this.dots &&
                      this.dots.forEach(function (m, g) {
                        return m.addEventListener("click", function () {
                          d.goTo(g),
                            d.isAutoPlay && (d.resetTimer(), d.setTimer());
                        });
                      }),
                    this.slides.length &&
                      (this.addCurrentClass(),
                      this.isInfiniteLoop || this.addDisabledClass(),
                      this.isAutoPlay && this.autoPlay()),
                    this.inner &&
                      this.afterLoadingClassesAdd &&
                      setTimeout(function () {
                        var m;
                        typeof d.afterLoadingClassesAdd == "string"
                          ? d.inner.classList.add(d.afterLoadingClassesAdd)
                          : (m = d.inner.classList).add.apply(
                              m,
                              d.afterLoadingClassesAdd,
                            );
                      }),
                    this.el.classList.add("init"),
                    this.el.addEventListener("touchstart", function (m) {
                      d.touchX.start = m.changedTouches[0].screenX;
                    }),
                    this.el.addEventListener("touchend", function (m) {
                      (d.touchX.end = m.changedTouches[0].screenX),
                        d.detectDirection();
                    }),
                    this.observeResize();
                }),
                (x.prototype.observeResize = function () {
                  var _ = this;
                  new ResizeObserver(function () {
                    return _.recalculateWidth();
                  }).observe(document.querySelector("body"));
                }),
                (x.prototype.calculateWidth = function () {
                  var _ = this;
                  (this.inner.style.width = "".concat(
                    this.sliderWidth * this.slides.length,
                    "px",
                  )),
                    (this.inner.style.transform = "translate(-".concat(
                      this.currentIndex * this.sliderWidth,
                      "px, 0px)",
                    )),
                    this.slides.forEach(function (f) {
                      f.style.width = "".concat(_.sliderWidth, "px");
                    });
                }),
                (x.prototype.addCurrentClass = function () {
                  var _ = this;
                  this.slides.forEach(function (f, d) {
                    d === _.currentIndex
                      ? f.classList.add("active")
                      : f.classList.remove("active");
                  }),
                    this.dots &&
                      this.dots.forEach(function (f, d) {
                        d === _.currentIndex
                          ? f.classList.add("active")
                          : f.classList.remove("active");
                      });
                }),
                (x.prototype.addDisabledClass = function () {
                  if (!this.prev || !this.next) return !1;
                  this.currentIndex === 0
                    ? (this.next.classList.remove("disabled"),
                      this.prev.classList.add("disabled"))
                    : this.currentIndex === this.slides.length - 1
                      ? (this.prev.classList.remove("disabled"),
                        this.next.classList.add("disabled"))
                      : (this.prev.classList.remove("disabled"),
                        this.next.classList.remove("disabled"));
                }),
                (x.prototype.autoPlay = function () {
                  this.setTimer();
                }),
                (x.prototype.setTimer = function () {
                  var _ = this;
                  this.timer = setInterval(function () {
                    _.currentIndex === _.slides.length - 1
                      ? _.goTo(0)
                      : _.goToNext();
                  }, this.speed);
                }),
                (x.prototype.resetTimer = function () {
                  clearInterval(this.timer);
                }),
                (x.prototype.detectDirection = function () {
                  var _ = this.touchX,
                    f = _.start,
                    d = _.end;
                  d < f && this.goToNext(), d > f && this.goToPrev();
                }),
                (x.prototype.recalculateWidth = function () {
                  (this.sliderWidth = this.inner.parentElement.clientWidth),
                    this.calculateWidth();
                }),
                (x.prototype.goToPrev = function () {
                  this.currentIndex === 0 && this.isInfiniteLoop
                    ? ((this.currentIndex = this.slides.length - 1),
                      (this.inner.style.transform = "translate(-".concat(
                        this.currentIndex * this.sliderWidth,
                        "px, 0px)",
                      )),
                      this.addCurrentClass())
                    : this.currentIndex !== 0 &&
                      ((this.currentIndex -= 1),
                      (this.inner.style.transform = "translate(-".concat(
                        this.currentIndex * this.sliderWidth,
                        "px, 0px)",
                      )),
                      this.addCurrentClass(),
                      this.addDisabledClass());
                }),
                (x.prototype.goToNext = function () {
                  this.currentIndex === this.slides.length - 1 &&
                  this.isInfiniteLoop
                    ? ((this.currentIndex = 0),
                      (this.inner.style.transform = "translate(-".concat(
                        this.currentIndex * this.sliderWidth,
                        "px, 0px)",
                      )),
                      this.addCurrentClass())
                    : this.currentIndex < this.slides.length - 1 &&
                      ((this.currentIndex += 1),
                      (this.inner.style.transform = "translate(-".concat(
                        this.currentIndex * this.sliderWidth,
                        "px, 0px)",
                      )),
                      this.addCurrentClass(),
                      this.addDisabledClass());
                }),
                (x.prototype.goTo = function (_) {
                  (this.currentIndex = _),
                    (this.inner.style.transform = "translate(-".concat(
                      this.currentIndex * this.sliderWidth,
                      "px, 0px)",
                    )),
                    this.addCurrentClass(),
                    this.isInfiniteLoop || this.addDisabledClass();
                }),
                (x.getInstance = function (_, f) {
                  var d = window.$hsCarouselCollection.find(function (m) {
                    return (
                      m.element.el ===
                      (typeof _ == "string" ? document.querySelector(_) : _)
                    );
                  });
                  return d ? (f ? d : d.element) : null;
                }),
                (x.autoInit = function () {
                  window.$hsCarouselCollection ||
                    (window.$hsCarouselCollection = []),
                    document
                      .querySelectorAll(
                        "[data-hs-carousel]:not(.--prevent-on-load-init)",
                      )
                      .forEach(function (_) {
                        window.$hsCarouselCollection.find(function (f) {
                          var d;
                          return (
                            ((d = f == null ? void 0 : f.element) === null ||
                            d === void 0
                              ? void 0
                              : d.el) === _
                          );
                        }) || new x(_);
                      });
                }),
                x
              );
            })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              window.addEventListener("resize", function () {
                if (!window.$hsCarouselCollection) return !1;
                window.$hsCarouselCollection.forEach(function (S) {
                  S.element.recalculateWidth();
                });
              }),
              typeof window < "u" && (window.HSCarousel = y),
              (a.default = y);
          },
          652: function (o, a, u) {
            /*
             * HSCollapse
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                });
            Object.defineProperty(a, "__esModule", { value: !0 });
            var v = u(969),
              y = (function (S) {
                function x(_, f, d) {
                  var m = S.call(this, _, f, d) || this;
                  return (
                    (m.contentId = m.el.dataset.hsCollapse),
                    (m.content = document.querySelector(m.contentId)),
                    (m.animationInProcess = !1),
                    m.content && m.init(),
                    m
                  );
                }
                return (
                  p(x, S),
                  (x.prototype.init = function () {
                    var _ = this;
                    this.createCollection(window.$hsCollapseCollection, this),
                      this.el.addEventListener("click", function () {
                        _.content.classList.contains("open")
                          ? _.hide()
                          : _.show();
                      });
                  }),
                  (x.prototype.hideAllMegaMenuItems = function () {
                    this.content
                      .querySelectorAll(".hs-mega-menu-content.block")
                      .forEach(function (_) {
                        _.classList.remove("block"), _.classList.add("hidden");
                      });
                  }),
                  (x.prototype.show = function () {
                    var _ = this;
                    if (
                      this.animationInProcess ||
                      this.el.classList.contains("open")
                    )
                      return !1;
                    (this.animationInProcess = !0),
                      this.el.classList.add("open"),
                      this.content.classList.add("open"),
                      this.content.classList.remove("hidden"),
                      (this.content.style.height = "0"),
                      setTimeout(function () {
                        _.content.style.height = "".concat(
                          _.content.scrollHeight,
                          "px",
                        );
                      }),
                      (0, v.afterTransition)(this.content, function () {
                        (_.content.style.height = ""),
                          _.fireEvent("open", _.el),
                          (0, v.dispatch)("open.hs.collapse", _.el, _.el),
                          (_.animationInProcess = !1);
                      });
                  }),
                  (x.prototype.hide = function () {
                    var _ = this;
                    if (
                      this.animationInProcess ||
                      !this.el.classList.contains("open")
                    )
                      return !1;
                    (this.animationInProcess = !0),
                      this.el.classList.remove("open"),
                      (this.content.style.height = "".concat(
                        this.content.scrollHeight,
                        "px",
                      )),
                      setTimeout(function () {
                        _.content.style.height = "0";
                      }),
                      this.content.classList.remove("open"),
                      (0, v.afterTransition)(this.content, function () {
                        _.content.classList.add("hidden"),
                          (_.content.style.height = ""),
                          _.fireEvent("hide", _.el),
                          (0, v.dispatch)("hide.hs.collapse", _.el, _.el),
                          (_.animationInProcess = !1);
                      }),
                      this.content.querySelectorAll(
                        ".hs-mega-menu-content.block",
                      ).length && this.hideAllMegaMenuItems();
                  }),
                  (x.getInstance = function (_, f) {
                    f === void 0 && (f = !1);
                    var d = window.$hsCollapseCollection.find(function (m) {
                      return (
                        m.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    return d ? (f ? d : d.element.el) : null;
                  }),
                  (x.autoInit = function () {
                    window.$hsCollapseCollection ||
                      (window.$hsCollapseCollection = []),
                      document
                        .querySelectorAll(
                          ".hs-collapse-toggle:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (_) {
                          window.$hsCollapseCollection.find(function (f) {
                            var d;
                            return (
                              ((d = f == null ? void 0 : f.element) === null ||
                              d === void 0
                                ? void 0
                                : d.el) === _
                            );
                          }) || new x(_);
                        });
                  }),
                  (x.show = function (_) {
                    var f = window.$hsCollapseCollection.find(function (d) {
                      return (
                        d.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    f &&
                      f.element.content.classList.contains("hidden") &&
                      f.element.show();
                  }),
                  (x.hide = function (_) {
                    var f = window.$hsCollapseCollection.find(function (d) {
                      return (
                        d.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    f &&
                      !f.element.content.classList.contains("hidden") &&
                      f.element.hide();
                  }),
                  (x.on = function (_, f, d) {
                    var m = window.$hsCollapseCollection.find(function (g) {
                      return (
                        g.element.el ===
                        (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    m && (m.element.events[_] = d);
                  }),
                  x
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              typeof window < "u" && (window.HSCollapse = y),
              (a.default = y);
          },
          413: function (o, a, u) {
            /*
             * HSCopyMarkup
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this,
                    g = f.getAttribute("data-hs-copy-markup"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d);
                  return (
                    (m.targetSelector =
                      (T == null ? void 0 : T.targetSelector) || null),
                    (m.wrapperSelector =
                      (T == null ? void 0 : T.wrapperSelector) || null),
                    (m.limit = (T == null ? void 0 : T.limit) || null),
                    (m.items = []),
                    m.targetSelector && m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    var f = this;
                    this.createCollection(window.$hsCopyMarkupCollection, this),
                      this.setTarget(),
                      this.setWrapper(),
                      this.addPredefinedItems(),
                      this.el.addEventListener("click", function () {
                        return f.copy();
                      });
                  }),
                  (_.prototype.copy = function () {
                    if (this.limit && this.items.length >= this.limit)
                      return !1;
                    this.el.hasAttribute("disabled") &&
                      this.el.setAttribute("disabled", "");
                    var f = this.target.cloneNode(!0);
                    this.addToItems(f),
                      this.limit &&
                        this.items.length >= this.limit &&
                        this.el.setAttribute("disabled", "disabled"),
                      this.fireEvent("copy", f),
                      (0, y.dispatch)("copy.hs.copyMarkup", f, f);
                  }),
                  (_.prototype.addPredefinedItems = function () {
                    var f = this;
                    Array.from(this.wrapper.children)
                      .filter(function (d) {
                        return !d.classList.contains("[--ignore-for-count]");
                      })
                      .forEach(function (d) {
                        f.addToItems(d);
                      });
                  }),
                  (_.prototype.setTarget = function () {
                    var f =
                      typeof this.targetSelector == "string"
                        ? document
                            .querySelector(this.targetSelector)
                            .cloneNode(!0)
                        : this.targetSelector.cloneNode(!0);
                    f.removeAttribute("id"), (this.target = f);
                  }),
                  (_.prototype.setWrapper = function () {
                    this.wrapper =
                      typeof this.wrapperSelector == "string"
                        ? document.querySelector(this.wrapperSelector)
                        : this.wrapperSelector;
                  }),
                  (_.prototype.addToItems = function (f) {
                    var d = this,
                      m = f.querySelector("[data-hs-copy-markup-delete-item]");
                    this.wrapper ? this.wrapper.append(f) : this.el.before(f),
                      m &&
                        m.addEventListener("click", function () {
                          return d.delete(f);
                        }),
                      this.items.push(f);
                  }),
                  (_.prototype.delete = function (f) {
                    var d = this.items.indexOf(f);
                    d !== -1 && this.items.splice(d, 1),
                      f.remove(),
                      this.fireEvent("delete", f),
                      (0, y.dispatch)("delete.hs.copyMarkup", f, f);
                  }),
                  (_.getInstance = function (f, d) {
                    var m = window.$hsCopyMarkupCollection.find(function (g) {
                      return (
                        g.element.el ===
                        (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    return m ? (d ? m : m.element) : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsCopyMarkupCollection ||
                      (window.$hsCopyMarkupCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-copy-markup]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          if (
                            !window.$hsCopyMarkupCollection.find(function (g) {
                              var w;
                              return (
                                ((w = g == null ? void 0 : g.element) ===
                                  null || w === void 0
                                  ? void 0
                                  : w.el) === f
                              );
                            })
                          ) {
                            var d = f.getAttribute("data-hs-copy-markup"),
                              m = d ? JSON.parse(d) : {};
                            new _(f, m);
                          }
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSCopyMarkup = S),
              (a.default = S);
          },
          610: function (o, a, u) {
            /*
             * HSDropdown
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (d, m) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (g, w) {
                          g.__proto__ = w;
                        }) ||
                      function (g, w) {
                        for (var T in w)
                          Object.prototype.hasOwnProperty.call(w, T) &&
                            (g[T] = w[T]);
                      }),
                    h(d, m)
                  );
                }),
                function (d, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(m) +
                        " is not a constructor or null",
                    );
                  function g() {
                    this.constructor = d;
                  }
                  h(d, m),
                    (d.prototype =
                      m === null
                        ? Object.create(m)
                        : ((g.prototype = m.prototype), new g()));
                }),
              v =
                (this && this.__spreadArray) ||
                function (d, m, g) {
                  if (g || arguments.length === 2)
                    for (var w, T = 0, C = m.length; T < C; T++)
                      (!w && T in m) ||
                        (w || (w = Array.prototype.slice.call(m, 0, T)),
                        (w[T] = m[T]));
                  return d.concat(w || Array.prototype.slice.call(m));
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = u(492),
              x = u(737),
              _ = u(190),
              f = (function (d) {
                function m(g, w, T) {
                  var C = d.call(this, g, w, T) || this;
                  return (
                    (C.toggle =
                      C.el.querySelector(":scope > .hs-dropdown-toggle") ||
                      C.el.children[0]),
                    (C.menu = C.el.querySelector(":scope > .hs-dropdown-menu")),
                    (C.eventMode = (0, y.getClassProperty)(
                      C.el,
                      "--trigger",
                      "click",
                    )),
                    (C.closeMode = (0, y.getClassProperty)(
                      C.el,
                      "--auto-close",
                      "true",
                    )),
                    (C.animationInProcess = !1),
                    C.toggle && C.menu && C.init(),
                    C
                  );
                }
                return (
                  p(m, d),
                  (m.prototype.init = function () {
                    var g = this;
                    if (
                      (this.createCollection(
                        window.$hsDropdownCollection,
                        this,
                      ),
                      this.toggle.disabled)
                    )
                      return !1;
                    this.toggle.addEventListener("click", function () {
                      return g.onClickHandler();
                    }),
                      (0, y.isIOS)() ||
                        (0, y.isIpadOS)() ||
                        (this.el.addEventListener("mouseenter", function () {
                          return g.onMouseEnterHandler();
                        }),
                        this.el.addEventListener("mouseleave", function () {
                          return g.onMouseLeaveHandler();
                        }));
                  }),
                  (m.prototype.resizeHandler = function () {
                    this.eventMode = (0, y.getClassProperty)(
                      this.el,
                      "--trigger",
                      "click",
                    );
                  }),
                  (m.prototype.onClickHandler = function () {
                    this.el.classList.contains("open") &&
                    !this.menu.classList.contains("hidden")
                      ? this.close()
                      : this.open();
                  }),
                  (m.prototype.onMouseEnterHandler = function () {
                    if (this.eventMode !== "hover") return !1;
                    this.el._popper && this.forceClearState(),
                      !this.el.classList.contains("open") &&
                        this.menu.classList.contains("hidden") &&
                        this.open();
                  }),
                  (m.prototype.onMouseLeaveHandler = function () {
                    if (this.eventMode !== "hover") return !1;
                    this.el.classList.contains("open") &&
                      !this.menu.classList.contains("hidden") &&
                      this.close();
                  }),
                  (m.prototype.destroyPopper = function () {
                    this.menu.classList.remove("block"),
                      this.menu.classList.add("hidden"),
                      (this.menu.style.inset = null),
                      (this.menu.style.position = null),
                      this.el && this.el._popper && this.el._popper.destroy(),
                      (this.animationInProcess = !1);
                  }),
                  (m.prototype.absoluteStrategyModifiers = function () {
                    var g = this;
                    return [
                      {
                        name: "applyStyles",
                        fn: function (w) {
                          var T = (
                              window
                                .getComputedStyle(g.el)
                                .getPropertyValue("--strategy") || "absolute"
                            ).replace(" ", ""),
                            C = (
                              window
                                .getComputedStyle(g.el)
                                .getPropertyValue("--adaptive") || "adaptive"
                            ).replace(" ", "");
                          (w.state.elements.popper.style.position = T),
                            (w.state.elements.popper.style.transform =
                              C === "adaptive"
                                ? w.state.styles.popper.transform
                                : null),
                            (w.state.elements.popper.style.top = null),
                            (w.state.elements.popper.style.bottom = null),
                            (w.state.elements.popper.style.left = null),
                            (w.state.elements.popper.style.right = null),
                            (w.state.elements.popper.style.margin = 0);
                        },
                      },
                      { name: "computeStyles", options: { adaptive: !1 } },
                    ];
                  }),
                  (m.prototype.open = function () {
                    var g = this;
                    if (
                      this.el.classList.contains("open") ||
                      this.animationInProcess
                    )
                      return !1;
                    this.animationInProcess = !0;
                    var w = (
                        window
                          .getComputedStyle(this.el)
                          .getPropertyValue("--placement") || ""
                      ).replace(" ", ""),
                      T = (
                        window
                          .getComputedStyle(this.el)
                          .getPropertyValue("--flip") || "true"
                      ).replace(" ", ""),
                      C = (
                        window
                          .getComputedStyle(this.el)
                          .getPropertyValue("--strategy") || "fixed"
                      ).replace(" ", ""),
                      A = parseInt(
                        (
                          window
                            .getComputedStyle(this.el)
                            .getPropertyValue("--offset") || "10"
                        ).replace(" ", ""),
                      );
                    C !== "static" &&
                      (this.el._popper = (0, S.createPopper)(
                        this.el,
                        this.menu,
                        {
                          placement: _.POSITIONS[w] || "bottom-start",
                          strategy: C,
                          modifiers: v(
                            v(
                              [],
                              C !== "fixed"
                                ? this.absoluteStrategyModifiers()
                                : [],
                              !0,
                            ),
                            [
                              { name: "flip", enabled: T === "true" },
                              { name: "offset", options: { offset: [0, A] } },
                            ],
                            !1,
                          ),
                        },
                      )),
                      (this.menu.style.margin = null),
                      this.menu.classList.remove("hidden"),
                      this.menu.classList.add("block"),
                      setTimeout(function () {
                        g.el.classList.add("open"), (g.animationInProcess = !1);
                      }),
                      this.fireEvent("open", this.el),
                      (0, y.dispatch)("open.hs.dropdown", this.el, this.el);
                  }),
                  (m.prototype.close = function (g) {
                    var w = this;
                    if (
                      (g === void 0 && (g = !0),
                      this.animationInProcess ||
                        !this.el.classList.contains("open"))
                    )
                      return !1;
                    if (((this.animationInProcess = !0), g)) {
                      var T =
                        this.el.querySelector(
                          "[data-hs-dropdown-transition]",
                        ) || this.menu;
                      (0, y.afterTransition)(T, function () {
                        return w.destroyPopper();
                      });
                    } else this.destroyPopper();
                    (this.menu.style.margin = null),
                      this.el.classList.remove("open"),
                      this.fireEvent("close", this.el),
                      (0, y.dispatch)("close.hs.dropdown", this.el, this.el);
                  }),
                  (m.prototype.forceClearState = function () {
                    this.destroyPopper(),
                      (this.menu.style.margin = null),
                      this.el.classList.remove("open");
                  }),
                  (m.getInstance = function (g, w) {
                    var T = window.$hsDropdownCollection.find(function (C) {
                      return (
                        C.element.el ===
                        (typeof g == "string" ? document.querySelector(g) : g)
                      );
                    });
                    return T ? (w ? T : T.element.el) : null;
                  }),
                  (m.autoInit = function () {
                    if (
                      (window.$hsDropdownCollection ||
                        (window.$hsDropdownCollection = []),
                      document
                        .querySelectorAll(
                          ".hs-dropdown:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (w) {
                          window.$hsDropdownCollection.find(function (T) {
                            var C;
                            return (
                              ((C = T == null ? void 0 : T.element) === null ||
                              C === void 0
                                ? void 0
                                : C.el) === w
                            );
                          }) || new m(w);
                        }),
                      window.$hsDropdownCollection)
                    ) {
                      document.addEventListener("keydown", function (w) {
                        return m.accessibility(w);
                      }),
                        window.addEventListener("click", function (w) {
                          var T = w.target;
                          m.closeCurrentlyOpened(T);
                        });
                      var g = window.innerWidth;
                      window.addEventListener("resize", function () {
                        window.innerWidth !== g &&
                          ((g = innerWidth), m.closeCurrentlyOpened(null, !1));
                      });
                    }
                  }),
                  (m.open = function (g) {
                    var w = window.$hsDropdownCollection.find(function (T) {
                      return (
                        T.element.el ===
                        (typeof g == "string" ? document.querySelector(g) : g)
                      );
                    });
                    w &&
                      w.element.menu.classList.contains("hidden") &&
                      w.element.open();
                  }),
                  (m.close = function (g) {
                    var w = window.$hsDropdownCollection.find(function (T) {
                      return (
                        T.element.el ===
                        (typeof g == "string" ? document.querySelector(g) : g)
                      );
                    });
                    w &&
                      !w.element.menu.classList.contains("hidden") &&
                      w.element.close();
                  }),
                  (m.accessibility = function (g) {
                    this.history = y.menuSearchHistory;
                    var w = window.$hsDropdownCollection.find(function (T) {
                      return T.element.el.classList.contains("open");
                    });
                    if (
                      w &&
                      (_.DROPDOWN_ACCESSIBILITY_KEY_SET.includes(g.code) ||
                        (g.code.length === 4 &&
                          g.code[g.code.length - 1].match(/^[A-Z]*$/))) &&
                      !g.metaKey &&
                      !w.element.menu.querySelector("input:focus")
                    )
                      switch ((console.log("Key code:", g.code), g.code)) {
                        case "Escape":
                          w.element.menu.querySelector(".hs-select.active") ||
                            (g.preventDefault(), this.onEscape(g));
                          break;
                        case "Enter":
                          w.element.menu.querySelector(
                            ".hs-select button:focus",
                          ) ||
                            w.element.menu.querySelector(
                              ".hs-collapse-toggle:focus",
                            ) ||
                            this.onEnter(g);
                          break;
                        case "ArrowUp":
                          g.preventDefault(), this.onArrow();
                          break;
                        case "ArrowDown":
                          g.preventDefault(), this.onArrow(!1);
                          break;
                        case "Home":
                          g.preventDefault(), this.onStartEnd();
                          break;
                        case "End":
                          g.preventDefault(), this.onStartEnd(!1);
                          break;
                        default:
                          g.preventDefault(), this.onFirstLetter(g.key);
                      }
                  }),
                  (m.onEscape = function (g) {
                    var w = g.target.closest(".hs-dropdown.open");
                    if (
                      window.$hsDropdownCollection.find(function (C) {
                        return C.element.el === w;
                      })
                    ) {
                      var T = window.$hsDropdownCollection.find(function (C) {
                        return C.element.el === w;
                      });
                      T && (T.element.close(), T.element.toggle.focus());
                    } else this.closeCurrentlyOpened();
                  }),
                  (m.onEnter = function (g) {
                    var w = g.target.parentElement;
                    if (
                      window.$hsDropdownCollection.find(function (C) {
                        return C.element.el === w;
                      })
                    ) {
                      g.preventDefault();
                      var T = window.$hsDropdownCollection.find(function (C) {
                        return C.element.el === w;
                      });
                      T && T.element.open();
                    }
                  }),
                  (m.onArrow = function (g) {
                    g === void 0 && (g = !0);
                    var w = window.$hsDropdownCollection.find(function (N) {
                      return N.element.el.classList.contains("open");
                    });
                    if (w) {
                      var T = w.element.menu;
                      if (!T) return !1;
                      var C = (
                          g
                            ? Array.from(
                                T.querySelectorAll(
                                  "a:not([hidden]), .hs-dropdown > button:not([hidden])",
                                ),
                              ).reverse()
                            : Array.from(
                                T.querySelectorAll(
                                  "a:not([hidden]), .hs-dropdown > button:not([hidden])",
                                ),
                              )
                        ).filter(function (N) {
                          return !N.classList.contains("disabled");
                        }),
                        A = T.querySelector("a:focus, button:focus"),
                        L = C.findIndex(function (N) {
                          return N === A;
                        });
                      L + 1 < C.length && L++, C[L].focus();
                    }
                  }),
                  (m.onStartEnd = function (g) {
                    g === void 0 && (g = !0);
                    var w = window.$hsDropdownCollection.find(function (A) {
                      return A.element.el.classList.contains("open");
                    });
                    if (w) {
                      var T = w.element.menu;
                      if (!T) return !1;
                      var C = (
                        g
                          ? Array.from(T.querySelectorAll("a"))
                          : Array.from(T.querySelectorAll("a")).reverse()
                      ).filter(function (A) {
                        return !A.classList.contains("disabled");
                      });
                      C.length && C[0].focus();
                    }
                  }),
                  (m.onFirstLetter = function (g) {
                    var w = this,
                      T = window.$hsDropdownCollection.find(function (P) {
                        return P.element.el.classList.contains("open");
                      });
                    if (T) {
                      var C = T.element.menu;
                      if (!C) return !1;
                      var A = Array.from(C.querySelectorAll("a")),
                        L = function () {
                          return A.findIndex(function (P, I) {
                            return (
                              P.innerText.toLowerCase().charAt(0) ===
                                g.toLowerCase() && w.history.existsInHistory(I)
                            );
                          });
                        },
                        N = L();
                      N === -1 && (this.history.clearHistory(), (N = L())),
                        N !== -1 && (A[N].focus(), this.history.addHistory(N));
                    }
                  }),
                  (m.closeCurrentlyOpened = function (g, w) {
                    g === void 0 && (g = null), w === void 0 && (w = !0);
                    var T =
                        g &&
                        g.closest(".hs-dropdown") &&
                        g
                          .closest(".hs-dropdown")
                          .parentElement.closest(".hs-dropdown")
                          ? g
                              .closest(".hs-dropdown")
                              .parentElement.closest(".hs-dropdown")
                          : null,
                      C = T
                        ? window.$hsDropdownCollection.filter(function (A) {
                            return (
                              A.element.el.classList.contains("open") &&
                              A.element.menu
                                .closest(".hs-dropdown")
                                .parentElement.closest(".hs-dropdown") === T
                            );
                          })
                        : window.$hsDropdownCollection.filter(function (A) {
                            return A.element.el.classList.contains("open");
                          });
                    g &&
                      g.closest(".hs-dropdown") &&
                      (0, y.getClassPropertyAlt)(
                        g.closest(".hs-dropdown"),
                        "--auto-close",
                      ) === "inside" &&
                      (C = C.filter(function (A) {
                        return A.element.el !== g.closest(".hs-dropdown");
                      })),
                      C &&
                        C.forEach(function (A) {
                          if (
                            A.element.closeMode === "false" ||
                            A.element.closeMode === "outside"
                          )
                            return !1;
                          A.element.close(w);
                        });
                  }),
                  (m.on = function (g, w, T) {
                    var C = window.$hsDropdownCollection.find(function (A) {
                      return (
                        A.element.el ===
                        (typeof w == "string" ? document.querySelector(w) : w)
                      );
                    });
                    C && (C.element.events[g] = T);
                  }),
                  m
                );
              })(x.default);
            window.addEventListener("load", function () {
              f.autoInit();
            }),
              window.addEventListener("resize", function () {
                window.$hsDropdownCollection ||
                  (window.$hsDropdownCollection = []),
                  window.$hsDropdownCollection.forEach(function (d) {
                    return d.element.resizeHandler();
                  });
              }),
              typeof window < "u" && (window.HSDropdown = f),
              (a.default = f);
          },
          371: function (o, a, u) {
            /*
             * HSInputNumber
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                });
            Object.defineProperty(a, "__esModule", { value: !0 });
            var v = u(969),
              y = (function (S) {
                function x(_, f) {
                  var d = S.call(this, _, f) || this;
                  return (
                    (d.input =
                      d.el.querySelector("[data-hs-input-number-input]") ||
                      null),
                    (d.increment =
                      d.el.querySelector("[data-hs-input-number-increment]") ||
                      null),
                    (d.decrement =
                      d.el.querySelector("[data-hs-input-number-decrement]") ||
                      null),
                    (d.inputValue = d.input ? parseInt(d.input.value) : 0),
                    d.init(),
                    d
                  );
                }
                return (
                  p(x, S),
                  (x.prototype.init = function () {
                    this.createCollection(
                      window.$hsInputNumberCollection,
                      this,
                    ),
                      this.input && this.increment && this.build();
                  }),
                  (x.prototype.build = function () {
                    this.input && this.buildInput(),
                      this.increment && this.buildIncrement(),
                      this.decrement && this.buildDecrement(),
                      this.inputValue <= 0 &&
                        ((this.inputValue = 0),
                        (this.input.value = "0"),
                        this.changeValue()),
                      this.input.hasAttribute("disabled") &&
                        this.disableButtons();
                  }),
                  (x.prototype.buildInput = function () {
                    var _ = this;
                    this.input.addEventListener("input", function () {
                      return _.changeValue();
                    });
                  }),
                  (x.prototype.buildIncrement = function () {
                    var _ = this;
                    this.increment.addEventListener("click", function () {
                      _.changeValue("increment");
                    });
                  }),
                  (x.prototype.buildDecrement = function () {
                    var _ = this;
                    this.decrement.addEventListener("click", function () {
                      _.changeValue("decrement");
                    });
                  }),
                  (x.prototype.changeValue = function (_) {
                    _ === void 0 && (_ = "none");
                    var f = { inputValue: this.inputValue };
                    switch (_) {
                      case "increment":
                        (this.inputValue += 1),
                          (this.input.value = this.inputValue.toString());
                        break;
                      case "decrement":
                        (this.inputValue -= this.inputValue <= 0 ? 0 : 1),
                          (this.input.value = this.inputValue.toString());
                        break;
                      default:
                        (this.inputValue =
                          parseInt(this.input.value) <= 0
                            ? 0
                            : parseInt(this.input.value)),
                          this.inputValue <= 0 &&
                            (this.input.value = this.inputValue.toString());
                    }
                    (f.inputValue = this.inputValue),
                      this.inputValue === 0
                        ? (this.el.classList.add("disabled"),
                          this.decrement && this.disableButtons("decrement"))
                        : (this.el.classList.remove("disabled"),
                          this.decrement && this.enableButtons("decrement")),
                      this.fireEvent("change", f),
                      (0, v.dispatch)("change.hs.inputNumber", this.el, f);
                  }),
                  (x.prototype.disableButtons = function (_) {
                    _ === void 0 && (_ = "all"),
                      _ === "all"
                        ? ((this.increment.tagName !== "BUTTON" &&
                            this.increment.tagName !== "INPUT") ||
                            this.increment.setAttribute("disabled", "disabled"),
                          (this.decrement.tagName !== "BUTTON" &&
                            this.decrement.tagName !== "INPUT") ||
                            this.decrement.setAttribute("disabled", "disabled"))
                        : _ === "increment"
                          ? (this.increment.tagName !== "BUTTON" &&
                              this.increment.tagName !== "INPUT") ||
                            this.increment.setAttribute("disabled", "disabled")
                          : _ === "decrement" &&
                            ((this.decrement.tagName !== "BUTTON" &&
                              this.decrement.tagName !== "INPUT") ||
                              this.decrement.setAttribute(
                                "disabled",
                                "disabled",
                              ));
                  }),
                  (x.prototype.enableButtons = function (_) {
                    _ === void 0 && (_ = "all"),
                      _ === "all"
                        ? ((this.increment.tagName !== "BUTTON" &&
                            this.increment.tagName !== "INPUT") ||
                            this.increment.removeAttribute("disabled"),
                          (this.decrement.tagName !== "BUTTON" &&
                            this.decrement.tagName !== "INPUT") ||
                            this.decrement.removeAttribute("disabled"))
                        : _ === "increment"
                          ? (this.increment.tagName !== "BUTTON" &&
                              this.increment.tagName !== "INPUT") ||
                            this.increment.removeAttribute("disabled")
                          : _ === "decrement" &&
                            ((this.decrement.tagName !== "BUTTON" &&
                              this.decrement.tagName !== "INPUT") ||
                              this.decrement.removeAttribute("disabled"));
                  }),
                  (x.getInstance = function (_, f) {
                    var d = window.$hsInputNumberCollection.find(function (m) {
                      return (
                        m.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    return d ? (f ? d : d.element) : null;
                  }),
                  (x.autoInit = function () {
                    window.$hsInputNumberCollection ||
                      (window.$hsInputNumberCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-input-number]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (_) {
                          window.$hsInputNumberCollection.find(function (f) {
                            var d;
                            return (
                              ((d = f == null ? void 0 : f.element) === null ||
                              d === void 0
                                ? void 0
                                : d.el) === _
                            );
                          }) || new x(_);
                        });
                  }),
                  x
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              typeof window < "u" && (window.HSInputNumber = y),
              (a.default = y);
          },
          770: function (o, a, u) {
            /*
             * HSOverlay
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d, m) {
                  var g,
                    w,
                    T = x.call(this, f, d, m) || this,
                    C = f.getAttribute("data-hs-overlay-options"),
                    A = C ? JSON.parse(C) : {},
                    L = v(v({}, A), d);
                  return (
                    (T.hiddenClass =
                      (L == null ? void 0 : L.hiddenClass) || "hidden"),
                    (T.isClosePrev =
                      (g = L == null ? void 0 : L.isClosePrev) === null ||
                      g === void 0 ||
                      g),
                    (T.backdropClasses =
                      (w = L == null ? void 0 : L.backdropClasses) !== null &&
                      w !== void 0
                        ? w
                        : "transition duration fixed inset-0 bg-gray-900 bg-opacity-50 dark:bg-opacity-80 hs-overlay-backdrop"),
                    (T.openNextOverlay = !1),
                    (T.autoHide = null),
                    (T.overlayId = T.el.getAttribute("data-hs-overlay")),
                    (T.overlay = document.querySelector(T.overlayId)),
                    T.overlay &&
                      ((T.isCloseWhenClickInside =
                        (0, y.getClassProperty)(
                          T.overlay,
                          "--close-when-click-inside",
                          "false",
                        ) || "false"),
                      (T.isTabAccessibilityLimited =
                        (0, y.getClassProperty)(
                          T.overlay,
                          "--tab-accessibility-limited",
                          "true",
                        ) || "true"),
                      (T.hasAutofocus =
                        (0, y.getClassProperty)(
                          T.overlay,
                          "--has-autofocus",
                          "true",
                        ) || "true"),
                      (T.hasAbilityToCloseOnBackdropClick =
                        T.overlay.getAttribute("data-hs-overlay-keyboard") ||
                        "true")),
                    T.overlay && T.init(),
                    T
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    var f = this;
                    this.createCollection(window.$hsOverlayCollection, this),
                      this.el.addEventListener("click", function () {
                        f.overlay.classList.contains(f.hiddenClass)
                          ? f.open()
                          : f.close();
                      }),
                      this.overlay.addEventListener("click", function (d) {
                        d.target.id &&
                          "#".concat(d.target.id) === f.overlayId &&
                          f.isCloseWhenClickInside === "true" &&
                          f.hasAbilityToCloseOnBackdropClick === "true" &&
                          f.close();
                      });
                  }),
                  (_.prototype.hideAuto = function () {
                    var f = this,
                      d = parseInt(
                        (0, y.getClassProperty)(
                          this.overlay,
                          "--auto-hide",
                          "0",
                        ),
                      );
                    d &&
                      (this.autoHide = setTimeout(function () {
                        f.close();
                      }, d));
                  }),
                  (_.prototype.checkTimer = function () {
                    this.autoHide &&
                      (clearTimeout(this.autoHide), (this.autoHide = null));
                  }),
                  (_.prototype.buildBackdrop = function () {
                    var f = this,
                      d = this.overlay.classList.value.split(" "),
                      m = parseInt(
                        window
                          .getComputedStyle(this.overlay)
                          .getPropertyValue("z-index"),
                      ),
                      g =
                        this.overlay.getAttribute(
                          "data-hs-overlay-backdrop-container",
                        ) || !1,
                      w = document.createElement("div"),
                      T = this.backdropClasses,
                      C =
                        (0, y.getClassProperty)(
                          this.overlay,
                          "--overlay-backdrop",
                          "true",
                        ) !== "static",
                      A =
                        (0, y.getClassProperty)(
                          this.overlay,
                          "--overlay-backdrop",
                          "true",
                        ) === "false";
                    (w.id = "".concat(this.overlay.id, "-backdrop")),
                      "style" in w && (w.style.zIndex = "".concat(m - 1));
                    for (var L = 0, N = d; L < N.length; L++) {
                      var P = N[L];
                      (P.startsWith("hs-overlay-backdrop-open:") ||
                        P.includes(":hs-overlay-backdrop-open:")) &&
                        (T += " ".concat(P));
                    }
                    A ||
                      (g &&
                        ((w = document
                          .querySelector(g)
                          .cloneNode(!0)).classList.remove("hidden"),
                        (T = "".concat(w.classList.toString())),
                        (w.classList.value = "")),
                      C &&
                        w.addEventListener(
                          "click",
                          function () {
                            return f.close();
                          },
                          !0,
                        ),
                      w.setAttribute("data-hs-overlay-backdrop-template", ""),
                      document.body.appendChild(w),
                      setTimeout(function () {
                        w.classList.value = T;
                      }));
                  }),
                  (_.prototype.destroyBackdrop = function () {
                    var f = document.querySelector(
                      "#".concat(this.overlay.id, "-backdrop"),
                    );
                    f &&
                      (this.openNextOverlay &&
                        (f.style.transitionDuration = "".concat(
                          1.8 *
                            parseFloat(
                              window
                                .getComputedStyle(f)
                                .transitionDuration.replace(/[^\d.-]/g, ""),
                            ),
                          "s",
                        )),
                      f.classList.add("opacity-0"),
                      (0, y.afterTransition)(f, function () {
                        f.remove();
                      }));
                  }),
                  (_.prototype.focusElement = function () {
                    var f = this.overlay.querySelector("[autofocus]");
                    if (!f) return !1;
                    f.focus();
                  }),
                  (_.prototype.open = function () {
                    var f = this;
                    if (!this.overlay) return !1;
                    var d = window.$hsOverlayCollection.find(function (g) {
                        return (
                          g.element.overlay ===
                          document.querySelector(".hs-overlay.open")
                        );
                      }),
                      m =
                        (0, y.getClassProperty)(
                          this.overlay,
                          "--body-scroll",
                          "false",
                        ) !== "true";
                    if (this.isClosePrev && d)
                      return (
                        (this.openNextOverlay = !0),
                        d.element.close().then(function () {
                          f.open(), (f.openNextOverlay = !1);
                        })
                      );
                    m && (document.body.style.overflow = "hidden"),
                      this.buildBackdrop(),
                      this.checkTimer(),
                      this.hideAuto(),
                      this.overlay.classList.remove(this.hiddenClass),
                      this.overlay.setAttribute("aria-overlay", "true"),
                      this.overlay.setAttribute("tabindex", "-1"),
                      setTimeout(function () {
                        if (f.overlay.classList.contains(f.hiddenClass))
                          return !1;
                        f.overlay.classList.add("open"),
                          f.fireEvent("open", f.el),
                          (0, y.dispatch)("open.hs.overlay", f.el, f.el),
                          f.hasAutofocus === "true" && f.focusElement();
                      }, 50);
                  }),
                  (_.prototype.close = function () {
                    var f = this;
                    return new Promise(function (d) {
                      if (!f.overlay) return !1;
                      f.overlay.classList.remove("open"),
                        f.overlay.removeAttribute("aria-overlay"),
                        f.overlay.removeAttribute("tabindex"),
                        (0, y.afterTransition)(f.overlay, function () {
                          if (f.overlay.classList.contains("open")) return !1;
                          f.overlay.classList.add(f.hiddenClass),
                            f.destroyBackdrop(),
                            f.fireEvent("close", f.el),
                            (0, y.dispatch)("close.hs.overlay", f.el, f.el),
                            (document.body.style.overflow = ""),
                            d(f.overlay);
                        });
                    });
                  }),
                  (_.getInstance = function (f, d) {
                    var m = window.$hsOverlayCollection.find(function (g) {
                      return (
                        g.element.el ===
                          (typeof f == "string"
                            ? document.querySelector(f)
                            : f) ||
                        g.element.overlay ===
                          (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    return m ? (d ? m : m.element.el) : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsOverlayCollection ||
                      (window.$hsOverlayCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-overlay]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          window.$hsOverlayCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === f
                            );
                          }) || new _(f);
                        }),
                      window.$hsOverlayCollection &&
                        document.addEventListener("keydown", function (f) {
                          return _.accessibility(f);
                        });
                  }),
                  (_.open = function (f) {
                    var d = window.$hsOverlayCollection.find(function (m) {
                      return (
                        m.element.el ===
                          (typeof f == "string"
                            ? document.querySelector(f)
                            : f) ||
                        m.element.overlay ===
                          (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    d &&
                      d.element.overlay.classList.contains(
                        d.element.hiddenClass,
                      ) &&
                      d.element.open();
                  }),
                  (_.close = function (f) {
                    var d = window.$hsOverlayCollection.find(function (m) {
                      return (
                        m.element.el ===
                          (typeof f == "string"
                            ? document.querySelector(f)
                            : f) ||
                        m.element.overlay ===
                          (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    d &&
                      !d.element.overlay.classList.contains(
                        d.element.hiddenClass,
                      ) &&
                      d.element.close();
                  }),
                  (_.accessibility = function (f) {
                    var d,
                      m,
                      g = window.$hsOverlayCollection.filter(function (L) {
                        return L.element.overlay.classList.contains("open");
                      }),
                      w = g[g.length - 1],
                      T =
                        (m =
                          (d = w == null ? void 0 : w.element) === null ||
                          d === void 0
                            ? void 0
                            : d.overlay) === null || m === void 0
                          ? void 0
                          : m.querySelectorAll(
                              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                            ),
                      C = [];
                    T != null &&
                      T.length &&
                      T.forEach(function (L) {
                        (0, y.isParentOrElementHidden)(L) || C.push(L);
                      });
                    var A = w && !f.metaKey;
                    if (
                      A &&
                      w.element.isTabAccessibilityLimited === "false" &&
                      f.code === "Tab"
                    )
                      return !1;
                    A &&
                      C.length &&
                      f.code === "Tab" &&
                      (f.preventDefault(), this.onTab(w, C)),
                      A &&
                        f.code === "Escape" &&
                        (f.preventDefault(), this.onEscape(w));
                  }),
                  (_.onEscape = function (f) {
                    f && f.element.close();
                  }),
                  (_.onTab = function (f, d) {
                    if (!d.length) return !1;
                    var m = f.element.overlay.querySelector(":focus"),
                      g = Array.from(d).indexOf(m);
                    g > -1 ? d[(g + 1) % d.length].focus() : d[0].focus();
                  }),
                  (_.on = function (f, d, m) {
                    var g = window.$hsOverlayCollection.find(function (w) {
                      return (
                        w.element.el ===
                          (typeof d == "string"
                            ? document.querySelector(d)
                            : d) ||
                        w.element.overlay ===
                          (typeof d == "string" ? document.querySelector(d) : d)
                      );
                    });
                    g && (g.element.events[f] = m);
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSOverlay = S),
              (a.default = S);
          },
          659: function (o, a, u) {
            /*
             * HSPinInput
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this,
                    g = f.getAttribute("data-hs-pin-input"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d);
                  return (
                    (m.items = m.el.querySelectorAll(
                      "[data-hs-pin-input-item]",
                    )),
                    (m.currentItem = null),
                    (m.currentValue = new Array(m.items.length).fill("")),
                    (m.placeholders = []),
                    (m.availableCharsRE = new RegExp(
                      (T == null ? void 0 : T.availableCharsRE) ||
                        "^[a-zA-Z0-9]+$",
                    )),
                    m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    this.createCollection(window.$hsPinInputCollection, this),
                      this.items.length && this.build();
                  }),
                  (_.prototype.build = function () {
                    this.buildInputItems();
                  }),
                  (_.prototype.buildInputItems = function () {
                    var f = this;
                    this.items.forEach(function (d, m) {
                      f.placeholders.push(d.getAttribute("placeholder") || ""),
                        d.hasAttribute("autofocus") && f.onFocusIn(m),
                        d.addEventListener("input", function (g) {
                          return f.onInput(g, m);
                        }),
                        d.addEventListener("paste", function (g) {
                          return f.onPaste(g);
                        }),
                        d.addEventListener("keydown", function (g) {
                          return f.onKeydown(g, m);
                        }),
                        d.addEventListener("focusin", function () {
                          return f.onFocusIn(m);
                        }),
                        d.addEventListener("focusout", function () {
                          return f.onFocusOut(m);
                        });
                    });
                  }),
                  (_.prototype.checkIfNumber = function (f) {
                    return f.match(this.availableCharsRE);
                  }),
                  (_.prototype.autoFillAll = function (f) {
                    var d = this;
                    Array.from(f).forEach(function (m, g) {
                      if (!(d != null && d.items[g])) return !1;
                      (d.items[g].value = m),
                        d.items[g].dispatchEvent(
                          new Event("input", { bubbles: !0 }),
                        );
                    });
                  }),
                  (_.prototype.setCurrentValue = function () {
                    this.currentValue = Array.from(this.items).map(
                      function (f) {
                        return f.value;
                      },
                    );
                  }),
                  (_.prototype.toggleCompleted = function () {
                    this.currentValue.includes("")
                      ? this.el.classList.remove("active")
                      : this.el.classList.add("active");
                  }),
                  (_.prototype.onInput = function (f, d) {
                    var m = f.target.value;
                    if (
                      ((this.currentItem = f.target),
                      (this.currentItem.value = ""),
                      (this.currentItem.value = m[m.length - 1]),
                      !this.checkIfNumber(this.currentItem.value))
                    )
                      return (
                        (this.currentItem.value = this.currentValue[d] || ""),
                        !1
                      );
                    if ((this.setCurrentValue(), this.currentItem.value)) {
                      if (
                        (d < this.items.length - 1 && this.items[d + 1].focus(),
                        !this.currentValue.includes(""))
                      ) {
                        var g = { currentValue: this.currentValue };
                        this.fireEvent("completed", g),
                          (0, y.dispatch)("completed.hs.pinInput", this.el, g);
                      }
                      this.toggleCompleted();
                    } else d > 0 && this.items[d - 1].focus();
                  }),
                  (_.prototype.onKeydown = function (f, d) {
                    f.key === "Backspace" &&
                      d > 0 &&
                      (this.items[d].value === ""
                        ? ((this.items[d - 1].value = ""),
                          this.items[d - 1].focus())
                        : (this.items[d].value = "")),
                      this.setCurrentValue(),
                      this.toggleCompleted();
                  }),
                  (_.prototype.onFocusIn = function (f) {
                    this.items[f].setAttribute("placeholder", "");
                  }),
                  (_.prototype.onFocusOut = function (f) {
                    this.items[f].setAttribute(
                      "placeholder",
                      this.placeholders[f],
                    );
                  }),
                  (_.prototype.onPaste = function (f) {
                    var d = this;
                    f.preventDefault(),
                      this.items.forEach(function (m) {
                        document.activeElement === m &&
                          d.autoFillAll(f.clipboardData.getData("text"));
                      });
                  }),
                  (_.getInstance = function (f, d) {
                    var m = window.$hsPinInputCollection.find(function (g) {
                      return (
                        g.element.el ===
                        (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    return m ? (d ? m : m.element) : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsPinInputCollection ||
                      (window.$hsPinInputCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-pin-input]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          window.$hsPinInputCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === f
                            );
                          }) || new _(f);
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSPinInput = S),
              (a.default = S);
          },
          139: function (o, a, u) {
            /*
             * HSRemoveElement
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this,
                    g = f.getAttribute("data-hs-remove-element-options"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d);
                  return (
                    (m.removeTargetId = m.el.getAttribute(
                      "data-hs-remove-element",
                    )),
                    (m.removeTarget = document.querySelector(m.removeTargetId)),
                    (m.removeTargetAnimationClass =
                      (T == null ? void 0 : T.removeTargetAnimationClass) ||
                      "hs-removing"),
                    m.removeTarget && m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    var f = this;
                    this.createCollection(
                      window.$hsRemoveElementCollection,
                      this,
                    ),
                      this.el.addEventListener("click", function () {
                        return f.remove();
                      });
                  }),
                  (_.prototype.remove = function () {
                    var f = this;
                    if (!this.removeTarget) return !1;
                    this.removeTarget.classList.add(
                      this.removeTargetAnimationClass,
                    ),
                      (0, y.afterTransition)(this.removeTarget, function () {
                        f.removeTarget.remove();
                      });
                  }),
                  (_.autoInit = function () {
                    window.$hsRemoveElementCollection ||
                      (window.$hsRemoveElementCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-remove-element]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          window.$hsRemoveElementCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === f
                            );
                          }) || new _(f);
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSRemoveElement = S),
              (a.default = S);
          },
          591: function (o, a, u) {
            /*
             * HSScrollspy
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                });
            Object.defineProperty(a, "__esModule", { value: !0 });
            var v = u(969),
              y = (function (S) {
                function x(_, f) {
                  f === void 0 && (f = {});
                  var d = S.call(this, _, f) || this;
                  return (
                    (d.activeSection = null),
                    (d.contentId = d.el.getAttribute("data-hs-scrollspy")),
                    (d.content = document.querySelector(d.contentId)),
                    (d.links = d.el.querySelectorAll("[href]")),
                    (d.sections = []),
                    (d.scrollableId = d.el.getAttribute(
                      "data-hs-scrollspy-scrollable-parent",
                    )),
                    (d.scrollable = d.scrollableId
                      ? document.querySelector(d.scrollableId)
                      : document),
                    d.init(),
                    d
                  );
                }
                return (
                  p(x, S),
                  (x.prototype.init = function () {
                    var _ = this;
                    this.createCollection(window.$hsScrollspyCollection, this),
                      this.links.forEach(function (f) {
                        _.sections.push(
                          _.scrollable.querySelector(f.getAttribute("href")),
                        );
                      }),
                      Array.from(this.sections).forEach(function (f) {
                        if (!f.getAttribute("id")) return !1;
                        _.scrollable.addEventListener("scroll", function (d) {
                          return _.update(d, f);
                        });
                      }),
                      this.links.forEach(function (f) {
                        f.addEventListener("click", function (d) {
                          if (
                            (d.preventDefault(),
                            f.getAttribute("href") === "javascript:;")
                          )
                            return !1;
                          _.scrollTo(f);
                        });
                      });
                  }),
                  (x.prototype.update = function (_, f) {
                    var d = parseInt(
                        (0, v.getClassProperty)(
                          this.el,
                          "--scrollspy-offset",
                          "0",
                        ),
                      ),
                      m =
                        parseInt(
                          (0, v.getClassProperty)(f, "--scrollspy-offset"),
                        ) || d,
                      g =
                        _.target === document
                          ? 0
                          : parseInt(
                              String(_.target.getBoundingClientRect().top),
                            ),
                      w =
                        parseInt(String(f.getBoundingClientRect().top)) - m - g,
                      T = f.offsetHeight;
                    if (w <= 0 && w + T > 0) {
                      if (this.activeSection === f) return !1;
                      this.links.forEach(function (N) {
                        N.classList.remove("active");
                      });
                      var C = this.el.querySelector(
                        '[href="#'.concat(f.getAttribute("id"), '"]'),
                      );
                      if (C) {
                        C.classList.add("active");
                        var A = C.closest("[data-hs-scrollspy-group]");
                        if (A) {
                          var L = A.querySelector("[href]");
                          L && L.classList.add("active");
                        }
                      }
                      this.activeSection = f;
                    }
                  }),
                  (x.prototype.scrollTo = function (_) {
                    var f = _.getAttribute("href"),
                      d = document.querySelector(f),
                      m = parseInt(
                        (0, v.getClassProperty)(
                          this.el,
                          "--scrollspy-offset",
                          "0",
                        ),
                      ),
                      g =
                        parseInt(
                          (0, v.getClassProperty)(d, "--scrollspy-offset"),
                        ) || m,
                      w =
                        this.scrollable === document
                          ? 0
                          : this.scrollable.offsetTop,
                      T = d.offsetTop - g - w,
                      C =
                        this.scrollable === document ? window : this.scrollable,
                      A = function () {
                        window.history.replaceState(
                          null,
                          null,
                          _.getAttribute("href"),
                        ),
                          "scrollTo" in C &&
                            C.scrollTo({ top: T, left: 0, behavior: "smooth" });
                      },
                      L = this.fireEvent("beforeScroll", this.el);
                    (0, v.dispatch)(
                      "beforeScroll.hs.scrollspy",
                      this.el,
                      this.el,
                    ),
                      L instanceof Promise
                        ? L.then(function () {
                            return A();
                          })
                        : A();
                  }),
                  (x.getInstance = function (_, f) {
                    f === void 0 && (f = !1);
                    var d = window.$hsScrollspyCollection.find(function (m) {
                      return (
                        m.element.el ===
                        (typeof _ == "string" ? document.querySelector(_) : _)
                      );
                    });
                    return d ? (f ? d : d.element.el) : null;
                  }),
                  (x.autoInit = function () {
                    window.$hsScrollspyCollection ||
                      (window.$hsScrollspyCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-scrollspy]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (_) {
                          window.$hsScrollspyCollection.find(function (f) {
                            var d;
                            return (
                              ((d = f == null ? void 0 : f.element) === null ||
                              d === void 0
                                ? void 0
                                : d.el) === _
                            );
                          }) || new x(_);
                        });
                  }),
                  x
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              typeof window < "u" && (window.HSScrollspy = y),
              (a.default = y);
          },
          961: function (o, a, u) {
            /*
             * HSTogglePassword
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (f, d) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (m, g) {
                          m.__proto__ = g;
                        }) ||
                      function (m, g) {
                        for (var w in g)
                          Object.prototype.hasOwnProperty.call(g, w) &&
                            (m[w] = g[w]);
                      }),
                    h(f, d)
                  );
                }),
                function (f, d) {
                  if (typeof d != "function" && d !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(d) +
                        " is not a constructor or null",
                    );
                  function m() {
                    this.constructor = f;
                  }
                  h(f, d),
                    (f.prototype =
                      d === null
                        ? Object.create(d)
                        : ((m.prototype = d.prototype), new m()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (f) {
                        for (var d, m = 1, g = arguments.length; m < g; m++)
                          for (var w in (d = arguments[m]))
                            Object.prototype.hasOwnProperty.call(d, w) &&
                              (f[w] = d[w]);
                        return f;
                      }),
                    v.apply(this, arguments)
                  );
                },
              y =
                (this && this.__awaiter) ||
                function (f, d, m, g) {
                  return new (m || (m = Promise))(function (w, T) {
                    function C(N) {
                      try {
                        L(g.next(N));
                      } catch (P) {
                        T(P);
                      }
                    }
                    function A(N) {
                      try {
                        L(g.throw(N));
                      } catch (P) {
                        T(P);
                      }
                    }
                    function L(N) {
                      var P;
                      N.done
                        ? w(N.value)
                        : ((P = N.value),
                          P instanceof m
                            ? P
                            : new m(function (I) {
                                I(P);
                              })).then(C, A);
                    }
                    L((g = g.apply(f, d || [])).next());
                  });
                },
              S =
                (this && this.__generator) ||
                function (f, d) {
                  var m,
                    g,
                    w,
                    T,
                    C = {
                      label: 0,
                      sent: function () {
                        if (1 & w[0]) throw w[1];
                        return w[1];
                      },
                      trys: [],
                      ops: [],
                    };
                  return (
                    (T = { next: A(0), throw: A(1), return: A(2) }),
                    typeof Symbol == "function" &&
                      (T[Symbol.iterator] = function () {
                        return this;
                      }),
                    T
                  );
                  function A(L) {
                    return function (N) {
                      return (function (P) {
                        if (m)
                          throw new TypeError(
                            "Generator is already executing.",
                          );
                        for (; T && ((T = 0), P[0] && (C = 0)), C; )
                          try {
                            if (
                              ((m = 1),
                              g &&
                                (w =
                                  2 & P[0]
                                    ? g.return
                                    : P[0]
                                      ? g.throw ||
                                        ((w = g.return) && w.call(g), 0)
                                      : g.next) &&
                                !(w = w.call(g, P[1])).done)
                            )
                              return w;
                            switch (
                              ((g = 0), w && (P = [2 & P[0], w.value]), P[0])
                            ) {
                              case 0:
                              case 1:
                                w = P;
                                break;
                              case 4:
                                return C.label++, { value: P[1], done: !1 };
                              case 5:
                                C.label++, (g = P[1]), (P = [0]);
                                continue;
                              case 7:
                                (P = C.ops.pop()), C.trys.pop();
                                continue;
                              default:
                                if (
                                  ((w = C.trys),
                                  !(
                                    (w = w.length > 0 && w[w.length - 1]) ||
                                    (P[0] !== 6 && P[0] !== 2)
                                  ))
                                ) {
                                  C = 0;
                                  continue;
                                }
                                if (
                                  P[0] === 3 &&
                                  (!w || (P[1] > w[0] && P[1] < w[3]))
                                ) {
                                  C.label = P[1];
                                  break;
                                }
                                if (P[0] === 6 && C.label < w[1]) {
                                  (C.label = w[1]), (w = P);
                                  break;
                                }
                                if (w && C.label < w[2]) {
                                  (C.label = w[2]), C.ops.push(P);
                                  break;
                                }
                                w[2] && C.ops.pop(), C.trys.pop();
                                continue;
                            }
                            P = d.call(f, C);
                          } catch (I) {
                            (P = [6, I]), (g = 0);
                          } finally {
                            m = w = 0;
                          }
                        if (5 & P[0]) throw P[1];
                        return { value: P[0] ? P[1] : void 0, done: !0 };
                      })([L, N]);
                    };
                  }
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var x = u(969),
              _ = (function (f) {
                function d(m, g) {
                  var w = f.call(this, m, g) || this,
                    T = m.getAttribute("data-hs-search-by-json"),
                    C = T ? JSON.parse(T) : {},
                    A = v(v({}, C), g);
                  return (
                    (w.jsonUrl = A.jsonUrl),
                    (w.minChars = A.minChars || 3),
                    (w.dropdownTemplate = A.dropdownTemplate || "<div></div>"),
                    (w.dropdownClasses =
                      A.dropdownClasses ||
                      "absolute top-full z-[1] w-full bg-white border border-gray-200 rounded-md hidden mt-2"),
                    (w.dropdownItemTemplate =
                      A.dropdownItemTemplate || "<div></div>"),
                    (w.dropdownItemTemplatesByType =
                      A.dropdownItemTemplatesByType || null),
                    (w.dropdownItemClasses =
                      A.dropdownItemClasses ||
                      "py-2 px-4 w-full cursor-pointer text-sm hover:bg-gray-300 hover:text-black"),
                    (w.highlightedTextTagName =
                      A.highlightedTextTagName || "u"),
                    (w.highlightedTextClasses =
                      A.highlightedTextClasses || "bg-green-200"),
                    w.jsonUrl &&
                      w.fetchData().then(function () {
                        return w.init();
                      }),
                    w
                  );
                }
                return (
                  p(d, f),
                  (d.prototype.init = function () {
                    var m = this;
                    this.createCollection(
                      window.$hsSearchByJsonCollection,
                      this,
                    ),
                      this.buildDropdown(),
                      this.el.addEventListener(
                        "input",
                        (0, x.debounce)(function (g) {
                          (m.val = g.target.value),
                            m.val.length > m.minChars
                              ? m.searchData(m.val)
                              : (m.result = []),
                            m.result.length
                              ? m.dropdown.classList.remove("hidden")
                              : m.dropdown.classList.add("hidden"),
                            m.buildItems(),
                            console.log("result:", m.result);
                        }),
                      );
                  }),
                  (d.prototype.fetchData = function () {
                    return y(this, void 0, void 0, function () {
                      var m = this;
                      return S(this, function (g) {
                        switch (g.label) {
                          case 0:
                            return [
                              4,
                              fetch(this.jsonUrl)
                                .then(function (w) {
                                  return w.json();
                                })
                                .then(function (w) {
                                  return (m.json = w);
                                }),
                            ];
                          case 1:
                            return g.sent(), [2];
                        }
                      });
                    });
                  }),
                  (d.prototype.searchData = function (m) {
                    this.result = this.json.filter(function (g) {
                      var w = m.toLowerCase(),
                        T = g.title.toLowerCase(),
                        C = g.description.toLowerCase();
                      return T.includes(w) || C.includes(w);
                    });
                  }),
                  (d.prototype.buildDropdown = function () {
                    (this.dropdown = (0, x.htmlToElement)(
                      this.dropdownTemplate,
                    )),
                      this.dropdownClasses &&
                        (0, x.classToClassList)(
                          this.dropdownClasses,
                          this.dropdown,
                        ),
                      this.el.after(this.dropdown);
                  }),
                  (d.prototype.buildItems = function () {
                    var m = this;
                    (this.dropdown.innerHTML = ""),
                      this.result.forEach(function (g) {
                        var w = (0, x.htmlToElement)(
                          '<a class="block" href="'.concat(
                            g.url,
                            '" target="_blank"></a>',
                          ),
                        );
                        w.append(m.itemTemplate(g)), m.dropdown.append(w);
                      });
                  }),
                  (d.prototype.itemTemplate = function (m) {
                    var g = new RegExp(this.val, "gi"),
                      w = m.title.replace(
                        g,
                        "<"
                          .concat(
                            this.highlightedTextTagName,
                            ' class="inline-block ',
                          )
                          .concat(this.highlightedTextClasses, '">')
                          .concat(this.val, "</")
                          .concat(this.highlightedTextTagName, ">"),
                      ),
                      T = m.description.replace(
                        g,
                        "<"
                          .concat(
                            this.highlightedTextTagName,
                            ' class="inline-block ',
                          )
                          .concat(this.highlightedTextClasses, '">')
                          .concat(this.val, "</")
                          .concat(this.highlightedTextTagName, ">"),
                      ),
                      C = this.dropdownItemTemplatesByType
                        ? this.dropdownItemTemplatesByType.find(function (I) {
                            return I.type === m.type;
                          })
                        : null,
                      A = C
                        ? (0, x.htmlToElement)(C.markup)
                        : (0, x.htmlToElement)(this.dropdownItemTemplate);
                    this.dropdownItemClasses &&
                      (0, x.classToClassList)(this.dropdownItemClasses, A);
                    var L = A.querySelector("[data-title]");
                    L
                      ? L.append(
                          (0, x.htmlToElement)("<span>".concat(w, "</span>")),
                        )
                      : A.append(
                          (0, x.htmlToElement)("<span>".concat(w, "</span>")),
                        );
                    var N = A.querySelector("[data-description]");
                    if (N)
                      N.append(
                        (0, x.htmlToElement)("<span>".concat(T, "</span>")),
                      );
                    else if (!C) {
                      var P = (0, x.htmlToElement)("<br />");
                      A.append(P),
                        A.append(
                          (0, x.htmlToElement)("<span>".concat(T, "</span>")),
                        );
                    }
                    return A;
                  }),
                  (d.getInstance = function (m) {
                    var g = window.$hsSearchByJsonCollection.find(function (w) {
                      return (
                        w.element.el ===
                        (typeof m == "string" ? document.querySelector(m) : m)
                      );
                    });
                    return g ? g.element : null;
                  }),
                  (d.autoInit = function () {
                    window.$hsSearchByJsonCollection ||
                      (window.$hsSearchByJsonCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-search-by-json]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (m) {
                          window.$hsSearchByJsonCollection.find(function (g) {
                            var w;
                            return (
                              ((w = g == null ? void 0 : g.element) === null ||
                              w === void 0
                                ? void 0
                                : w.el) === m
                            );
                          }) || new d(m);
                        });
                  }),
                  d
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              _.autoInit();
            }),
              typeof window < "u" && (window.HSSearchByJson = _),
              (a.default = _);
          },
          233: function (o, a, u) {
            /*
             * HSSelect
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (d, m) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (g, w) {
                          g.__proto__ = w;
                        }) ||
                      function (g, w) {
                        for (var T in w)
                          Object.prototype.hasOwnProperty.call(w, T) &&
                            (g[T] = w[T]);
                      }),
                    h(d, m)
                  );
                }),
                function (d, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(m) +
                        " is not a constructor or null",
                    );
                  function g() {
                    this.constructor = d;
                  }
                  h(d, m),
                    (d.prototype =
                      m === null
                        ? Object.create(m)
                        : ((g.prototype = m.prototype), new g()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (d) {
                        for (var m, g = 1, w = arguments.length; g < w; g++)
                          for (var T in (m = arguments[g]))
                            Object.prototype.hasOwnProperty.call(m, T) &&
                              (d[T] = m[T]);
                        return d;
                      }),
                    v.apply(this, arguments)
                  );
                },
              y =
                (this && this.__spreadArray) ||
                function (d, m, g) {
                  if (g || arguments.length === 2)
                    for (var w, T = 0, C = m.length; T < C; T++)
                      (!w && T in m) ||
                        (w || (w = Array.prototype.slice.call(m, 0, T)),
                        (w[T] = m[T]));
                  return d.concat(w || Array.prototype.slice.call(m));
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var S = u(969),
              x = u(737),
              _ = u(190),
              f = (function (d) {
                function m(g, w) {
                  var T,
                    C = d.call(this, g, w) || this,
                    A = g.getAttribute("data-hs-select"),
                    L = A ? JSON.parse(A) : {},
                    N = v(v({}, L), w);
                  return (
                    (C.value =
                      (N == null ? void 0 : N.value) || C.el.value || null),
                    (C.placeholder =
                      (N == null ? void 0 : N.placeholder) || "Select..."),
                    (C.hasSearch = (N == null ? void 0 : N.hasSearch) || !1),
                    (C.mode = (N == null ? void 0 : N.mode) || "default"),
                    (C.viewport =
                      (N == null ? void 0 : N.viewport) !== void 0
                        ? document.querySelector(
                            N == null ? void 0 : N.viewport,
                          )
                        : null),
                    (C.isOpened = !!(N != null && N.isOpened) || !1),
                    (C.isMultiple = C.el.hasAttribute("multiple") || !1),
                    (C.isDisabled = C.el.hasAttribute("disabled") || !1),
                    (C.toggleTag = (N == null ? void 0 : N.toggleTag) || null),
                    (C.toggleClasses =
                      (N == null ? void 0 : N.toggleClasses) || null),
                    (C.toggleCountText =
                      (N == null ? void 0 : N.toggleCountText) || null),
                    (C.toggleCountTextMinItems =
                      (N == null ? void 0 : N.toggleCountTextMinItems) || 1),
                    (C.tagsClasses =
                      (N == null ? void 0 : N.tagsClasses) || null),
                    (C.tagsItemTemplate =
                      (N == null ? void 0 : N.tagsItemTemplate) || null),
                    (C.tagsItemClasses =
                      (N == null ? void 0 : N.tagsItemClasses) || null),
                    (C.tagsInputClasses =
                      (N == null ? void 0 : N.tagsInputClasses) || null),
                    (C.dropdownTag =
                      (N == null ? void 0 : N.dropdownTag) || null),
                    (C.dropdownClasses =
                      (N == null ? void 0 : N.dropdownClasses) || null),
                    (C.dropdownDirectionClasses =
                      (N == null ? void 0 : N.dropdownDirectionClasses) ||
                      null),
                    (C.dropdownSpace =
                      (N == null ? void 0 : N.dropdownSpace) || 10),
                    (C.searchWrapperTemplate =
                      (N == null ? void 0 : N.searchWrapperTemplate) || null),
                    (C.searchWrapperClasses =
                      (N == null ? void 0 : N.searchWrapperClasses) ||
                      "bg-white p-2 sticky top-0"),
                    (C.searchClasses =
                      (N == null ? void 0 : N.searchClasses) ||
                      "block w-[calc(100%-2rem)] text-sm border-gray-200 rounded-md focus:border-blue-500 focus:ring-blue-500 dark:bg-slate-900 dark:border-gray-700 dark:text-gray-400 py-2 px-3 my-2 mx-4"),
                    (C.searchPlaceholder =
                      (N == null ? void 0 : N.searchPlaceholder) ||
                      "Search..."),
                    (C.searchNoResultText =
                      (N == null ? void 0 : N.searchNoResultText) ||
                      "No options found..."),
                    (C.searchNoResultClasses =
                      (N == null ? void 0 : N.searchNoResultClasses) ||
                      "px-4 text-sm"),
                    (C.optionTemplate =
                      (N == null ? void 0 : N.optionTemplate) || null),
                    (C.optionTag = (N == null ? void 0 : N.optionTag) || null),
                    (C.optionClasses =
                      (N == null ? void 0 : N.optionClasses) || null),
                    (C.descriptionClasses =
                      (N == null ? void 0 : N.descriptionClasses) || null),
                    (C.iconClasses =
                      (N == null ? void 0 : N.iconClasses) || null),
                    (C.isAddTagOnEnter =
                      (T = N == null ? void 0 : N.isAddTagOnEnter) === null ||
                      T === void 0 ||
                      T),
                    (C.animationInProcess = !1),
                    (C.selectOptions = []),
                    C.init(),
                    C
                  );
                }
                return (
                  p(m, d),
                  (m.prototype.init = function () {
                    this.createCollection(window.$hsSelectCollection, this),
                      this.build();
                  }),
                  (m.prototype.build = function () {
                    var g = this;
                    if (
                      ((this.el.style.display = "none"),
                      this.el.children &&
                        Array.from(this.el.children)
                          .filter(function (C) {
                            return C.value && C.value !== "";
                          })
                          .forEach(function (C) {
                            var A = C.getAttribute("data-hs-select-option");
                            g.selectOptions = y(
                              y([], g.selectOptions, !0),
                              [
                                {
                                  title: C.textContent,
                                  val: C.value,
                                  options:
                                    A !== "undefined" ? JSON.parse(A) : null,
                                },
                              ],
                              !1,
                            );
                          }),
                      this.isMultiple)
                    ) {
                      var w = Array.from(this.el.options).filter(function (C) {
                        return C.selected;
                      });
                      if (w) {
                        var T = [];
                        w.forEach(function (C) {
                          T.push(C.value);
                        }),
                          (this.value = T);
                      }
                    }
                    this.buildWrapper(),
                      this.mode === "tags"
                        ? this.buildTags()
                        : this.buildToggle(),
                      this.buildDropdown();
                  }),
                  (m.prototype.buildWrapper = function () {
                    (this.wrapper = document.createElement("div")),
                      this.wrapper.classList.add("hs-select", "relative"),
                      this.el.before(this.wrapper),
                      this.wrapper.append(this.el);
                  }),
                  (m.prototype.buildToggle = function () {
                    var g,
                      w,
                      T,
                      C = this;
                    (this.toggleTextWrapper = document.createElement("span")),
                      this.toggleTextWrapper.classList.add("truncate"),
                      (this.toggle = (0, S.htmlToElement)(
                        this.toggleTag || "<div></div>",
                      )),
                      (w = this.toggle.querySelector("[data-icon]")),
                      (T = this.toggle.querySelector("[data-title]")),
                      !this.isMultiple && w && this.setToggleIcon(),
                      !this.isMultiple && T && this.setToggleTitle(),
                      this.isMultiple
                        ? (this.toggleTextWrapper.innerHTML = this.value.length
                            ? this.stringFromValue()
                            : this.placeholder)
                        : (this.toggleTextWrapper.innerHTML =
                            ((g = this.getItemByValue(this.value)) === null ||
                            g === void 0
                              ? void 0
                              : g.title) || this.placeholder),
                      T || this.toggle.append(this.toggleTextWrapper),
                      this.toggleClasses &&
                        (0, S.classToClassList)(
                          this.toggleClasses,
                          this.toggle,
                        ),
                      this.isDisabled && this.toggle.classList.add("disabled"),
                      this.wrapper && this.wrapper.append(this.toggle),
                      this.toggle.addEventListener("click", function () {
                        if (C.isDisabled) return !1;
                        C.isOpened ? C.close() : C.open();
                      });
                  }),
                  (m.prototype.setToggleIcon = function () {
                    var g,
                      w,
                      T = this.toggle.querySelector("[data-icon]");
                    if (((T.innerHTML = ""), T)) {
                      var C = (0, S.htmlToElement)(
                        ((w =
                          (g = this.getItemByValue(this.value)) === null ||
                          g === void 0
                            ? void 0
                            : g.options) === null || w === void 0
                          ? void 0
                          : w.icon) || "",
                      );
                      T.append(C),
                        C
                          ? T.classList.remove("hidden")
                          : T.classList.add("hidden");
                    }
                  }),
                  (m.prototype.setToggleTitle = function () {
                    var g,
                      w = this.toggle.querySelector("[data-title]");
                    if ((w.classList.add("truncate"), (w.innerHTML = ""), w)) {
                      var T =
                        ((g = this.getItemByValue(this.value)) === null ||
                        g === void 0
                          ? void 0
                          : g.title) || this.placeholder;
                      (w.innerHTML = T), this.toggle.append(w);
                    }
                  }),
                  (m.prototype.buildTags = function () {
                    (this.tags = document.createElement("div")),
                      this.tags.classList.add("flex"),
                      this.tagsClasses &&
                        (0, S.classToClassList)(this.tagsClasses, this.tags),
                      this.buildTagsInput(),
                      this.buildTagsItems(),
                      this.setTagsItems(),
                      this.wrapper && this.wrapper.append(this.tags);
                  }),
                  (m.prototype.buildTagsItems = function () {
                    (this.tagsItems = document.createElement("div")),
                      this.tagsItems.classList.add(
                        "flex",
                        "flex-wrap",
                        "flex-0",
                        "items-center",
                      ),
                      this.setTagsItems(),
                      this.tags.append(this.tagsItems);
                  }),
                  (m.prototype.buildTagsItem = function (g) {
                    var w,
                      T,
                      C,
                      A,
                      L,
                      N,
                      P,
                      I = this,
                      Q = this.getItemByValue(g),
                      ue = document.createElement("div");
                    if (
                      (this.tagsItemClasses &&
                        (0, S.classToClassList)(this.tagsItemClasses, ue),
                      this.tagsItemTemplate &&
                        ((A = (0, S.htmlToElement)(this.tagsItemTemplate)),
                        ue.append(A)),
                      (w = Q == null ? void 0 : Q.options) === null ||
                      w === void 0
                        ? void 0
                        : w.icon)
                    ) {
                      var F = (0, S.htmlToElement)(
                        (T = Q == null ? void 0 : Q.options) === null ||
                          T === void 0
                          ? void 0
                          : T.icon,
                      );
                      (P = A
                        ? A.querySelector("[data-icon]")
                        : document.createElement("span")).append(F),
                        A || ue.append(P);
                    }
                    A &&
                      A.querySelector("[data-icon]") &&
                      !(
                        !(
                          (C = Q == null ? void 0 : Q.options) === null ||
                          C === void 0
                        ) && C.icon
                      ) &&
                      A.querySelector("[data-icon]").classList.add("hidden"),
                      ((L = A
                        ? A.querySelector("[data-title]")
                        : document.createElement("span")).textContent =
                        Q.title || ""),
                      A || ue.append(L),
                      A
                        ? (N = A.querySelector("[data-remove]"))
                        : (((N = document.createElement("span")).textContent =
                            "X"),
                          ue.append(N)),
                      N.addEventListener("click", function () {
                        (I.value = I.value.filter(function (X) {
                          return X !== g;
                        })),
                          I.unselectMultipleItems(),
                          I.setTagsItems(),
                          I.selectMultipleItems();
                      }),
                      this.tagsItems.append(ue);
                  }),
                  (m.prototype.getItemByValue = function (g) {
                    return this.selectOptions.find(function (w) {
                      return w.val === g;
                    });
                  }),
                  (m.prototype.setTagsItems = function () {
                    var g = this;
                    (this.tagsItems.innerHTML = ""),
                      this.value &&
                        (this.value.forEach(function (w) {
                          g.buildTagsItem(w);
                        }),
                        (this.tagsInput.readOnly = !0)),
                      this.value.length ||
                        ((this.tagsInput.placeholder = this.placeholder),
                        (this.tagsInput.readOnly = !1));
                  }),
                  (m.prototype.buildTagsInput = function () {
                    var g = this;
                    (this.tagsInput = document.createElement("input")),
                      (this.tagsInput.placeholder = this.placeholder),
                      this.tagsInputClasses &&
                        (0, S.classToClassList)(
                          this.tagsInputClasses,
                          this.tagsInput,
                        ),
                      this.tagsInput.addEventListener("focus", function () {
                        return g.open();
                      }),
                      this.tagsInput.addEventListener(
                        "input",
                        (0, S.debounce)(function (w) {
                          return g.searchOptions(w.target.value);
                        }),
                      ),
                      this.tagsInput.addEventListener("keydown", function (w) {
                        if (w.key === "Enter" && g.isAddTagOnEnter) {
                          var T = w.target.value;
                          if (
                            g.selectOptions.find(function (C) {
                              return C.val === T;
                            })
                          )
                            return !1;
                          g.addSelectOption(T, T),
                            g.buildOption(T, T),
                            g.dropdown
                              .querySelector('[data-value="'.concat(T, '"]'))
                              .click(),
                            g.resetTagsInputField(),
                            g.close();
                        }
                      }),
                      this.tags.append(this.tagsInput);
                  }),
                  (m.prototype.buildDropdown = function () {
                    var g = this;
                    (this.dropdown = (0, S.htmlToElement)(
                      this.dropdownTag || "<div></div>",
                    )),
                      this.dropdown.classList.add("absolute", "top-full"),
                      this.isOpened || this.dropdown.classList.add("hidden"),
                      this.dropdownClasses &&
                        (0, S.classToClassList)(
                          this.dropdownClasses,
                          this.dropdown,
                        ),
                      this.wrapper && this.wrapper.append(this.dropdown),
                      this.dropdown && this.hasSearch && this.buildSearch(),
                      this.selectOptions &&
                        this.selectOptions.forEach(function (w, T) {
                          return g.buildOption(
                            w.title,
                            w.val,
                            w.options,
                            "".concat(T),
                          );
                        });
                  }),
                  (m.prototype.buildSearch = function () {
                    var g,
                      w = this;
                    (this.searchWrapper = (0, S.htmlToElement)(
                      this.searchWrapperTemplate || "<div></div>",
                    )),
                      this.searchWrapperClasses &&
                        (0, S.classToClassList)(
                          this.searchWrapperClasses,
                          this.searchWrapper,
                        ),
                      (g = this.searchWrapper.querySelector("[data-input]")),
                      (this.search = (0, S.htmlToElement)(
                        '<input type="text" />',
                      )),
                      (this.search.placeholder = this.searchPlaceholder),
                      this.searchClasses &&
                        (0, S.classToClassList)(
                          this.searchClasses,
                          this.search,
                        ),
                      this.search.addEventListener(
                        "input",
                        (0, S.debounce)(function (T) {
                          return w.searchOptions(T.target.value);
                        }),
                      ),
                      g
                        ? g.append(this.search)
                        : this.searchWrapper.append(this.search),
                      this.dropdown.append(this.searchWrapper);
                  }),
                  (m.prototype.buildOption = function (g, w, T, C) {
                    var A = this;
                    C === void 0 && (C = "1");
                    var L = null,
                      N = (0, S.htmlToElement)(this.optionTag || "<div></div>");
                    if (
                      (N.setAttribute("data-value", w),
                      N.setAttribute("data-title-value", g),
                      N.setAttribute("tabIndex", C),
                      N.classList.add("cursor-pointer"),
                      this.optionTemplate &&
                        ((L = (0, S.htmlToElement)(this.optionTemplate)),
                        N.append(L)),
                      L
                        ? (L.querySelector("[data-title]").textContent =
                            g || "")
                        : (N.textContent = g || ""),
                      T)
                    ) {
                      if (T.icon) {
                        var P = (0, S.htmlToElement)(T.icon);
                        if ((P.classList.add("mw-full"), L))
                          L.querySelector("[data-icon]").append(P);
                        else {
                          var I = (0, S.htmlToElement)("<div></div>");
                          this.iconClasses &&
                            (0, S.classToClassList)(this.iconClasses, I),
                            I.append(P),
                            N.append(I);
                        }
                      }
                      if (T.description)
                        if (L)
                          L.querySelector("[data-description]").append(
                            T.description,
                          );
                        else {
                          var Q = (0, S.htmlToElement)("<div></div>");
                          (Q.textContent = T.description),
                            this.descriptionClasses &&
                              (0, S.classToClassList)(
                                this.descriptionClasses,
                                Q,
                              ),
                            N.append(Q);
                        }
                    }
                    L &&
                      L.querySelector("[data-icon]") &&
                      !T &&
                      !(T != null && T.icon) &&
                      L.querySelector("[data-icon]").classList.add("hidden"),
                      this.value &&
                        (this.isMultiple
                          ? this.value.includes(w)
                          : this.value === w) &&
                        N.classList.add("selected"),
                      N.addEventListener("click", function () {
                        return A.onSelectOption(w);
                      }),
                      this.optionClasses &&
                        (0, S.classToClassList)(this.optionClasses, N),
                      this.dropdown && this.dropdown.append(N);
                  }),
                  (m.prototype.destroyOption = function (g) {
                    var w = this.dropdown.querySelector(
                      '[data-value="'.concat(g, '"]'),
                    );
                    if (!w) return !1;
                    w.remove();
                  }),
                  (m.prototype.buildOriginalOption = function (g, w, T) {
                    var C = (0, S.htmlToElement)("<option></option>");
                    C.setAttribute("value", w),
                      C.setAttribute(
                        "data-hs-select-option",
                        JSON.stringify(T),
                      ),
                      (C.innerText = g),
                      this.el.append(C);
                  }),
                  (m.prototype.destroyOriginalOption = function (g) {
                    var w = this.el.querySelector('[value="'.concat(g, '"]'));
                    if (!w) return !1;
                    w.remove();
                  }),
                  (m.prototype.onSelectOption = function (g) {
                    this.clearSelections(),
                      this.isMultiple
                        ? ((this.value = this.value.includes(g)
                            ? Array.from(this.value).filter(function (w) {
                                return w !== g;
                              })
                            : y(y([], Array.from(this.value), !0), [g], !1)),
                          this.selectMultipleItems(),
                          this.setNewValue())
                        : ((this.value = g),
                          this.selectSingleItem(),
                          this.setNewValue()),
                      this.fireEvent("change", this.value),
                      (0, S.dispatch)("change.hs.select", this.el, this.value),
                      this.mode === "tags" && this.resetTagsInputField(),
                      this.isMultiple ||
                        (this.toggle.querySelector("[data-icon]") &&
                          this.setToggleIcon(),
                        this.toggle.querySelector("[data-title]") &&
                          this.setToggleTitle(),
                        this.close()),
                      this.value.length ||
                        this.mode !== "tags" ||
                        (this.tagsInput.placeholder = this.placeholder);
                  }),
                  (m.prototype.addSelectOption = function (g, w, T) {
                    this.selectOptions = y(
                      y([], this.selectOptions, !0),
                      [{ title: g, val: w, options: T }],
                      !1,
                    );
                  }),
                  (m.prototype.removeSelectOption = function (g) {
                    if (
                      !this.selectOptions.some(function (w) {
                        return w.val === g;
                      })
                    )
                      return !1;
                    this.selectOptions = this.selectOptions.filter(
                      function (w) {
                        return w.val !== g;
                      },
                    );
                  }),
                  (m.prototype.resetTagsInputField = function () {
                    (this.tagsInput.value = ""),
                      (this.tagsInput.placeholder = ""),
                      this.searchOptions("");
                  }),
                  (m.prototype.clearSelections = function () {
                    Array.from(this.dropdown.children).forEach(function (g) {
                      g.classList.contains("selected") &&
                        g.classList.remove("selected");
                    }),
                      Array.from(this.el.children).forEach(function (g) {
                        g.selected && (g.selected = !1);
                      });
                  }),
                  (m.prototype.setNewValue = function () {
                    this.mode === "tags"
                      ? this.setTagsItems()
                      : this.value.length
                        ? (this.toggleTextWrapper.innerHTML =
                            this.stringFromValue())
                        : (this.toggleTextWrapper.innerHTML = this.placeholder);
                  }),
                  (m.prototype.stringFromValue = function () {
                    var g = this,
                      w = [];
                    return (
                      this.selectOptions.forEach(function (T) {
                        g.isMultiple
                          ? g.value.includes(T.val) && w.push(T.title)
                          : g.value === T.val && w.push(T.title);
                      }),
                      this.toggleCountText &&
                      this.toggleCountText !== "" &&
                      w.length >= this.toggleCountTextMinItems
                        ? "".concat(w.length, " ").concat(this.toggleCountText)
                        : w.join(", ")
                    );
                  }),
                  (m.prototype.selectSingleItem = function () {
                    var g = this;
                    (Array.from(this.el.children).find(function (w) {
                      return g.value === w.value;
                    }).selected = !0),
                      Array.from(this.dropdown.children)
                        .find(function (w) {
                          return g.value === w.getAttribute("data-value");
                        })
                        .classList.add("selected");
                  }),
                  (m.prototype.selectMultipleItems = function () {
                    var g = this;
                    Array.from(this.dropdown.children)
                      .filter(function (w) {
                        return g.value.includes(w.getAttribute("data-value"));
                      })
                      .forEach(function (w) {
                        return w.classList.add("selected");
                      }),
                      Array.from(this.el.children)
                        .filter(function (w) {
                          return g.value.includes(w.value);
                        })
                        .forEach(function (w) {
                          return (w.selected = !0);
                        });
                  }),
                  (m.prototype.unselectMultipleItems = function () {
                    Array.from(this.dropdown.children).forEach(function (g) {
                      return g.classList.remove("selected");
                    }),
                      Array.from(this.el.children).forEach(function (g) {
                        return (g.selected = !1);
                      });
                  }),
                  (m.prototype.searchOptions = function (g) {
                    this.searchNoResult &&
                      (this.searchNoResult.remove(),
                      (this.searchNoResult = null)),
                      (this.searchNoResult = (0, S.htmlToElement)(
                        "<span></span>",
                      )),
                      (this.searchNoResult.innerText = this.searchNoResultText),
                      (0, S.classToClassList)(
                        this.searchNoResultClasses,
                        this.searchNoResult,
                      );
                    var w = this.dropdown.querySelectorAll("[data-value]"),
                      T = !1;
                    w.forEach(function (C) {
                      C.getAttribute("data-title-value")
                        .toLowerCase()
                        .includes(g.toLowerCase())
                        ? (C.classList.remove("hidden"), (T = !0))
                        : C.classList.add("hidden");
                    }),
                      T || this.dropdown.append(this.searchNoResult);
                  }),
                  (m.prototype.eraseToggleIcon = function () {
                    var g = this.toggle.querySelector("[data-icon]");
                    g && ((g.innerHTML = null), g.classList.add("hidden"));
                  }),
                  (m.prototype.eraseToggleTitle = function () {
                    var g = this.toggle.querySelector("[data-title]");
                    g
                      ? (g.innerHTML = this.placeholder)
                      : (this.toggleTextWrapper.innerHTML = this.placeholder);
                  }),
                  (m.prototype.destroy = function () {
                    var g = this.el.parentElement.parentElement;
                    this.el.classList.remove("hidden"),
                      (this.el.style.display = ""),
                      g.prepend(this.el),
                      g.querySelector(".hs-select").remove(),
                      (this.wrapper = null);
                  }),
                  (m.prototype.open = function () {
                    var g = this;
                    if (this.animationInProcess) return !1;
                    (this.animationInProcess = !0),
                      this.dropdown.classList.remove("hidden"),
                      this.recalculateDirection(),
                      setTimeout(function () {
                        g.wrapper.classList.add("active"),
                          g.dropdown.classList.add("opened"),
                          g.hasSearch && g.search.focus(),
                          (g.animationInProcess = !1);
                      }),
                      (this.isOpened = !0);
                  }),
                  (m.prototype.close = function () {
                    var g,
                      w,
                      T,
                      C = this;
                    if (this.animationInProcess) return !1;
                    (this.animationInProcess = !0),
                      this.wrapper.classList.remove("active"),
                      this.dropdown.classList.remove(
                        "opened",
                        "bottom-full",
                        "top-full",
                      ),
                      !(
                        (g = this.dropdownDirectionClasses) === null ||
                        g === void 0
                      ) &&
                        g.bottom &&
                        this.dropdown.classList.remove(
                          this.dropdownDirectionClasses.bottom,
                        ),
                      !(
                        (w = this.dropdownDirectionClasses) === null ||
                        w === void 0
                      ) &&
                        w.top &&
                        this.dropdown.classList.remove(
                          this.dropdownDirectionClasses.top,
                        ),
                      (this.dropdown.style.marginTop = ""),
                      (this.dropdown.style.marginBottom = ""),
                      (0, S.afterTransition)(this.dropdown, function () {
                        C.dropdown.classList.add("hidden"),
                          C.hasSearch &&
                            ((C.search.value = ""),
                            C.search.dispatchEvent(
                              new Event("input", { bubbles: !0 }),
                            ),
                            C.search.blur()),
                          (C.animationInProcess = !1);
                      }),
                      (T = this.dropdown.querySelector(
                        ".hs-select-option-highlighted",
                      )) === null ||
                        T === void 0 ||
                        T.classList.remove("hs-select-option-highlighted"),
                      (this.isOpened = !1);
                  }),
                  (m.prototype.addOption = function (g) {
                    var w = this,
                      T = "".concat(this.selectOptions.length),
                      C = function (A) {
                        var L = A.title,
                          N = A.val,
                          P = A.options;
                        w.selectOptions.some(function (I) {
                          return I.val === N;
                        }) ||
                          (w.addSelectOption(L, N, P),
                          w.buildOption(L, N, P, T),
                          w.buildOriginalOption(L, N, P));
                      };
                    Array.isArray(g)
                      ? g.forEach(function (A) {
                          C(A);
                        })
                      : C(g);
                  }),
                  (m.prototype.removeOption = function (g) {
                    var w = this,
                      T = function (C) {
                        w.selectOptions.some(function (A) {
                          return A.val === C;
                        }) &&
                          (w.removeSelectOption(C),
                          w.destroyOption(C),
                          w.destroyOriginalOption(C),
                          w.value === C &&
                            ((w.value = null),
                            w.eraseToggleTitle(),
                            w.eraseToggleIcon()));
                      };
                    Array.isArray(g)
                      ? g.forEach(function (C) {
                          T(C);
                        })
                      : T(g);
                  }),
                  (m.prototype.recalculateDirection = function () {
                    var g, w, T, C;
                    (0, S.isEnoughSpace)(
                      this.dropdown,
                      this.toggle || this.tagsInput,
                      "bottom",
                      this.dropdownSpace,
                      this.viewport,
                    )
                      ? (this.dropdown.classList.remove("bottom-full"),
                        !(
                          (g = this.dropdownDirectionClasses) === null ||
                          g === void 0
                        ) &&
                          g.bottom &&
                          this.dropdown.classList.remove(
                            this.dropdownDirectionClasses.bottom,
                          ),
                        (this.dropdown.style.marginBottom = ""),
                        this.dropdown.classList.add("top-full"),
                        !(
                          (w = this.dropdownDirectionClasses) === null ||
                          w === void 0
                        ) &&
                          w.top &&
                          this.dropdown.classList.add(
                            this.dropdownDirectionClasses.top,
                          ),
                        (this.dropdown.style.marginTop = "".concat(
                          this.dropdownSpace,
                          "px",
                        )))
                      : (this.dropdown.classList.remove("top-full"),
                        !(
                          (T = this.dropdownDirectionClasses) === null ||
                          T === void 0
                        ) &&
                          T.top &&
                          this.dropdown.classList.remove(
                            this.dropdownDirectionClasses.top,
                          ),
                        (this.dropdown.style.marginTop = ""),
                        this.dropdown.classList.add("bottom-full"),
                        !(
                          (C = this.dropdownDirectionClasses) === null ||
                          C === void 0
                        ) &&
                          C.bottom &&
                          this.dropdown.classList.add(
                            this.dropdownDirectionClasses.bottom,
                          ),
                        (this.dropdown.style.marginBottom = "".concat(
                          this.dropdownSpace,
                          "px",
                        )));
                  }),
                  (m.getInstance = function (g, w) {
                    var T = window.$hsSelectCollection.find(function (C) {
                      return (
                        C.element.el ===
                        (typeof g == "string" ? document.querySelector(g) : g)
                      );
                    });
                    return T ? (w ? T : T.element) : null;
                  }),
                  (m.autoInit = function () {
                    window.$hsSelectCollection ||
                      (window.$hsSelectCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-select]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (g) {
                          if (
                            !window.$hsSelectCollection.find(function (C) {
                              var A;
                              return (
                                ((A = C == null ? void 0 : C.element) ===
                                  null || A === void 0
                                  ? void 0
                                  : A.el) === g
                              );
                            })
                          ) {
                            var w = g.getAttribute("data-hs-select"),
                              T = w ? JSON.parse(w) : {};
                            new m(g, T);
                          }
                        }),
                      window.$hsSelectCollection &&
                        (window.addEventListener("click", function (g) {
                          var w = g.target;
                          m.closeCurrentlyOpened(w);
                        }),
                        document.addEventListener("keydown", function (g) {
                          return m.accessibility(g);
                        }));
                  }),
                  (m.close = function (g) {
                    var w = window.$hsSelectCollection.find(function (T) {
                      return (
                        T.element.el ===
                        (typeof g == "string" ? document.querySelector(g) : g)
                      );
                    });
                    w && w.element.isOpened && w.element.close();
                  }),
                  (m.closeCurrentlyOpened = function (g) {
                    if (
                      (g === void 0 && (g = null),
                      !g.closest(".hs-select.active"))
                    ) {
                      var w =
                        window.$hsSelectCollection.filter(function (T) {
                          return T.element.isOpened;
                        }) || null;
                      w &&
                        w.forEach(function (T) {
                          T.element.close();
                        });
                    }
                  }),
                  (m.accessibility = function (g) {
                    var w = window.$hsSelectCollection.find(function (T) {
                      return T.element.isOpened;
                    });
                    if (
                      w &&
                      _.SELECT_ACCESSIBILITY_KEY_SET.includes(g.code) &&
                      !g.metaKey
                    )
                      switch (
                        (console.log(w),
                        console.log("Key code:", g.code),
                        g.code)
                      ) {
                        case "Escape":
                          g.preventDefault(), this.onEscape();
                          break;
                        case "ArrowUp":
                          g.preventDefault(), this.onArrow();
                          break;
                        case "ArrowDown":
                          g.preventDefault(), this.onArrow(!1);
                          break;
                        case "Tab":
                          g.preventDefault(), this.onTab(g.shiftKey);
                          break;
                        case "Home":
                          g.preventDefault(), this.onStartEnd();
                          break;
                        case "End":
                          g.preventDefault(), this.onStartEnd(!1);
                          break;
                        case "Enter":
                          g.preventDefault(), this.onEnter(g);
                      }
                  }),
                  (m.onEscape = function () {
                    var g = window.$hsSelectCollection.find(function (w) {
                      return w.element.isOpened;
                    });
                    g && g.element.close();
                  }),
                  (m.onArrow = function (g) {
                    g === void 0 && (g = !0);
                    var w = window.$hsSelectCollection.find(function (N) {
                      return N.element.isOpened;
                    });
                    if (w) {
                      var T = w.element.dropdown;
                      if (!T) return !1;
                      var C = (
                          g
                            ? Array.from(
                                T.querySelectorAll(":scope > *:not(.hidden)"),
                              ).reverse()
                            : Array.from(
                                T.querySelectorAll(":scope > *:not(.hidden)"),
                              )
                        ).filter(function (N) {
                          return !N.classList.contains("disabled");
                        }),
                        A = T.querySelector(".hs-select-option-highlighted");
                      A || C[0].classList.add("hs-select-option-highlighted");
                      var L = C.findIndex(function (N) {
                        return N === A;
                      });
                      L + 1 < C.length && L++,
                        C[L].focus(),
                        A && A.classList.remove("hs-select-option-highlighted"),
                        C[L].classList.add("hs-select-option-highlighted");
                    }
                  }),
                  (m.onTab = function (g) {
                    g === void 0 && (g = !0);
                    var w = window.$hsSelectCollection.find(function (N) {
                      return N.element.isOpened;
                    });
                    if (w) {
                      var T = w.element.dropdown;
                      if (!T) return !1;
                      var C = (
                          g
                            ? Array.from(
                                T.querySelectorAll(":scope >  *:not(.hidden)"),
                              ).reverse()
                            : Array.from(
                                T.querySelectorAll(":scope >  *:not(.hidden)"),
                              )
                        ).filter(function (N) {
                          return !N.classList.contains("disabled");
                        }),
                        A = T.querySelector(".hs-select-option-highlighted");
                      A || C[0].classList.add("hs-select-option-highlighted");
                      var L = C.findIndex(function (N) {
                        return N === A;
                      });
                      if (!(L + 1 < C.length))
                        return (
                          A &&
                            A.classList.remove("hs-select-option-highlighted"),
                          w.element.close(),
                          w.element.toggle.focus(),
                          !1
                        );
                      C[++L].focus(),
                        A && A.classList.remove("hs-select-option-highlighted"),
                        C[L].classList.add("hs-select-option-highlighted");
                    }
                  }),
                  (m.onStartEnd = function (g) {
                    g === void 0 && (g = !0);
                    var w = window.$hsSelectCollection.find(function (L) {
                      return L.element.isOpened;
                    });
                    if (w) {
                      var T = w.element.dropdown;
                      if (!T) return !1;
                      var C = (
                          g
                            ? Array.from(
                                T.querySelectorAll(":scope >  *:not(.hidden)"),
                              )
                            : Array.from(
                                T.querySelectorAll(":scope >  *:not(.hidden)"),
                              ).reverse()
                        ).filter(function (L) {
                          return !L.classList.contains("disabled");
                        }),
                        A = T.querySelector(".hs-select-option-highlighted");
                      C.length &&
                        (C[0].focus(),
                        A && A.classList.remove("hs-select-option-highlighted"),
                        C[0].classList.add("hs-select-option-highlighted"));
                    }
                  }),
                  (m.onEnter = function (g) {
                    var w = g.target.previousSibling;
                    if (
                      window.$hsSelectCollection.find(function (A) {
                        return A.element.el === w;
                      })
                    ) {
                      var T = window.$hsSelectCollection.find(function (A) {
                          return A.element.isOpened;
                        }),
                        C = window.$hsSelectCollection.find(function (A) {
                          return A.element.el === w;
                        });
                      T.element.close(), C.element.open();
                    } else
                      (C = window.$hsSelectCollection.find(function (A) {
                        return A.element.isOpened;
                      })) &&
                        C.element.onSelectOption(g.target.dataset.value || "");
                  }),
                  m
                );
              })(x.default);
            window.addEventListener("load", function () {
              f.autoInit();
            }),
              document.addEventListener("scroll", function () {
                if (!window.$hsSelectCollection) return !1;
                var d = window.$hsSelectCollection.find(function (m) {
                  return m.element.isOpened;
                });
                d && d.element.recalculateDirection();
              }),
              typeof window < "u" && (window.HSSelect = f),
              (a.default = f);
          },
          957: function (o, a, u) {
            /*
             * HSStepper
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this,
                    g = f.getAttribute("data-hs-stepper"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d);
                  return (
                    (m.currentIndex =
                      (T == null ? void 0 : T.currentIndex) || 1),
                    (m.mode = (T == null ? void 0 : T.mode) || "linear"),
                    (m.isCompleted =
                      (T == null ? void 0 : T.isCompleted) !== void 0 &&
                      (T == null ? void 0 : T.isCompleted)),
                    (m.totalSteps = 1),
                    (m.navItems = []),
                    (m.contentItems = []),
                    m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    this.createCollection(window.$hsStepperCollection, this),
                      this.buildNav(),
                      this.buildContent(),
                      this.buildButtons(),
                      this.setTotalSteps();
                  }),
                  (_.prototype.getUncompletedSteps = function (f) {
                    return (
                      f === void 0 && (f = !1),
                      this.navItems.filter(function (d) {
                        var m = d.isCompleted,
                          g = d.isSkip;
                        return f ? !m || g : !m && !g;
                      })
                    );
                  }),
                  (_.prototype.setTotalSteps = function () {
                    var f = this;
                    this.navItems.forEach(function (d) {
                      var m = d.index;
                      m > f.totalSteps && (f.totalSteps = m);
                    });
                  }),
                  (_.prototype.buildNav = function () {
                    var f = this;
                    this.el
                      .querySelectorAll("[data-hs-stepper-nav-item]")
                      .forEach(function (d) {
                        return f.addNavItem(d);
                      }),
                      this.navItems.forEach(function (d) {
                        return f.buildNavItem(d);
                      });
                  }),
                  (_.prototype.buildNavItem = function (f) {
                    var d = this,
                      m = f.index,
                      g = f.isDisabled,
                      w = f.el;
                    m === this.currentIndex && this.setCurrentNavItem(),
                      (this.mode !== "linear" || g) &&
                        w.addEventListener("click", function () {
                          return d.handleNavItemClick(f);
                        });
                  }),
                  (_.prototype.addNavItem = function (f) {
                    var d = JSON.parse(
                        f.getAttribute("data-hs-stepper-nav-item"),
                      ),
                      m = d.index,
                      g = d.isFinal,
                      w = g !== void 0 && g,
                      T = d.isCompleted,
                      C = T !== void 0 && T,
                      A = d.isSkip,
                      L = A !== void 0 && A,
                      N = d.isOptional,
                      P = N !== void 0 && N,
                      I = d.isDisabled,
                      Q = I !== void 0 && I,
                      ue = d.isProcessed,
                      F = ue !== void 0 && ue,
                      X = d.hasError,
                      G = X !== void 0 && X;
                    C && f.classList.add("success"),
                      L && f.classList.add("skipped"),
                      Q &&
                        ((f.tagName !== "BUTTON" && f.tagName !== "INPUT") ||
                          f.setAttribute("disabled", "disabled"),
                        f.classList.add("disabled")),
                      G && f.classList.add("error"),
                      this.navItems.push({
                        index: m,
                        isFinal: w,
                        isCompleted: C,
                        isSkip: L,
                        isOptional: P,
                        isDisabled: Q,
                        isProcessed: F,
                        hasError: G,
                        el: f,
                      });
                  }),
                  (_.prototype.setCurrentNavItem = function () {
                    var f = this;
                    this.navItems.forEach(function (d) {
                      var m = d.index,
                        g = d.el;
                      m === f.currentIndex
                        ? f.setCurrentNavItemActions(g)
                        : f.unsetCurrentNavItemActions(g);
                    });
                  }),
                  (_.prototype.setCurrentNavItemActions = function (f) {
                    f.classList.add("active"),
                      this.fireEvent("active", this.currentIndex),
                      (0, y.dispatch)(
                        "active.hs.stepper",
                        this.el,
                        this.currentIndex,
                      );
                  }),
                  (_.prototype.getNavItem = function (f) {
                    return (
                      f === void 0 && (f = this.currentIndex),
                      this.navItems.find(function (d) {
                        return d.index === f;
                      })
                    );
                  }),
                  (_.prototype.setProcessedNavItemActions = function (f) {
                    (f.isProcessed = !0), f.el.classList.add("processed");
                  }),
                  (_.prototype.setErrorNavItemActions = function (f) {
                    (f.hasError = !0), f.el.classList.add("error");
                  }),
                  (_.prototype.unsetCurrentNavItemActions = function (f) {
                    f.classList.remove("active");
                  }),
                  (_.prototype.handleNavItemClick = function (f) {
                    var d = f.index;
                    (this.currentIndex = d),
                      this.setCurrentNavItem(),
                      this.setCurrentContentItem(),
                      this.checkForTheFirstStep();
                  }),
                  (_.prototype.buildContent = function () {
                    var f = this;
                    this.el
                      .querySelectorAll("[data-hs-stepper-content-item]")
                      .forEach(function (d) {
                        return f.addContentItem(d);
                      }),
                      this.navItems.forEach(function (d) {
                        return f.buildContentItem(d);
                      });
                  }),
                  (_.prototype.buildContentItem = function (f) {
                    f.index === this.currentIndex &&
                      this.setCurrentContentItem();
                  }),
                  (_.prototype.addContentItem = function (f) {
                    var d = JSON.parse(
                        f.getAttribute("data-hs-stepper-content-item"),
                      ),
                      m = d.index,
                      g = d.isFinal,
                      w = g !== void 0 && g,
                      T = d.isCompleted,
                      C = T !== void 0 && T,
                      A = d.isSkip,
                      L = A !== void 0 && A;
                    C && f.classList.add("success"),
                      L && f.classList.add("skipped"),
                      this.contentItems.push({
                        index: m,
                        isFinal: w,
                        isCompleted: C,
                        isSkip: L,
                        el: f,
                      });
                  }),
                  (_.prototype.setCurrentContentItem = function () {
                    var f = this;
                    if (this.isCompleted) {
                      var d = this.contentItems.find(function (g) {
                          return g.isFinal;
                        }),
                        m = this.contentItems.filter(function (g) {
                          return !g.isFinal;
                        });
                      return (
                        (d.el.style.display = ""),
                        m.forEach(function (g) {
                          return (g.el.style.display = "none");
                        }),
                        !1
                      );
                    }
                    this.contentItems.forEach(function (g) {
                      var w = g.index,
                        T = g.el;
                      w === f.currentIndex
                        ? f.setCurrentContentItemActions(T)
                        : f.unsetCurrentContentItemActions(T);
                    });
                  }),
                  (_.prototype.hideAllContentItems = function () {
                    this.contentItems.forEach(function (f) {
                      return (f.el.style.display = "none");
                    });
                  }),
                  (_.prototype.setCurrentContentItemActions = function (f) {
                    f.style.display = "";
                  }),
                  (_.prototype.unsetCurrentContentItemActions = function (f) {
                    f.style.display = "none";
                  }),
                  (_.prototype.disableAll = function () {
                    var f = this.getNavItem(this.currentIndex);
                    (f.hasError = !1),
                      (f.isCompleted = !1),
                      (f.isDisabled = !1),
                      f.el.classList.remove("error", "success"),
                      this.disableButtons();
                  }),
                  (_.prototype.disableNavItemActions = function (f) {
                    (f.isDisabled = !0), f.el.classList.add("disabled");
                  }),
                  (_.prototype.enableNavItemActions = function (f) {
                    (f.isDisabled = !1), f.el.classList.remove("disabled");
                  }),
                  (_.prototype.buildButtons = function () {
                    (this.backBtn = this.el.querySelector(
                      "[data-hs-stepper-back-btn]",
                    )),
                      (this.nextBtn = this.el.querySelector(
                        "[data-hs-stepper-next-btn]",
                      )),
                      (this.skipBtn = this.el.querySelector(
                        "[data-hs-stepper-skip-btn]",
                      )),
                      (this.completeStepBtn = this.el.querySelector(
                        "[data-hs-stepper-complete-step-btn]",
                      )),
                      (this.finishBtn = this.el.querySelector(
                        "[data-hs-stepper-finish-btn]",
                      )),
                      (this.resetBtn = this.el.querySelector(
                        "[data-hs-stepper-reset-btn]",
                      )),
                      this.buildBackButton(),
                      this.buildNextButton(),
                      this.buildSkipButton(),
                      this.buildCompleteStepButton(),
                      this.buildFinishButton(),
                      this.buildResetButton();
                  }),
                  (_.prototype.buildBackButton = function () {
                    var f = this;
                    this.backBtn &&
                      (this.checkForTheFirstStep(),
                      this.backBtn.addEventListener("click", function () {
                        if ((f.handleBackButtonClick(), f.mode === "linear")) {
                          var d = f.navItems.find(function (g) {
                              return g.index === f.currentIndex;
                            }),
                            m = f.contentItems.find(function (g) {
                              return g.index === f.currentIndex;
                            });
                          if (!d || !m) return;
                          d.isCompleted &&
                            ((d.isCompleted = !1),
                            (d.isSkip = !1),
                            d.el.classList.remove("success", "skipped")),
                            m.isCompleted &&
                              ((m.isCompleted = !1),
                              (m.isSkip = !1),
                              m.el.classList.remove("success", "skipped")),
                            f.mode === "linear" &&
                              f.currentIndex !== f.totalSteps &&
                              (f.nextBtn && (f.nextBtn.style.display = ""),
                              f.completeStepBtn &&
                                (f.completeStepBtn.style.display = "")),
                            f.showSkipButton(),
                            f.showFinishButton(),
                            f.showCompleteStepButton();
                        }
                      }));
                  }),
                  (_.prototype.handleBackButtonClick = function () {
                    this.currentIndex !== 1 &&
                      (this.mode === "linear" && this.removeOptionalClasses(),
                      this.currentIndex--,
                      this.mode === "linear" && this.removeOptionalClasses(),
                      this.setCurrentNavItem(),
                      this.setCurrentContentItem(),
                      this.checkForTheFirstStep(),
                      this.completeStepBtn &&
                        this.changeTextAndDisableCompleteButtonIfStepCompleted(),
                      this.fireEvent("back", this.currentIndex),
                      (0, y.dispatch)(
                        "back.hs.stepper",
                        this.el,
                        this.currentIndex,
                      ));
                  }),
                  (_.prototype.checkForTheFirstStep = function () {
                    this.currentIndex === 1
                      ? this.setToDisabled(this.backBtn)
                      : this.setToNonDisabled(this.backBtn);
                  }),
                  (_.prototype.setToDisabled = function (f) {
                    (f.tagName !== "BUTTON" && f.tagName !== "INPUT") ||
                      f.setAttribute("disabled", "disabled"),
                      f.classList.add("disabled");
                  }),
                  (_.prototype.setToNonDisabled = function (f) {
                    (f.tagName !== "BUTTON" && f.tagName !== "INPUT") ||
                      f.removeAttribute("disabled"),
                      f.classList.remove("disabled");
                  }),
                  (_.prototype.buildNextButton = function () {
                    var f = this;
                    this.nextBtn &&
                      this.nextBtn.addEventListener("click", function () {
                        var d;
                        if (
                          (f.fireEvent("beforeNext", f.currentIndex),
                          (0, y.dispatch)(
                            "beforeNext.hs.stepper",
                            f.el,
                            f.currentIndex,
                          ),
                          (d = f.getNavItem(f.currentIndex)) === null ||
                          d === void 0
                            ? void 0
                            : d.isProcessed)
                        )
                          return f.disableAll(), !1;
                        f.goToNext();
                      });
                  }),
                  (_.prototype.unsetProcessedNavItemActions = function (f) {
                    (f.isProcessed = !1), f.el.classList.remove("processed");
                  }),
                  (_.prototype.handleNextButtonClick = function (f) {
                    if ((f === void 0 && (f = !0), f))
                      this.currentIndex === this.totalSteps
                        ? (this.currentIndex = 1)
                        : this.currentIndex++;
                    else {
                      var d = this.getUncompletedSteps();
                      if (d.length === 1) {
                        var m = d[0].index;
                        this.currentIndex = m;
                      } else {
                        if (this.currentIndex === this.totalSteps) return;
                        this.currentIndex++;
                      }
                    }
                    this.mode === "linear" && this.removeOptionalClasses(),
                      this.setCurrentNavItem(),
                      this.setCurrentContentItem(),
                      this.checkForTheFirstStep(),
                      this.completeStepBtn &&
                        this.changeTextAndDisableCompleteButtonIfStepCompleted(),
                      this.showSkipButton(),
                      this.showFinishButton(),
                      this.showCompleteStepButton(),
                      this.fireEvent("next", this.currentIndex),
                      (0, y.dispatch)(
                        "next.hs.stepper",
                        this.el,
                        this.currentIndex,
                      );
                  }),
                  (_.prototype.removeOptionalClasses = function () {
                    var f = this,
                      d = this.navItems.find(function (g) {
                        return g.index === f.currentIndex;
                      }),
                      m = this.contentItems.find(function (g) {
                        return g.index === f.currentIndex;
                      });
                    (d.isSkip = !1),
                      (d.hasError = !1),
                      (d.isDisabled = !1),
                      (m.isSkip = !1),
                      d.el.classList.remove("skipped", "success", "error"),
                      m.el.classList.remove("skipped", "success", "error");
                  }),
                  (_.prototype.buildSkipButton = function () {
                    var f = this;
                    this.skipBtn &&
                      (this.showSkipButton(),
                      this.skipBtn.addEventListener("click", function () {
                        f.handleSkipButtonClick(),
                          f.mode === "linear" &&
                            f.currentIndex === f.totalSteps &&
                            (f.nextBtn && (f.nextBtn.style.display = "none"),
                            f.completeStepBtn &&
                              (f.completeStepBtn.style.display = "none"),
                            f.finishBtn && (f.finishBtn.style.display = ""));
                      }));
                  }),
                  (_.prototype.setSkipItem = function (f) {
                    var d = this,
                      m = this.navItems.find(function (w) {
                        return w.index === (f || d.currentIndex);
                      }),
                      g = this.contentItems.find(function (w) {
                        return w.index === (f || d.currentIndex);
                      });
                    m &&
                      g &&
                      (this.setSkipItemActions(m), this.setSkipItemActions(g));
                  }),
                  (_.prototype.setSkipItemActions = function (f) {
                    (f.isSkip = !0), f.el.classList.add("skipped");
                  }),
                  (_.prototype.showSkipButton = function () {
                    var f = this;
                    if (this.skipBtn) {
                      var d = this.navItems.find(function (m) {
                        return m.index === f.currentIndex;
                      }).isOptional;
                      this.skipBtn.style.display = d ? "" : "none";
                    }
                  }),
                  (_.prototype.handleSkipButtonClick = function () {
                    this.setSkipItem(),
                      this.handleNextButtonClick(),
                      this.fireEvent("skip", this.currentIndex),
                      (0, y.dispatch)(
                        "skip.hs.stepper",
                        this.el,
                        this.currentIndex,
                      );
                  }),
                  (_.prototype.buildCompleteStepButton = function () {
                    var f = this;
                    this.completeStepBtn &&
                      ((this.completeStepBtnDefaultText =
                        this.completeStepBtn.innerText),
                      this.completeStepBtn.addEventListener(
                        "click",
                        function () {
                          return f.handleCompleteStepButtonClick();
                        },
                      ));
                  }),
                  (_.prototype.changeTextAndDisableCompleteButtonIfStepCompleted =
                    function () {
                      var f = this,
                        d = this.navItems.find(function (g) {
                          return g.index === f.currentIndex;
                        }),
                        m = JSON.parse(
                          this.completeStepBtn.getAttribute(
                            "data-hs-stepper-complete-step-btn",
                          ),
                        ).completedText;
                      d &&
                        (d.isCompleted
                          ? ((this.completeStepBtn.innerText =
                              m || this.completeStepBtnDefaultText),
                            this.completeStepBtn.setAttribute(
                              "disabled",
                              "disabled",
                            ),
                            this.completeStepBtn.classList.add("disabled"))
                          : ((this.completeStepBtn.innerText =
                              this.completeStepBtnDefaultText),
                            this.completeStepBtn.removeAttribute("disabled"),
                            this.completeStepBtn.classList.remove("disabled")));
                    }),
                  (_.prototype.setCompleteItem = function (f) {
                    var d = this,
                      m = this.navItems.find(function (w) {
                        return w.index === (f || d.currentIndex);
                      }),
                      g = this.contentItems.find(function (w) {
                        return w.index === (f || d.currentIndex);
                      });
                    m &&
                      g &&
                      (this.setCompleteItemActions(m),
                      this.setCompleteItemActions(g));
                  }),
                  (_.prototype.setCompleteItemActions = function (f) {
                    (f.isCompleted = !0), f.el.classList.add("success");
                  }),
                  (_.prototype.showCompleteStepButton = function () {
                    this.completeStepBtn &&
                      (this.getUncompletedSteps().length === 1
                        ? (this.completeStepBtn.style.display = "none")
                        : (this.completeStepBtn.style.display = ""));
                  }),
                  (_.prototype.handleCompleteStepButtonClick = function () {
                    this.setCompleteItem(),
                      this.fireEvent("complete", this.currentIndex),
                      (0, y.dispatch)(
                        "complete.hs.stepper",
                        this.el,
                        this.currentIndex,
                      ),
                      this.handleNextButtonClick(!1),
                      this.showFinishButton(),
                      this.showCompleteStepButton(),
                      this.checkForTheFirstStep(),
                      this.completeStepBtn &&
                        this.changeTextAndDisableCompleteButtonIfStepCompleted(),
                      this.showSkipButton();
                  }),
                  (_.prototype.buildFinishButton = function () {
                    var f = this;
                    this.finishBtn &&
                      (this.isCompleted && this.setCompleted(),
                      this.finishBtn.addEventListener("click", function () {
                        return f.handleFinishButtonClick();
                      }));
                  }),
                  (_.prototype.setCompleted = function () {
                    this.el.classList.add("completed");
                  }),
                  (_.prototype.unsetCompleted = function () {
                    this.el.classList.remove("completed");
                  }),
                  (_.prototype.showFinishButton = function () {
                    this.finishBtn &&
                      (this.getUncompletedSteps().length === 1
                        ? (this.finishBtn.style.display = "")
                        : (this.finishBtn.style.display = "none"));
                  }),
                  (_.prototype.handleFinishButtonClick = function () {
                    var f = this,
                      d = this.getUncompletedSteps(),
                      m = this.getUncompletedSteps(!0),
                      g = this.contentItems.find(function (T) {
                        return T.isFinal;
                      }).el;
                    d.length &&
                      d.forEach(function (T) {
                        var C = T.index;
                        return f.setCompleteItem(C);
                      }),
                      (this.currentIndex = this.totalSteps),
                      this.setCurrentNavItem(),
                      this.hideAllContentItems();
                    var w = this.navItems.find(function (T) {
                      return T.index === f.currentIndex;
                    });
                    (w ? w.el : null).classList.remove("active"),
                      (g.style.display = "block"),
                      this.backBtn && (this.backBtn.style.display = "none"),
                      this.nextBtn && (this.nextBtn.style.display = "none"),
                      this.skipBtn && (this.skipBtn.style.display = "none"),
                      this.completeStepBtn &&
                        (this.completeStepBtn.style.display = "none"),
                      this.finishBtn && (this.finishBtn.style.display = "none"),
                      this.resetBtn && (this.resetBtn.style.display = ""),
                      m.length <= 1 &&
                        ((this.isCompleted = !0), this.setCompleted()),
                      this.fireEvent("finish", this.currentIndex),
                      (0, y.dispatch)(
                        "finish.hs.stepper",
                        this.el,
                        this.currentIndex,
                      );
                  }),
                  (_.prototype.buildResetButton = function () {
                    var f = this;
                    this.resetBtn &&
                      this.resetBtn.addEventListener("click", function () {
                        return f.handleResetButtonClick();
                      });
                  }),
                  (_.prototype.handleResetButtonClick = function () {
                    var f = this;
                    this.backBtn && (this.backBtn.style.display = ""),
                      this.nextBtn && (this.nextBtn.style.display = ""),
                      this.completeStepBtn &&
                        ((this.completeStepBtn.style.display = ""),
                        (this.completeStepBtn.innerText =
                          this.completeStepBtnDefaultText),
                        this.completeStepBtn.removeAttribute("disabled"),
                        this.completeStepBtn.classList.remove("disabled")),
                      this.resetBtn && (this.resetBtn.style.display = "none"),
                      this.navItems.forEach(function (d) {
                        var m = d.el;
                        (d.isSkip = !1),
                          (d.isCompleted = !1),
                          f.unsetCurrentNavItemActions(m),
                          m.classList.remove("success", "skipped");
                      }),
                      this.contentItems.forEach(function (d) {
                        var m = d.el;
                        (d.isSkip = !1),
                          (d.isCompleted = !1),
                          f.unsetCurrentContentItemActions(m),
                          m.classList.remove("success", "skipped");
                      }),
                      (this.currentIndex = 1),
                      this.setCurrentNavItem(),
                      this.setCurrentContentItem(),
                      this.showFinishButton(),
                      this.showCompleteStepButton(),
                      this.checkForTheFirstStep(),
                      this.unsetCompleted(),
                      (this.isCompleted = !1),
                      this.fireEvent("reset", this.currentIndex),
                      (0, y.dispatch)(
                        "reset.hs.stepper",
                        this.el,
                        this.currentIndex,
                      );
                  }),
                  (_.prototype.setProcessedNavItem = function (f) {
                    var d = this.getNavItem(f);
                    d && this.setProcessedNavItemActions(d);
                  }),
                  (_.prototype.unsetProcessedNavItem = function (f) {
                    var d = this.getNavItem(f);
                    d && this.unsetProcessedNavItemActions(d);
                  }),
                  (_.prototype.goToNext = function () {
                    this.mode === "linear" && this.setCompleteItem(),
                      this.handleNextButtonClick(this.mode !== "linear"),
                      this.mode === "linear" &&
                        this.currentIndex === this.totalSteps &&
                        (this.nextBtn && (this.nextBtn.style.display = "none"),
                        this.completeStepBtn &&
                          (this.completeStepBtn.style.display = "none"));
                  }),
                  (_.prototype.disableButtons = function () {
                    this.backBtn && this.setToDisabled(this.backBtn),
                      this.nextBtn && this.setToDisabled(this.nextBtn);
                  }),
                  (_.prototype.enableButtons = function () {
                    this.backBtn && this.setToNonDisabled(this.backBtn),
                      this.nextBtn && this.setToNonDisabled(this.nextBtn);
                  }),
                  (_.prototype.setErrorNavItem = function (f) {
                    var d = this.getNavItem(f);
                    d && this.setErrorNavItemActions(d);
                  }),
                  (_.getInstance = function (f, d) {
                    var m = window.$hsStepperCollection.find(function (g) {
                      return (
                        g.element.el ===
                        (typeof f == "string" ? document.querySelector(f) : f)
                      );
                    });
                    return m ? (d ? m : m.element) : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsStepperCollection ||
                      (window.$hsStepperCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-stepper]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          window.$hsStepperCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === f
                            );
                          }) || new _(f);
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSStepper = S),
              (a.default = S);
          },
          983: function (o, a, u) {
            /*
             * HSStrongPassword
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this;
                  (m.isOpened = !1),
                    (m.strength = 0),
                    (m.passedRules = new Set());
                  var g = f.getAttribute("data-hs-strong-password"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d);
                  return (
                    (m.target =
                      T != null && T.target
                        ? typeof (T == null ? void 0 : T.target) == "string"
                          ? document.querySelector(T.target)
                          : T.target
                        : null),
                    (m.hints =
                      T != null && T.hints
                        ? typeof (T == null ? void 0 : T.hints) == "string"
                          ? document.querySelector(T.hints)
                          : T.hints
                        : null),
                    (m.stripClasses =
                      (T == null ? void 0 : T.stripClasses) || null),
                    (m.minLength = (T == null ? void 0 : T.minLength) || 6),
                    (m.mode = (T == null ? void 0 : T.mode) || "default"),
                    (m.popoverSpace =
                      (T == null ? void 0 : T.popoverSpace) || 10),
                    (m.checksExclude =
                      (T == null ? void 0 : T.checksExclude) || []),
                    (m.availableChecks = [
                      "lowercase",
                      "uppercase",
                      "numbers",
                      "special-characters",
                      "min-length",
                    ].filter(function (C) {
                      return !m.checksExclude.includes(C);
                    })),
                    (m.specialCharactersSet =
                      (T == null ? void 0 : T.specialCharactersSet) ||
                      "!\"#$%&'()*+,-./:;<=>?@[\\\\\\]^_`{|}~"),
                    m.target && m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    this.createCollection(
                      window.$hsStrongPasswordCollection,
                      this,
                    ),
                      this.availableChecks.length && this.build();
                  }),
                  (_.prototype.build = function () {
                    var f = this;
                    this.buildStrips(),
                      this.hints && this.buildHints(),
                      this.setStrength(this.target.value),
                      this.target.addEventListener("input", function (d) {
                        f.setStrength(d.target.value);
                      });
                  }),
                  (_.prototype.buildStrips = function () {
                    if (((this.el.innerHTML = ""), this.stripClasses))
                      for (var f = 0; f < this.availableChecks.length; f++) {
                        var d = (0, y.htmlToElement)("<div></div>");
                        (0, y.classToClassList)(this.stripClasses, d),
                          this.el.append(d);
                      }
                  }),
                  (_.prototype.buildHints = function () {
                    var f = this;
                    (this.weakness =
                      this.hints.querySelector(
                        "[data-hs-strong-password-hints-weakness-text]",
                      ) || null),
                      (this.rules =
                        Array.from(
                          this.hints.querySelectorAll(
                            "[data-hs-strong-password-hints-rule-text]",
                          ),
                        ) || null),
                      this.rules.forEach(function (d) {
                        var m,
                          g = d.getAttribute(
                            "data-hs-strong-password-hints-rule-text",
                          );
                        !((m = f.checksExclude) === null || m === void 0) &&
                          m.includes(g) &&
                          d.remove();
                      }),
                      this.weakness && this.buildWeakness(),
                      this.rules && this.buildRules(),
                      this.mode === "popover" &&
                        (this.target.addEventListener("focus", function () {
                          (f.isOpened = !0),
                            f.hints.classList.remove("hidden"),
                            f.hints.classList.add("block"),
                            f.recalculateDirection();
                        }),
                        this.target.addEventListener("blur", function () {
                          (f.isOpened = !1),
                            f.hints.classList.remove(
                              "block",
                              "bottom-full",
                              "top-full",
                            ),
                            f.hints.classList.add("hidden"),
                            (f.hints.style.marginTop = ""),
                            (f.hints.style.marginBottom = "");
                        }));
                  }),
                  (_.prototype.buildWeakness = function () {
                    var f = this;
                    this.checkStrength(this.target.value),
                      this.setWeaknessText(),
                      this.target.addEventListener("input", function () {
                        return setTimeout(function () {
                          return f.setWeaknessText();
                        });
                      });
                  }),
                  (_.prototype.buildRules = function () {
                    var f = this;
                    this.setRulesText(),
                      this.target.addEventListener("input", function () {
                        return setTimeout(function () {
                          return f.setRulesText();
                        });
                      });
                  }),
                  (_.prototype.setWeaknessText = function () {
                    var f = this.weakness.getAttribute(
                        "data-hs-strong-password-hints-weakness-text",
                      ),
                      d = JSON.parse(f);
                    this.weakness.textContent = d[this.strength];
                  }),
                  (_.prototype.setRulesText = function () {
                    var f = this;
                    this.rules.forEach(function (d) {
                      var m = d.getAttribute(
                        "data-hs-strong-password-hints-rule-text",
                      );
                      f.checkIfPassed(d, f.passedRules.has(m));
                    });
                  }),
                  (_.prototype.togglePopover = function () {
                    var f = this.el.querySelector(".popover");
                    f && f.classList.toggle("show");
                  }),
                  (_.prototype.checkStrength = function (f) {
                    var d = new Set(),
                      m = {
                        lowercase: /[a-z]+/,
                        uppercase: /[A-Z]+/,
                        numbers: /[0-9]+/,
                        "special-characters": new RegExp(
                          "[".concat(this.specialCharactersSet, "]"),
                        ),
                      },
                      g = 0;
                    return (
                      this.availableChecks.includes("lowercase") &&
                        f.match(m.lowercase) &&
                        ((g += 1), d.add("lowercase")),
                      this.availableChecks.includes("uppercase") &&
                        f.match(m.uppercase) &&
                        ((g += 1), d.add("uppercase")),
                      this.availableChecks.includes("numbers") &&
                        f.match(m.numbers) &&
                        ((g += 1), d.add("numbers")),
                      this.availableChecks.includes("special-characters") &&
                        f.match(m["special-characters"]) &&
                        ((g += 1), d.add("special-characters")),
                      this.availableChecks.includes("min-length") &&
                        f.length >= this.minLength &&
                        ((g += 1), d.add("min-length")),
                      f.length || (g = 0),
                      g === this.availableChecks.length
                        ? this.el.classList.add("accepted")
                        : this.el.classList.remove("accepted"),
                      (this.strength = g),
                      (this.passedRules = d),
                      { strength: this.strength, rules: this.passedRules }
                    );
                  }),
                  (_.prototype.checkIfPassed = function (f, d) {
                    d === void 0 && (d = !1);
                    var m = f.querySelector("[data-check]"),
                      g = f.querySelector("[data-uncheck]");
                    d
                      ? (f.classList.add("active"),
                        m.classList.remove("hidden"),
                        g.classList.add("hidden"))
                      : (f.classList.remove("active"),
                        m.classList.add("hidden"),
                        g.classList.remove("hidden"));
                  }),
                  (_.prototype.setStrength = function (f) {
                    var d = this.checkStrength(f),
                      m = d.strength,
                      g = { strength: m, rules: d.rules };
                    this.hideStrips(m),
                      this.fireEvent("change", g),
                      (0, y.dispatch)("change.hs.strongPassword", this.el, g);
                  }),
                  (_.prototype.hideStrips = function (f) {
                    Array.from(this.el.children).forEach(function (d, m) {
                      m < f
                        ? d.classList.add("passed")
                        : d.classList.remove("passed");
                    });
                  }),
                  (_.prototype.recalculateDirection = function () {
                    (0, y.isEnoughSpace)(
                      this.hints,
                      this.target,
                      "bottom",
                      this.popoverSpace,
                    )
                      ? (this.hints.classList.remove("bottom-full"),
                        this.hints.classList.add("top-full"),
                        (this.hints.style.marginBottom = ""),
                        (this.hints.style.marginTop = "".concat(
                          this.popoverSpace,
                          "px",
                        )))
                      : (this.hints.classList.remove("top-full"),
                        this.hints.classList.add("bottom-full"),
                        (this.hints.style.marginTop = ""),
                        (this.hints.style.marginBottom = "".concat(
                          this.popoverSpace,
                          "px",
                        )));
                  }),
                  (_.getInstance = function (f) {
                    var d = window.$hsStrongPasswordCollection.find(
                      function (m) {
                        return (
                          m.element.el ===
                          (typeof f == "string" ? document.querySelector(f) : f)
                        );
                      },
                    );
                    return d ? d.element : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsStrongPasswordCollection ||
                      (window.$hsStrongPasswordCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-strong-password]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          if (
                            !window.$hsStrongPasswordCollection.find(
                              function (g) {
                                var w;
                                return (
                                  ((w = g == null ? void 0 : g.element) ===
                                    null || w === void 0
                                    ? void 0
                                    : w.el) === f
                                );
                              },
                            )
                          ) {
                            var d = f.getAttribute("data-hs-strong-password"),
                              m = d ? JSON.parse(d) : {};
                            new _(f, m);
                          }
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              document.addEventListener("scroll", function () {
                if (!window.$hsStrongPasswordCollection) return !1;
                var x = window.$hsStrongPasswordCollection.find(function (_) {
                  return _.element.isOpened;
                });
                x && x.element.recalculateDirection();
              }),
              typeof window < "u" && (window.HSStrongPassword = S),
              (a.default = S);
          },
          949: function (o, a, u) {
            /*
             * HSTabs
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (_, f) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (d, m) {
                          d.__proto__ = m;
                        }) ||
                      function (d, m) {
                        for (var g in m)
                          Object.prototype.hasOwnProperty.call(m, g) &&
                            (d[g] = m[g]);
                      }),
                    h(_, f)
                  );
                }),
                function (_, f) {
                  if (typeof f != "function" && f !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(f) +
                        " is not a constructor or null",
                    );
                  function d() {
                    this.constructor = _;
                  }
                  h(_, f),
                    (_.prototype =
                      f === null
                        ? Object.create(f)
                        : ((d.prototype = f.prototype), new d()));
                });
            Object.defineProperty(a, "__esModule", { value: !0 });
            var v = u(969),
              y = u(737),
              S = u(190),
              x = (function (_) {
                function f(d, m, g) {
                  var w = _.call(this, d, m, g) || this;
                  return (
                    (w.toggles = w.el.querySelectorAll("[data-hs-tab]")),
                    (w.extraToggleId = w.el.getAttribute("hs-data-tab-select")),
                    (w.extraToggle = document.querySelector(w.extraToggleId)),
                    (w.current = Array.from(w.toggles).find(function (T) {
                      return T.classList.contains("active");
                    })),
                    (w.currentContentId =
                      w.current.getAttribute("data-hs-tab")),
                    (w.currentContent = document.querySelector(
                      w.currentContentId,
                    )),
                    (w.prev = null),
                    (w.prevContentId = null),
                    (w.prevContent = null),
                    w.init(),
                    w
                  );
                }
                return (
                  p(f, _),
                  (f.prototype.init = function () {
                    var d = this;
                    this.createCollection(window.$hsTabsCollection, this),
                      this.toggles.forEach(function (m) {
                        m.addEventListener("click", function () {
                          return d.open(m);
                        });
                      }),
                      this.extraToggle &&
                        this.extraToggle.addEventListener(
                          "change",
                          function (m) {
                            return d.change(m);
                          },
                        );
                  }),
                  (f.prototype.open = function (d) {
                    (this.prev = this.current),
                      (this.prevContentId = this.currentContentId),
                      (this.prevContent = this.currentContent),
                      (this.current = d),
                      (this.currentContentId =
                        this.current.getAttribute("data-hs-tab")),
                      (this.currentContent = document.querySelector(
                        this.currentContentId,
                      )),
                      this.prev.classList.remove("active"),
                      this.prevContent.classList.add("hidden"),
                      this.current.classList.add("active"),
                      this.currentContent.classList.remove("hidden"),
                      this.fireEvent("change", {
                        el: d,
                        prev: this.prevContentId,
                        current: this.currentContentId,
                      }),
                      (0, v.dispatch)("change.hs.tab", d, {
                        el: d,
                        prev: this.prevContentId,
                        current: this.currentContentId,
                      });
                  }),
                  (f.prototype.change = function (d) {
                    var m = document.querySelector(
                      '[data-hs-tab="'.concat(d.target.value, '"]'),
                    );
                    m && m.click();
                  }),
                  (f.getInstance = function (d, m) {
                    var g = window.$hsTabsCollection.find(function (w) {
                      return (
                        w.element.el ===
                        (typeof d == "string" ? document.querySelector(d) : d)
                      );
                    });
                    return g ? (m ? g : g.element) : null;
                  }),
                  (f.autoInit = function () {
                    window.$hsTabsCollection || (window.$hsTabsCollection = []),
                      document
                        .querySelectorAll(
                          '[role="tablist"]:not(select):not(.--prevent-on-load-init)',
                        )
                        .forEach(function (d) {
                          window.$hsTabsCollection.find(function (m) {
                            var g;
                            return (
                              ((g = m == null ? void 0 : m.element) === null ||
                              g === void 0
                                ? void 0
                                : g.el) === d
                            );
                          }) || new f(d);
                        }),
                      window.$hsTabsCollection &&
                        document.addEventListener("keydown", function (d) {
                          return f.accessibility(d);
                        });
                  }),
                  (f.open = function (d) {
                    var m = window.$hsTabsCollection.find(function (w) {
                        return Array.from(w.element.toggles).includes(
                          typeof d == "string" ? document.querySelector(d) : d,
                        );
                      }),
                      g = Array.from(m.element.toggles).find(function (w) {
                        return (
                          w ===
                          (typeof d == "string" ? document.querySelector(d) : d)
                        );
                      });
                    g && !g.classList.contains("active") && m.element.open(g);
                  }),
                  (f.accessibility = function (d) {
                    var m = document.querySelector("[data-hs-tab]:focus");
                    if (
                      m &&
                      S.TABS_ACCESSIBILITY_KEY_SET.includes(d.code) &&
                      !d.metaKey
                    ) {
                      var g = m
                        .closest('[role="tablist"]')
                        .getAttribute("data-hs-tabs-vertical");
                      switch (
                        (d.preventDefault(),
                        console.log("Key code:", d.code),
                        d.code)
                      ) {
                        case g === "true" ? "ArrowUp" : "ArrowLeft":
                          this.onArrow();
                          break;
                        case g === "true" ? "ArrowDown" : "ArrowRight":
                          this.onArrow(!1);
                          break;
                        case "Home":
                          this.onStartEnd();
                          break;
                        case "End":
                          this.onStartEnd(!1);
                      }
                    }
                  }),
                  (f.onArrow = function (d) {
                    d === void 0 && (d = !0);
                    var m = document
                        .querySelector("[data-hs-tab]:focus")
                        .closest('[role="tablist"]'),
                      g = window.$hsTabsCollection.find(function (A) {
                        return A.element.el === m;
                      });
                    if (g) {
                      var w = d
                          ? Array.from(g.element.toggles).reverse()
                          : Array.from(g.element.toggles),
                        T = w.find(function (A) {
                          return document.activeElement === A;
                        }),
                        C = w.findIndex(function (A) {
                          return A === T;
                        });
                      w[(C = C + 1 < w.length ? C + 1 : 0)].focus(),
                        w[C].click();
                    }
                  }),
                  (f.onStartEnd = function (d) {
                    d === void 0 && (d = !0);
                    var m = document
                        .querySelector("[data-hs-tab]:focus")
                        .closest('[role="tablist"]'),
                      g = window.$hsTabsCollection.find(function (T) {
                        return T.element.el === m;
                      });
                    if (g) {
                      var w = d
                        ? Array.from(g.element.toggles)
                        : Array.from(g.element.toggles).reverse();
                      w.length && (w[0].focus(), w[0].click());
                    }
                  }),
                  (f.on = function (d, m, g) {
                    var w = window.$hsTabsCollection.find(function (T) {
                      return Array.from(T.element.toggles).includes(
                        typeof m == "string" ? document.querySelector(m) : m,
                      );
                    });
                    w && (w.element.events[d] = g);
                  }),
                  f
                );
              })(y.default);
            window.addEventListener("load", function () {
              x.autoInit();
            }),
              typeof window < "u" && (window.HSTabs = x),
              (a.default = x);
          },
          557: function (o, a, u) {
            var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (S) {
                        for (var x, _ = 1, f = arguments.length; _ < f; _++)
                          for (var d in (x = arguments[_]))
                            Object.prototype.hasOwnProperty.call(x, d) &&
                              (S[d] = x[d]);
                        return S;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = (function (S) {
              function x(_, f) {
                var d = S.call(this, _, f) || this,
                  m = _.getAttribute("data-hs-theme-switch"),
                  g = m ? JSON.parse(m) : {},
                  w = v(v({}, g), f);
                return (
                  (d.theme =
                    (w == null ? void 0 : w.theme) ||
                    localStorage.getItem("hs_theme") ||
                    "default"),
                  (d.themeSet = ["dark", "light", "default"]),
                  d.init(),
                  d
                );
              }
              return (
                p(x, S),
                (x.prototype.init = function () {
                  this.createCollection(window.$hsThemeSwitchCollection, this),
                    this.theme !== "default" && this.setAppearance();
                }),
                (x.prototype.setResetStyles = function () {
                  var _ = document.createElement("style");
                  return (
                    (_.innerText = "*{transition: unset !important;}"),
                    _.setAttribute("data-hs-appearance-onload-styles", ""),
                    document.head.appendChild(_),
                    _
                  );
                }),
                (x.prototype.setAppearance = function (_, f, d) {
                  _ === void 0 && (_ = this.theme),
                    f === void 0 && (f = !0),
                    d === void 0 && (d = !0);
                  var m = this.setResetStyles(),
                    g = document.querySelector("html");
                  f && localStorage.setItem("hs_theme", _),
                    _ === "auto" &&
                      (_ = window.matchMedia("(prefers-color-scheme: dark)")
                        .matches
                        ? "dark"
                        : "default"),
                    g.classList.remove("dark", "default", "auto"),
                    g.classList.add(_),
                    setTimeout(function () {
                      return m.remove();
                    }),
                    d &&
                      window.dispatchEvent(
                        new CustomEvent("on-hs-appearance-change", {
                          detail: _,
                        }),
                      );
                }),
                (x.getInstance = function (_) {
                  var f = window.$hsThemeSwitchCollection.find(function (d) {
                    return (
                      d.element.el ===
                      (typeof _ == "string" ? document.querySelector(_) : _)
                    );
                  });
                  return f ? f.element : null;
                }),
                (x.autoInit = function () {
                  window.$hsThemeSwitchCollection ||
                    (window.$hsThemeSwitchCollection = []),
                    document
                      .querySelectorAll(
                        "[data-hs-theme-switch]:not(.--prevent-on-load-init)",
                      )
                      .forEach(function (_) {
                        if (
                          !window.$hsThemeSwitchCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === _
                            );
                          })
                        ) {
                          var f = new x(_);
                          (f.el.checked = f.theme === "dark"),
                            f.el.addEventListener("change", function (d) {
                              f.setAppearance(
                                d.target.checked ? "dark" : "default",
                              );
                            });
                        }
                      }),
                    document
                      .querySelectorAll(
                        "[data-hs-theme-click-value]:not(.--prevent-on-load-init)",
                      )
                      .forEach(function (_) {
                        var f = _.getAttribute("data-hs-theme-click-value"),
                          d = new x(_);
                        d.el.addEventListener("click", function () {
                          return d.setAppearance(f);
                        });
                      });
                }),
                x
              );
            })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              window.$hsThemeSwitchCollection &&
                window.addEventListener(
                  "on-hs-appearance-change",
                  function (S) {
                    window.$hsThemeSwitchCollection.forEach(function (x) {
                      x.element.el.checked = S.detail === "dark";
                    });
                  },
                ),
              typeof window < "u" && (window.HSThemeSwitch = y),
              (a.default = y);
          },
          87: function (o, a, u) {
            /*
             * HSToggleCount
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (S, x) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (_, f) {
                          _.__proto__ = f;
                        }) ||
                      function (_, f) {
                        for (var d in f)
                          Object.prototype.hasOwnProperty.call(f, d) &&
                            (_[d] = f[d]);
                      }),
                    h(S, x)
                  );
                }),
                function (S, x) {
                  if (typeof x != "function" && x !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(x) +
                        " is not a constructor or null",
                    );
                  function _() {
                    this.constructor = S;
                  }
                  h(S, x),
                    (S.prototype =
                      x === null
                        ? Object.create(x)
                        : ((_.prototype = x.prototype), new _()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (S) {
                        for (var x, _ = 1, f = arguments.length; _ < f; _++)
                          for (var d in (x = arguments[_]))
                            Object.prototype.hasOwnProperty.call(x, d) &&
                              (S[d] = x[d]);
                        return S;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = (function (S) {
              function x(_, f) {
                var d = S.call(this, _, f) || this,
                  m = _.getAttribute("data-hs-toggle-count"),
                  g = m ? JSON.parse(m) : {},
                  w = v(v({}, g), f);
                return (
                  (d.target =
                    w != null && w.target
                      ? typeof (w == null ? void 0 : w.target) == "string"
                        ? document.querySelector(w.target)
                        : w.target
                      : null),
                  (d.min = (w == null ? void 0 : w.min) || 0),
                  (d.max = (w == null ? void 0 : w.max) || 0),
                  (d.duration = (w == null ? void 0 : w.duration) || 700),
                  (d.isChecked = d.target.checked || !1),
                  d.target && d.init(),
                  d
                );
              }
              return (
                p(x, S),
                (x.prototype.init = function () {
                  var _ = this;
                  this.createCollection(window.$hsToggleCountCollection, this),
                    this.isChecked && (this.el.innerText = String(this.max)),
                    this.target.addEventListener("change", function () {
                      (_.isChecked = !_.isChecked), _.toggle();
                    });
                }),
                (x.prototype.toggle = function () {
                  this.isChecked ? this.countUp() : this.countDown();
                }),
                (x.prototype.animate = function (_, f) {
                  var d = this,
                    m = 0,
                    g = function (w) {
                      m || (m = w);
                      var T = Math.min((w - m) / d.duration, 1);
                      (d.el.innerText = String(Math.floor(T * (f - _) + _))),
                        T < 1 && window.requestAnimationFrame(g);
                    };
                  window.requestAnimationFrame(g);
                }),
                (x.prototype.countUp = function () {
                  this.animate(this.min, this.max);
                }),
                (x.prototype.countDown = function () {
                  this.animate(this.max, this.min);
                }),
                (x.getInstance = function (_, f) {
                  var d = window.$hsToggleCountCollection.find(function (m) {
                    return (
                      m.element.el ===
                      (typeof _ == "string" ? document.querySelector(_) : _)
                    );
                  });
                  return d ? (f ? d : d.element) : null;
                }),
                (x.autoInit = function () {
                  window.$hsToggleCountCollection ||
                    (window.$hsToggleCountCollection = []),
                    document
                      .querySelectorAll(
                        "[data-hs-toggle-count]:not(.--prevent-on-load-init)",
                      )
                      .forEach(function (_) {
                        window.$hsToggleCountCollection.find(function (f) {
                          var d;
                          return (
                            ((d = f == null ? void 0 : f.element) === null ||
                            d === void 0
                              ? void 0
                              : d.el) === _
                          );
                        }) || new x(_);
                      });
                }),
                x
              );
            })(u(737).default);
            window.addEventListener("load", function () {
              y.autoInit();
            }),
              typeof window < "u" && (window.HSToggleCount = y),
              (a.default = y);
          },
          366: function (o, a, u) {
            /*
             * HSTogglePassword
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (x, _) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (f, d) {
                          f.__proto__ = d;
                        }) ||
                      function (f, d) {
                        for (var m in d)
                          Object.prototype.hasOwnProperty.call(d, m) &&
                            (f[m] = d[m]);
                      }),
                    h(x, _)
                  );
                }),
                function (x, _) {
                  if (typeof _ != "function" && _ !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(_) +
                        " is not a constructor or null",
                    );
                  function f() {
                    this.constructor = x;
                  }
                  h(x, _),
                    (x.prototype =
                      _ === null
                        ? Object.create(_)
                        : ((f.prototype = _.prototype), new f()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (x) {
                        for (var _, f = 1, d = arguments.length; f < d; f++)
                          for (var m in (_ = arguments[f]))
                            Object.prototype.hasOwnProperty.call(_, m) &&
                              (x[m] = _[m]);
                        return x;
                      }),
                    v.apply(this, arguments)
                  );
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var y = u(969),
              S = (function (x) {
                function _(f, d) {
                  var m = x.call(this, f, d) || this,
                    g = f.getAttribute("data-hs-toggle-password"),
                    w = g ? JSON.parse(g) : {},
                    T = v(v({}, w), d),
                    C = [];
                  return (
                    T != null &&
                    T.target &&
                    typeof (T == null ? void 0 : T.target) == "string"
                      ? (T == null ? void 0 : T.target.split(",")).forEach(
                          function (A) {
                            C.push(document.querySelector(A));
                          },
                        )
                      : T != null &&
                          T.target &&
                          typeof (T == null ? void 0 : T.target) == "object"
                        ? T.target.forEach(function (A) {
                            return C.push(document.querySelector(A));
                          })
                        : T.target.forEach(function (A) {
                            return C.push(A);
                          }),
                    (m.target = C),
                    (m.isShown = !!m.el.hasAttribute("type") && m.el.checked),
                    (m.eventType = (0, y.isFormElement)(m.el)
                      ? "change"
                      : "click"),
                    (m.isMultiple =
                      m.target.length > 1 &&
                      !!m.el.closest("[data-hs-toggle-password-group]")),
                    m.target && m.init(),
                    m
                  );
                }
                return (
                  p(_, x),
                  (_.prototype.init = function () {
                    var f = this;
                    this.createCollection(
                      window.$hsTogglePasswordCollection,
                      this,
                    ),
                      this.isShown ? this.show() : this.hide(),
                      this.el.addEventListener(this.eventType, function () {
                        f.isShown ? f.hide() : f.show(),
                          f.fireEvent("toggle", f.target),
                          (0, y.dispatch)(
                            "toggle.hs.toggle-select",
                            f.el,
                            f.target,
                          );
                      });
                  }),
                  (_.prototype.getMultipleToggles = function () {
                    var f = this.el
                        .closest("[data-hs-toggle-password-group]")
                        .querySelectorAll("[data-hs-toggle-password]"),
                      d = [];
                    return (
                      f.forEach(function (m) {
                        d.push(_.getInstance(m));
                      }),
                      d
                    );
                  }),
                  (_.prototype.show = function () {
                    this.isMultiple
                      ? (this.getMultipleToggles().forEach(function (f) {
                          return !!f && (f.isShown = !0);
                        }),
                        this.el
                          .closest("[data-hs-toggle-password-group]")
                          .classList.add("active"))
                      : ((this.isShown = !0), this.el.classList.add("active")),
                      this.target.forEach(function (f) {
                        f.type = "text";
                      });
                  }),
                  (_.prototype.hide = function () {
                    this.isMultiple
                      ? (this.getMultipleToggles().forEach(function (f) {
                          return !!f && (f.isShown = !1);
                        }),
                        this.el
                          .closest("[data-hs-toggle-password-group]")
                          .classList.remove("active"))
                      : ((this.isShown = !1),
                        this.el.classList.remove("active")),
                      this.target.forEach(function (f) {
                        f.type = "password";
                      });
                  }),
                  (_.getInstance = function (f, d) {
                    var m = window.$hsTogglePasswordCollection.find(
                      function (g) {
                        return (
                          g.element.el ===
                          (typeof f == "string" ? document.querySelector(f) : f)
                        );
                      },
                    );
                    return m ? (d ? m : m.element) : null;
                  }),
                  (_.autoInit = function () {
                    window.$hsTogglePasswordCollection ||
                      (window.$hsTogglePasswordCollection = []),
                      document
                        .querySelectorAll(
                          "[data-hs-toggle-password]:not(.--prevent-on-load-init)",
                        )
                        .forEach(function (f) {
                          window.$hsTogglePasswordCollection.find(function (d) {
                            var m;
                            return (
                              ((m = d == null ? void 0 : d.element) === null ||
                              m === void 0
                                ? void 0
                                : m.el) === f
                            );
                          }) || new _(f);
                        });
                  }),
                  _
                );
              })(u(737).default);
            window.addEventListener("load", function () {
              S.autoInit();
            }),
              typeof window < "u" && (window.HSTogglePassword = S),
              (a.default = S);
          },
          679: function (o, a, u) {
            /*
             * HSTooltip
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ var h,
              p =
                (this && this.__extends) ||
                ((h = function (m, g) {
                  return (
                    (h =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (w, T) {
                          w.__proto__ = T;
                        }) ||
                      function (w, T) {
                        for (var C in T)
                          Object.prototype.hasOwnProperty.call(T, C) &&
                            (w[C] = T[C]);
                      }),
                    h(m, g)
                  );
                }),
                function (m, g) {
                  if (typeof g != "function" && g !== null)
                    throw new TypeError(
                      "Class extends value " +
                        String(g) +
                        " is not a constructor or null",
                    );
                  function w() {
                    this.constructor = m;
                  }
                  h(m, g),
                    (m.prototype =
                      g === null
                        ? Object.create(g)
                        : ((w.prototype = g.prototype), new w()));
                }),
              v =
                (this && this.__assign) ||
                function () {
                  return (
                    (v =
                      Object.assign ||
                      function (m) {
                        for (var g, w = 1, T = arguments.length; w < T; w++)
                          for (var C in (g = arguments[w]))
                            Object.prototype.hasOwnProperty.call(g, C) &&
                              (m[C] = g[C]);
                        return m;
                      }),
                    v.apply(this, arguments)
                  );
                },
              y =
                (this && this.__spreadArray) ||
                function (m, g, w) {
                  if (w || arguments.length === 2)
                    for (var T, C = 0, A = g.length; C < A; C++)
                      (!T && C in g) ||
                        (T || (T = Array.prototype.slice.call(g, 0, C)),
                        (T[C] = g[C]));
                  return m.concat(T || Array.prototype.slice.call(g));
                };
            Object.defineProperty(a, "__esModule", { value: !0 });
            var S = u(492),
              x = u(969),
              _ = u(737),
              f = u(190),
              d = (function (m) {
                function g(w, T, C) {
                  var A = m.call(this, w, T, C) || this;
                  return (
                    A.el &&
                      ((A.toggle =
                        A.el.querySelector(".hs-tooltip-toggle") || A.el),
                      (A.content = A.el.querySelector(".hs-tooltip-content")),
                      (A.eventMode =
                        (0, x.getClassProperty)(A.el, "--trigger") || "hover"),
                      (A.preventPopper = (0, x.getClassProperty)(
                        A.el,
                        "--prevent-popper",
                        "false",
                      )),
                      (A.placement = (0, x.getClassProperty)(
                        A.el,
                        "--placement",
                      )),
                      (A.strategy = (0, x.getClassProperty)(
                        A.el,
                        "--strategy",
                      ))),
                    A.el && A.toggle && A.content && A.init(),
                    A
                  );
                }
                return (
                  p(g, m),
                  (g.prototype.init = function () {
                    var w = this;
                    this.createCollection(window.$hsTooltipCollection, this),
                      this.eventMode === "click"
                        ? this.toggle.addEventListener("click", function () {
                            return w.click();
                          })
                        : this.eventMode === "focus"
                          ? this.toggle.addEventListener("click", function () {
                              return w.focus();
                            })
                          : this.eventMode === "hover" &&
                            (this.toggle.addEventListener(
                              "mouseenter",
                              function () {
                                return w.enter();
                              },
                            ),
                            this.toggle.addEventListener(
                              "mouseleave",
                              function () {
                                return w.leave();
                              },
                            )),
                      this.preventPopper === "false" && this.buildPopper();
                  }),
                  (g.prototype.enter = function () {
                    this.show();
                  }),
                  (g.prototype.leave = function () {
                    this.hide();
                  }),
                  (g.prototype.click = function () {
                    var w = this;
                    if (this.el.classList.contains("show")) return !1;
                    this.show();
                    var T = function () {
                      setTimeout(function () {
                        w.hide(),
                          w.toggle.removeEventListener("click", T, !0),
                          w.toggle.removeEventListener("blur", T, !0);
                      });
                    };
                    this.toggle.addEventListener("click", T, !0),
                      this.toggle.addEventListener("blur", T, !0);
                  }),
                  (g.prototype.focus = function () {
                    var w = this;
                    this.show();
                    var T = function () {
                      w.hide(), w.toggle.removeEventListener("blur", T, !0);
                    };
                    this.toggle.addEventListener("blur", T, !0);
                  }),
                  (g.prototype.buildPopper = function () {
                    this.popperInstance = (0, S.createPopper)(
                      this.toggle,
                      this.content,
                      {
                        placement: f.POSITIONS[this.placement] || "top",
                        strategy: this.strategy || "fixed",
                        modifiers: [
                          { name: "offset", options: { offset: [0, 5] } },
                        ],
                      },
                    );
                  }),
                  (g.prototype.show = function () {
                    var w = this;
                    this.content.classList.remove("hidden"),
                      this.preventPopper === "false" &&
                        (this.popperInstance.setOptions(function (T) {
                          return v(v({}, T), {
                            modifiers: y(
                              y([], T.modifiers, !0),
                              [{ name: "eventListeners", enabled: !0 }],
                              !1,
                            ),
                          });
                        }),
                        this.popperInstance.update()),
                      setTimeout(function () {
                        w.el.classList.add("show"),
                          w.fireEvent("show", w.el),
                          (0, x.dispatch)("show.hs.tooltip", w.el, w.el);
                      });
                  }),
                  (g.prototype.hide = function () {
                    var w = this;
                    this.el.classList.remove("show"),
                      this.preventPopper === "false" &&
                        this.popperInstance.setOptions(function (T) {
                          return v(v({}, T), {
                            modifiers: y(
                              y([], T.modifiers, !0),
                              [{ name: "eventListeners", enabled: !1 }],
                              !1,
                            ),
                          });
                        }),
                      this.fireEvent("hide", this.el),
                      (0, x.dispatch)("hide.hs.tooltip", this.el, this.el),
                      (0, x.afterTransition)(this.content, function () {
                        if (w.el.classList.contains("show")) return !1;
                        w.content.classList.add("hidden");
                      });
                  }),
                  (g.getInstance = function (w, T) {
                    T === void 0 && (T = !1);
                    var C = window.$hsTooltipCollection.find(function (A) {
                      return (
                        A.element.el ===
                        (typeof w == "string" ? document.querySelector(w) : w)
                      );
                    });
                    return C ? (T ? C : C.element.el) : null;
                  }),
                  (g.autoInit = function () {
                    window.$hsTooltipCollection ||
                      (window.$hsTooltipCollection = []),
                      document
                        .querySelectorAll(".hs-tooltip")
                        .forEach(function (w) {
                          window.$hsTooltipCollection.find(function (T) {
                            var C;
                            return (
                              ((C = T == null ? void 0 : T.element) === null ||
                              C === void 0
                                ? void 0
                                : C.el) === w
                            );
                          }) || new g(w);
                        });
                  }),
                  (g.show = function (w) {
                    var T = window.$hsTooltipCollection.find(function (C) {
                      return (
                        C.element.el ===
                        (typeof w == "string" ? document.querySelector(w) : w)
                      );
                    });
                    if (T)
                      switch (T.element.eventMode) {
                        case "click":
                          T.element.click();
                          break;
                        case "focus":
                          T.element.focus();
                          break;
                        default:
                          T.element.enter();
                      }
                  }),
                  (g.hide = function (w) {
                    var T = window.$hsTooltipCollection.find(function (C) {
                      return (
                        C.element.el ===
                        (typeof w == "string" ? document.querySelector(w) : w)
                      );
                    });
                    T && T.element.hide();
                  }),
                  (g.on = function (w, T, C) {
                    var A = window.$hsTooltipCollection.find(function (L) {
                      return (
                        L.element.el ===
                        (typeof T == "string" ? document.querySelector(T) : T)
                      );
                    });
                    A && (A.element.events[w] = C);
                  }),
                  g
                );
              })(_.default);
            window.addEventListener("load", function () {
              d.autoInit();
            }),
              typeof window < "u" && (window.HSTooltip = d),
              (a.default = d);
          },
          362: (o, a, u) => {
            Object.defineProperty(a, "__esModule", { value: !0 }),
              (a.COLLECTIONS = void 0);
            var h = u(413),
              p = u(460),
              v = u(629),
              y = u(652),
              S = u(610),
              x = u(371),
              _ = u(770),
              f = u(659),
              d = u(139),
              m = u(591),
              g = u(233),
              w = u(957),
              T = u(983),
              C = u(949),
              A = u(87),
              L = u(366),
              N = u(679);
            a.COLLECTIONS = [
              { key: "copy-markup", fn: h.default },
              { key: "accordion", fn: p.default },
              { key: "carousel", fn: v.default },
              { key: "collapse", fn: y.default },
              { key: "dropdown", fn: S.default },
              { key: "input-number", fn: x.default },
              { key: "overlay", fn: _.default },
              { key: "pin-input", fn: f.default },
              { key: "remove-element", fn: d.default },
              { key: "scrollspy", fn: m.default },
              { key: "select", fn: g.default },
              { key: "stepper", fn: w.default },
              { key: "strong-password", fn: T.default },
              { key: "tabs", fn: C.default },
              { key: "toggle-count", fn: A.default },
              { key: "toggle-password", fn: L.default },
              { key: "tooltip", fn: N.default },
            ];
          },
          313: (o, a, u) => {
            /*
             * HSStaticMethods
             * @version: 2.0.3
             * @author: HTMLStream
             * @license: Licensed under MIT (https://preline.co/docs/license.html)
             * Copyright 2023 HTMLStream
             */ Object.defineProperty(a, "__esModule", { value: !0 });
            var h = u(969),
              p = u(362),
              v = {
                getClassProperty: h.getClassProperty,
                afterTransition: h.afterTransition,
                autoInit: function (y) {
                  y === void 0 && (y = "all"),
                    y === "all"
                      ? p.COLLECTIONS.forEach(function (S) {
                          var x = S.fn;
                          x == null || x.autoInit();
                        })
                      : p.COLLECTIONS.forEach(function (S) {
                          var x = S.key,
                            _ = S.fn;
                          y.includes(x) && (_ == null || _.autoInit());
                        });
                },
              };
            typeof window < "u" && (window.HSStaticMethods = v),
              (a.default = v);
          },
          969: function (o, a) {
            var u = this;
            Object.defineProperty(a, "__esModule", { value: !0 }),
              (a.menuSearchHistory =
                a.classToClassList =
                a.htmlToElement =
                a.afterTransition =
                a.dispatch =
                a.debounce =
                a.isFormElement =
                a.isParentOrElementHidden =
                a.isEnoughSpace =
                a.isIpadOS =
                a.isIOS =
                a.getClassPropertyAlt =
                a.getClassProperty =
                  void 0),
              (a.getClassProperty = function (p, v, y) {
                return (
                  y === void 0 && (y = ""),
                  (window.getComputedStyle(p).getPropertyValue(v) || y).replace(
                    " ",
                    "",
                  )
                );
              }),
              (a.getClassPropertyAlt = function (p, v, y) {
                y === void 0 && (y = "");
                var S = "";
                return (
                  p.classList.forEach(function (x) {
                    x.includes(v) && (S = x);
                  }),
                  S.match(/:(.*)]/) ? S.match(/:(.*)]/)[1] : y
                );
              }),
              (a.isIOS = function () {
                return (
                  !!/iPad|iPhone|iPod/.test(navigator.platform) ||
                  (navigator.maxTouchPoints &&
                    navigator.maxTouchPoints > 2 &&
                    /MacIntel/.test(navigator.platform))
                );
              }),
              (a.isIpadOS = function () {
                return (
                  navigator.maxTouchPoints &&
                  navigator.maxTouchPoints > 2 &&
                  /MacIntel/.test(navigator.platform)
                );
              }),
              (a.isEnoughSpace = function (p, v, y, S, x) {
                y === void 0 && (y = "auto"),
                  S === void 0 && (S = 10),
                  x === void 0 && (x = null);
                var _ = v.getBoundingClientRect(),
                  f = x ? x.getBoundingClientRect() : null,
                  d = window.innerHeight,
                  m = f ? _.top - f.top : _.top,
                  g = (x ? f.bottom : d) - _.bottom,
                  w = p.clientHeight + S;
                return y === "bottom"
                  ? g >= w
                  : y === "top"
                    ? m >= w
                    : m >= w || g >= w;
              }),
              (a.isFormElement = function (p) {
                return (
                  p instanceof HTMLInputElement ||
                  p instanceof HTMLTextAreaElement ||
                  p instanceof HTMLSelectElement
                );
              });
            var h = function (p) {
              return (
                !!p &&
                (window.getComputedStyle(p).display === "none" ||
                  h(p.parentElement))
              );
            };
            (a.isParentOrElementHidden = h),
              (a.debounce = function (p, v) {
                var y;
                return (
                  v === void 0 && (v = 200),
                  function () {
                    for (var S = [], x = 0; x < arguments.length; x++)
                      S[x] = arguments[x];
                    clearTimeout(y),
                      (y = setTimeout(function () {
                        p.apply(u, S);
                      }, v));
                  }
                );
              }),
              (a.dispatch = function (p, v, y) {
                y === void 0 && (y = null);
                var S = new CustomEvent(p, {
                  detail: { payload: y },
                  bubbles: !0,
                  cancelable: !0,
                  composed: !1,
                });
                v.dispatchEvent(S);
              }),
              (a.afterTransition = function (p, v) {
                var y = function () {
                  v(), p.removeEventListener("transitionend", y, !0);
                };
                window
                  .getComputedStyle(p, null)
                  .getPropertyValue("transition") !== "all 0s ease 0s"
                  ? p.addEventListener("transitionend", y, !0)
                  : v();
              }),
              (a.htmlToElement = function (p) {
                var v = document.createElement("template");
                return (p = p.trim()), (v.innerHTML = p), v.content.firstChild;
              }),
              (a.classToClassList = function (p, v, y) {
                y === void 0 && (y = " "),
                  p.split(y).forEach(function (S) {
                    return v.classList.add(S);
                  });
              }),
              (a.menuSearchHistory = {
                historyIndex: -1,
                addHistory: function (p) {
                  this.historyIndex = p;
                },
                existsInHistory: function (p) {
                  return p > this.historyIndex;
                },
                clearHistory: function () {
                  this.historyIndex = -1;
                },
              });
          },
        },
        i = {};
      function r(o) {
        var a = i[o];
        if (a !== void 0) return a.exports;
        var u = (i[o] = { exports: {} });
        return t[o].call(u.exports, u, u.exports, r), u.exports;
      }
      (r.d = (o, a) => {
        for (var u in a)
          r.o(a, u) &&
            !r.o(o, u) &&
            Object.defineProperty(o, u, { enumerable: !0, get: a[u] });
      }),
        (r.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a)),
        (r.r = (o) => {
          typeof Symbol < "u" &&
            Symbol.toStringTag &&
            Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(o, "__esModule", { value: !0 });
        });
      var s = {};
      return (
        (() => {
          var o = s;
          Object.defineProperty(o, "__esModule", { value: !0 }),
            (o.HSStaticMethods =
              o.HSTooltip =
              o.HSTogglePassword =
              o.HSToggleCount =
              o.HSThemeSwitch =
              o.HSTabs =
              o.HSStrongPassword =
              o.HSStepper =
              o.HSSelect =
              o.HSScrollspy =
              o.HSSearchByJson =
              o.HSRemoveElement =
              o.HSPinInput =
              o.HSOverlay =
              o.HSInputNumber =
              o.HSDropdown =
              o.HSCollapse =
              o.HSCarousel =
              o.HSAccordion =
              o.HSCopyMarkup =
                void 0);
          var a = r(413);
          Object.defineProperty(o, "HSCopyMarkup", {
            enumerable: !0,
            get: function () {
              return a.default;
            },
          });
          var u = r(460);
          Object.defineProperty(o, "HSAccordion", {
            enumerable: !0,
            get: function () {
              return u.default;
            },
          });
          var h = r(629);
          Object.defineProperty(o, "HSCarousel", {
            enumerable: !0,
            get: function () {
              return h.default;
            },
          });
          var p = r(652);
          Object.defineProperty(o, "HSCollapse", {
            enumerable: !0,
            get: function () {
              return p.default;
            },
          });
          var v = r(610);
          Object.defineProperty(o, "HSDropdown", {
            enumerable: !0,
            get: function () {
              return v.default;
            },
          });
          var y = r(371);
          Object.defineProperty(o, "HSInputNumber", {
            enumerable: !0,
            get: function () {
              return y.default;
            },
          });
          var S = r(770);
          Object.defineProperty(o, "HSOverlay", {
            enumerable: !0,
            get: function () {
              return S.default;
            },
          });
          var x = r(659);
          Object.defineProperty(o, "HSPinInput", {
            enumerable: !0,
            get: function () {
              return x.default;
            },
          });
          var _ = r(139);
          Object.defineProperty(o, "HSRemoveElement", {
            enumerable: !0,
            get: function () {
              return _.default;
            },
          });
          var f = r(961);
          Object.defineProperty(o, "HSSearchByJson", {
            enumerable: !0,
            get: function () {
              return f.default;
            },
          });
          var d = r(591);
          Object.defineProperty(o, "HSScrollspy", {
            enumerable: !0,
            get: function () {
              return d.default;
            },
          });
          var m = r(233);
          Object.defineProperty(o, "HSSelect", {
            enumerable: !0,
            get: function () {
              return m.default;
            },
          });
          var g = r(957);
          Object.defineProperty(o, "HSStepper", {
            enumerable: !0,
            get: function () {
              return g.default;
            },
          });
          var w = r(983);
          Object.defineProperty(o, "HSStrongPassword", {
            enumerable: !0,
            get: function () {
              return w.default;
            },
          });
          var T = r(949);
          Object.defineProperty(o, "HSTabs", {
            enumerable: !0,
            get: function () {
              return T.default;
            },
          });
          var C = r(557);
          Object.defineProperty(o, "HSThemeSwitch", {
            enumerable: !0,
            get: function () {
              return C.default;
            },
          });
          var A = r(87);
          Object.defineProperty(o, "HSToggleCount", {
            enumerable: !0,
            get: function () {
              return A.default;
            },
          });
          var L = r(366);
          Object.defineProperty(o, "HSTogglePassword", {
            enumerable: !0,
            get: function () {
              return L.default;
            },
          });
          var N = r(679);
          Object.defineProperty(o, "HSTooltip", {
            enumerable: !0,
            get: function () {
              return N.default;
            },
          });
          var P = r(313);
          Object.defineProperty(o, "HSStaticMethods", {
            enumerable: !0,
            get: function () {
              return P.default;
            },
          });
        })(),
        s
      );
    })(),
  );
})($D);
let YD = { data: "" },
  KD = (n) =>
    typeof window == "object"
      ? (
          (n ? n.querySelector("#_goober") : window._goober) ||
          Object.assign(
            (n || document.head).appendChild(document.createElement("style")),
            { innerHTML: " ", id: "_goober" },
          )
        ).firstChild
      : n || YD,
  QD = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  ZD = /\/\*[^]*?\*\/|  +/g,
  dT = /\n+/g,
  Zo = (n, e) => {
    let t = "",
      i = "",
      r = "";
    for (let s in n) {
      let o = n[s];
      s[0] == "@"
        ? s[1] == "i"
          ? (t = s + " " + o + ";")
          : (i +=
              s[1] == "f"
                ? Zo(o, s)
                : s + "{" + Zo(o, s[1] == "k" ? "" : e) + "}")
        : typeof o == "object"
          ? (i += Zo(
              o,
              e
                ? e.replace(/([^,])+/g, (a) =>
                    s.replace(/(^:.*)|([^,])+/g, (u) =>
                      /&/.test(u) ? u.replace(/&/g, a) : a ? a + " " + u : u,
                    ),
                  )
                : s,
            ))
          : o != null &&
            ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase()),
            (r += Zo.p ? Zo.p(s, o) : s + ":" + o + ";"));
    }
    return t + (e && r ? e + "{" + r + "}" : r) + i;
  },
  Xs = {},
  s2 = (n) => {
    if (typeof n == "object") {
      let e = "";
      for (let t in n) e += t + s2(n[t]);
      return e;
    }
    return n;
  },
  JD = (n, e, t, i, r) => {
    let s = s2(n),
      o =
        Xs[s] ||
        (Xs[s] = ((u) => {
          let h = 0,
            p = 11;
          for (; h < u.length; ) p = (101 * p + u.charCodeAt(h++)) >>> 0;
          return "go" + p;
        })(s));
    if (!Xs[o]) {
      let u =
        s !== n
          ? n
          : ((h) => {
              let p,
                v,
                y = [{}];
              for (; (p = QD.exec(h.replace(ZD, ""))); )
                p[4]
                  ? y.shift()
                  : p[3]
                    ? ((v = p[3].replace(dT, " ").trim()),
                      y.unshift((y[0][v] = y[0][v] || {})))
                    : (y[0][p[1]] = p[2].replace(dT, " ").trim());
              return y[0];
            })(n);
      Xs[o] = Zo(r ? { ["@keyframes " + o]: u } : u, t ? "" : "." + o);
    }
    let a = t && Xs.g ? Xs.g : null;
    return (
      t && (Xs.g = Xs[o]),
      ((u, h, p, v) => {
        v
          ? (h.data = h.data.replace(v, u))
          : h.data.indexOf(u) === -1 && (h.data = p ? u + h.data : h.data + u);
      })(Xs[o], e, i, a),
      o
    );
  },
  ek = (n, e, t) =>
    n.reduce((i, r, s) => {
      let o = e[s];
      if (o && o.call) {
        let a = o(t),
          u = (a && a.props && a.props.className) || (/^go/.test(a) && a);
        o = u
          ? "." + u
          : a && typeof a == "object"
            ? a.props
              ? ""
              : Zo(a, "")
            : a === !1
              ? ""
              : a;
      }
      return i + r + (o ?? "");
    }, "");
function dv(n) {
  let e = this || {},
    t = n.call ? n(e.p) : n;
  return JD(
    t.unshift
      ? t.raw
        ? ek(t, [].slice.call(arguments, 1), e.p)
        : t.reduce((i, r) => Object.assign(i, r && r.call ? r(e.p) : r), {})
      : t,
    KD(e.target),
    e.g,
    e.o,
    e.k,
  );
}
let o2, wx, Mx;
dv.bind({ g: 1 });
let mo = dv.bind({ k: 1 });
function tk(n, e, t, i) {
  (Zo.p = e), (o2 = n), (wx = t), (Mx = i);
}
function Ra(n, e) {
  let t = this || {};
  return function () {
    let i = arguments;
    function r(s, o) {
      let a = Object.assign({}, s),
        u = a.className || r.className;
      (t.p = Object.assign({ theme: wx && wx() }, a)),
        (t.o = / *go\d+/.test(u)),
        (a.className = dv.apply(t, i) + (u ? " " + u : "")),
        e && (a.ref = o);
      let h = n;
      return (
        n[0] && ((h = a.as || n), delete a.as), Mx && h[0] && Mx(a), o2(h, a)
      );
    }
    return e ? e(r) : r;
  };
}
var nk = (n) => typeof n == "function",
  Ch = (n, e) => (nk(n) ? n(e) : n),
  ik = (() => {
    let n = 0;
    return () => (++n).toString();
  })(),
  a2 = (() => {
    let n;
    return () => {
      if (n === void 0 && typeof window < "u") {
        let e = matchMedia("(prefers-reduced-motion: reduce)");
        n = !e || e.matches;
      }
      return n;
    };
  })(),
  rk = 20,
  Km = new Map(),
  sk = 1e3,
  hT = (n) => {
    if (Km.has(n)) return;
    let e = setTimeout(() => {
      Km.delete(n), Xl({ type: 4, toastId: n });
    }, sk);
    Km.set(n, e);
  },
  ok = (n) => {
    let e = Km.get(n);
    e && clearTimeout(e);
  },
  Ex = (n, e) => {
    switch (e.type) {
      case 0:
        return { ...n, toasts: [e.toast, ...n.toasts].slice(0, rk) };
      case 1:
        return (
          e.toast.id && ok(e.toast.id),
          {
            ...n,
            toasts: n.toasts.map((s) =>
              s.id === e.toast.id ? { ...s, ...e.toast } : s,
            ),
          }
        );
      case 2:
        let { toast: t } = e;
        return n.toasts.find((s) => s.id === t.id)
          ? Ex(n, { type: 1, toast: t })
          : Ex(n, { type: 0, toast: t });
      case 3:
        let { toastId: i } = e;
        return (
          i
            ? hT(i)
            : n.toasts.forEach((s) => {
                hT(s.id);
              }),
          {
            ...n,
            toasts: n.toasts.map((s) =>
              s.id === i || i === void 0 ? { ...s, visible: !1 } : s,
            ),
          }
        );
      case 4:
        return e.toastId === void 0
          ? { ...n, toasts: [] }
          : { ...n, toasts: n.toasts.filter((s) => s.id !== e.toastId) };
      case 5:
        return { ...n, pausedAt: e.time };
      case 6:
        let r = e.time - (n.pausedAt || 0);
        return {
          ...n,
          pausedAt: void 0,
          toasts: n.toasts.map((s) => ({
            ...s,
            pauseDuration: s.pauseDuration + r,
          })),
        };
    }
  },
  Qm = [],
  Zm = { toasts: [], pausedAt: void 0 },
  Xl = (n) => {
    (Zm = Ex(Zm, n)),
      Qm.forEach((e) => {
        e(Zm);
      });
  },
  ak = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 },
  lk = (n = {}) => {
    let [e, t] = se.useState(Zm);
    se.useEffect(
      () => (
        Qm.push(t),
        () => {
          let r = Qm.indexOf(t);
          r > -1 && Qm.splice(r, 1);
        }
      ),
      [e],
    );
    let i = e.toasts.map((r) => {
      var s, o;
      return {
        ...n,
        ...n[r.type],
        ...r,
        duration:
          r.duration ||
          ((s = n[r.type]) == null ? void 0 : s.duration) ||
          (n == null ? void 0 : n.duration) ||
          ak[r.type],
        style: {
          ...n.style,
          ...((o = n[r.type]) == null ? void 0 : o.style),
          ...r.style,
        },
      };
    });
    return { ...e, toasts: i };
  },
  uk = (n, e = "blank", t) => ({
    createdAt: Date.now(),
    visible: !0,
    type: e,
    ariaProps: { role: "status", "aria-live": "polite" },
    message: n,
    pauseDuration: 0,
    ...t,
    id: (t == null ? void 0 : t.id) || ik(),
  }),
  pf = (n) => (e, t) => {
    let i = uk(e, n, t);
    return Xl({ type: 2, toast: i }), i.id;
  },
  pr = (n, e) => pf("blank")(n, e);
pr.error = pf("error");
pr.success = pf("success");
pr.loading = pf("loading");
pr.custom = pf("custom");
pr.dismiss = (n) => {
  Xl({ type: 3, toastId: n });
};
pr.remove = (n) => Xl({ type: 4, toastId: n });
pr.promise = (n, e, t) => {
  let i = pr.loading(e.loading, { ...t, ...(t == null ? void 0 : t.loading) });
  return (
    n
      .then(
        (r) => (
          pr.success(Ch(e.success, r), {
            id: i,
            ...t,
            ...(t == null ? void 0 : t.success),
          }),
          r
        ),
      )
      .catch((r) => {
        pr.error(Ch(e.error, r), {
          id: i,
          ...t,
          ...(t == null ? void 0 : t.error),
        });
      }),
    n
  );
};
var ck = (n, e) => {
    Xl({ type: 1, toast: { id: n, height: e } });
  },
  dk = () => {
    Xl({ type: 5, time: Date.now() });
  },
  hk = (n) => {
    let { toasts: e, pausedAt: t } = lk(n);
    se.useEffect(() => {
      if (t) return;
      let s = Date.now(),
        o = e.map((a) => {
          if (a.duration === 1 / 0) return;
          let u = (a.duration || 0) + a.pauseDuration - (s - a.createdAt);
          if (u < 0) {
            a.visible && pr.dismiss(a.id);
            return;
          }
          return setTimeout(() => pr.dismiss(a.id), u);
        });
      return () => {
        o.forEach((a) => a && clearTimeout(a));
      };
    }, [e, t]);
    let i = se.useCallback(() => {
        t && Xl({ type: 6, time: Date.now() });
      }, [t]),
      r = se.useCallback(
        (s, o) => {
          let {
              reverseOrder: a = !1,
              gutter: u = 8,
              defaultPosition: h,
            } = o || {},
            p = e.filter(
              (S) => (S.position || h) === (s.position || h) && S.height,
            ),
            v = p.findIndex((S) => S.id === s.id),
            y = p.filter((S, x) => x < v && S.visible).length;
          return p
            .filter((S) => S.visible)
            .slice(...(a ? [y + 1] : [0, y]))
            .reduce((S, x) => S + (x.height || 0) + u, 0);
        },
        [e],
      );
    return {
      toasts: e,
      handlers: {
        updateHeight: ck,
        startPause: dk,
        endPause: i,
        calculateOffset: r,
      },
    };
  },
  fk = mo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
  pk = mo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  mk = mo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
  gk = Ra("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(n) => n.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${fk} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${pk} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(n) => n.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${mk} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`,
  vk = mo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`,
  yk = Ra("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(n) => n.secondary || "#e0e0e0"};
  border-right-color: ${(n) => n.primary || "#616161"};
  animation: ${vk} 1s linear infinite;
`,
  _k = mo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`,
  xk = mo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`,
  Sk = Ra("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(n) => n.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${_k} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${xk} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(n) => n.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`,
  wk = Ra("div")`
  position: absolute;
`,
  Mk = Ra("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`,
  Ek = mo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
  Tk = Ra("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Ek} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`,
  Ck = ({ toast: n }) => {
    let { icon: e, type: t, iconTheme: i } = n;
    return e !== void 0
      ? typeof e == "string"
        ? se.createElement(Tk, null, e)
        : e
      : t === "blank"
        ? null
        : se.createElement(
            Mk,
            null,
            se.createElement(yk, { ...i }),
            t !== "loading" &&
              se.createElement(
                wk,
                null,
                t === "error"
                  ? se.createElement(gk, { ...i })
                  : se.createElement(Sk, { ...i }),
              ),
          );
  },
  bk = (n) => `
0% {transform: translate3d(0,${n * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`,
  Ak = (n) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${n * -150}%,-1px) scale(.6); opacity:0;}
`,
  Pk = "0%{opacity:0;} 100%{opacity:1;}",
  Rk = "0%{opacity:1;} 100%{opacity:0;}",
  Lk = Ra("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`,
  Ik = Ra("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`,
  Ok = (n, e) => {
    let t = n.includes("top") ? 1 : -1,
      [i, r] = a2() ? [Pk, Rk] : [bk(t), Ak(t)];
    return {
      animation: e
        ? `${mo(i)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`
        : `${mo(r)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`,
    };
  },
  Nk = se.memo(({ toast: n, position: e, style: t, children: i }) => {
    let r = n.height
        ? Ok(n.position || e || "top-center", n.visible)
        : { opacity: 0 },
      s = se.createElement(Ck, { toast: n }),
      o = se.createElement(Ik, { ...n.ariaProps }, Ch(n.message, n));
    return se.createElement(
      Lk,
      { className: n.className, style: { ...r, ...t, ...n.style } },
      typeof i == "function"
        ? i({ icon: s, message: o })
        : se.createElement(se.Fragment, null, s, o),
    );
  });
tk(se.createElement);
var Dk = ({
    id: n,
    className: e,
    style: t,
    onHeightUpdate: i,
    children: r,
  }) => {
    let s = se.useCallback(
      (o) => {
        if (o) {
          let a = () => {
            let u = o.getBoundingClientRect().height;
            i(n, u);
          };
          a(),
            new MutationObserver(a).observe(o, {
              subtree: !0,
              childList: !0,
              characterData: !0,
            });
        }
      },
      [n, i],
    );
    return se.createElement("div", { ref: s, className: e, style: t }, r);
  },
  kk = (n, e) => {
    let t = n.includes("top"),
      i = t ? { top: 0 } : { bottom: 0 },
      r = n.includes("center")
        ? { justifyContent: "center" }
        : n.includes("right")
          ? { justifyContent: "flex-end" }
          : {};
    return {
      left: 0,
      right: 0,
      display: "flex",
      position: "absolute",
      transition: a2() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
      transform: `translateY(${e * (t ? 1 : -1)}px)`,
      ...i,
      ...r,
    };
  },
  Uk = dv`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,
  Fp = 16,
  Fk = ({
    reverseOrder: n,
    position: e = "top-center",
    toastOptions: t,
    gutter: i,
    children: r,
    containerStyle: s,
    containerClassName: o,
  }) => {
    let { toasts: a, handlers: u } = hk(t);
    return se.createElement(
      "div",
      {
        style: {
          position: "fixed",
          zIndex: 9999,
          top: Fp,
          left: Fp,
          right: Fp,
          bottom: Fp,
          pointerEvents: "none",
          ...s,
        },
        className: o,
        onMouseEnter: u.startPause,
        onMouseLeave: u.endPause,
      },
      a.map((h) => {
        let p = h.position || e,
          v = u.calculateOffset(h, {
            reverseOrder: n,
            gutter: i,
            defaultPosition: e,
          }),
          y = kk(p, v);
        return se.createElement(
          Dk,
          {
            id: h.id,
            key: h.id,
            onHeightUpdate: u.updateHeight,
            className: h.visible ? Uk : "",
            style: y,
          },
          h.type === "custom"
            ? Ch(h.message, h)
            : r
              ? r(h)
              : se.createElement(Nk, { toast: h, position: p }),
        );
      }),
    );
  },
  Ng = pr;
function Bk() {
  return ce.jsx(Fk, {
    position: "bottom-center",
    children: (n) => {
      const e = zk(n.type);
      return ce.jsx("div", {
        className: `max-w-xs ${e.container} flex`,
        role: "alert",
        children: ce.jsxs("div", {
          className: "flex p-4",
          children: [
            ce.jsx("p", {
              className: "text-sm text-white",
              children: Ch(n.message, n),
            }),
            ce.jsx("div", {
              className: "ms-auto pl-2",
              children: ce.jsxs("button", {
                className: `inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg opacity-70 hover:opacity-100 focus:outline-none focus:opacity-100 ${e.closeButton}`,
                onClick: () => Ng.dismiss(n.id),
                type: "button",
                children: [
                  ce.jsx("span", { className: "sr-only", children: "Close" }),
                  ce.jsxs("svg", {
                    className: "flex-shrink-0 size-4",
                    xmlns: "http://www.w3.org/2000/svg",
                    width: "24",
                    height: "24",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    children: [
                      ce.jsx("path", { d: "M18 6 6 18" }),
                      ce.jsx("path", { d: "m6 6 12 12" }),
                    ],
                  }),
                ],
              }),
            }),
          ],
        }),
      });
    },
  });
}
const zk = (n) => {
    switch (n) {
      case "error":
        return {
          container:
            "max-w-xs bg-red-500 text-sm text-white rounded-xl shadow-lg",
          closeButton:
            "inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg text-white hover:text-white opacity-50 hover:opacity-100 focus:outline-none focus:opacity-100",
        };
      case "success":
        return {
          container:
            "max-w-xs bg-green-500 text-sm text-white rounded-xl shadow-lg",
          closeButton:
            "inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg text-white hover:text-white opacity-50 hover:opacity-100 focus:outline-none focus:opacity-100",
        };
      case "custom":
        return {
          container:
            "max-w-xs bg-yellow-500 text-sm text-white rounded-xl shadow-lg",
          closeButton:
            "inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg text-white hover:text-white opacity-50 hover:opacity-100 focus:outline-none focus:opacity-100",
        };
      case "blank":
        return {
          container:
            "max-w-xs bg-gray-500 text-sm text-white rounded-xl shadow-lg dark:bg-gray-700",
          closeButton:
            "inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg text-white hover:text-white opacity-50 hover:opacity-100 focus:outline-none focus:opacity-100",
        };
      default:
        return {
          container:
            "max-w-xs bg-gray-800 text-sm text-white rounded-xl shadow-lg dark:bg-gray-900",
          closeButton:
            "inline-flex flex-shrink-0 justify-center items-center size-5 rounded-lg text-white hover:text-white opacity-50 hover:opacity-100 focus:outline-none focus:opacity-100",
        };
    }
  },
  l2 = new PD({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1e3,
        retryDelay: (n) => Math.min(n > 1 ? 2 ** n * 1e3 : 1e3, 30 * 1e3),
      },
    },
  }),
  Hk = ({ router: n }) =>
    ce.jsxs(ND, {
      client: l2,
      children: [
        ce.jsxs("div", {
          className: "app relative z-10 h-[100svh]",
          children: [ce.jsx(K3, { router: n }), ce.jsx(Bk, {})],
        }),
        ce.jsx(qD, { initialIsOpen: !1 }),
      ],
    }),
  Sw = U3(),
  Vk = ({ onSelection: n, value: e = "" }) => {
    const [t, i] = se.useState(() => e),
      r = se.useRef(null),
      [s, o] = se.useState("");
    return (
      se.useEffect(() => {
        i(e);
      }, [e]),
      se.useEffect(() => {
        const a = r.current,
          u = new google.maps.places.Autocomplete(a);
        u.addListener("place_changed", () => {
          const h = u.getPlace();
          if (!h.geometry || !h.geometry.location) {
            o("Unable to find location. Please try another address.");
            return;
          }
          const p = {
            label: h.formatted_address ?? "No label",
            latitude: h.geometry.location.lat(),
            longitude: h.geometry.location.lng(),
          };
          n == null || n(p), i(p.label);
        });
      }, []),
      ce.jsxs("div", {
        children: [
          ce.jsx("label", {
            htmlFor: "address-autocomplete",
            className: "sr-only",
            children: "Location:",
          }),
          ce.jsxs("div", {
            className: "flex rounded-lg shadow-sm relative",
            children: [
              ce.jsx("input", {
                "aria-describedby": "hs-validation-name-error-helper",
                className:
                  "py-3 rounded-3xl ps-12 px-4 block w-full border-gray-200 shadow-sm rounded-0 text-sm focus:z-10 focus:border-blue-500 focus:ring-blue-500 disabled:opacity-50 disabled:pointer-events-none dark:bg-slate-900 dark:border-gray-700 dark:text-gray-400 dark:focus:ring-gray-600",
                id: "address-autocomplete",
                name: "hs-search-box-with-loading-3",
                onChange: (a) => {
                  o(""), i(a.target.value);
                },
                onFocus: (a) => {
                  o(""), a.target.select();
                },
                placeholder: "Enter location..",
                ref: r,
                required: !0,
                type: "text",
                value: t,
              }),
              ce.jsx("div", {
                className:
                  "absolute inset-y-0 start-0 flex items-center pointer-events-none z-20 ps-4",
                children: ce.jsx("svg", {
                  className: "w-[24px] h-[24px] fill-gray-400",
                  viewBox: "0 0 512 512",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: ce.jsx("path", {
                    d: "M352 256c0 22.2-1.2 43.6-3.3 64H163.3c-2.2-20.4-3.3-41.8-3.3-64s1.2-43.6 3.3-64H348.7c2.2 20.4 3.3 41.8 3.3 64zm28.8-64H503.9c5.3 20.5 8.1 41.9 8.1 64s-2.8 43.5-8.1 64H380.8c2.1-20.6 3.2-42 3.2-64s-1.1-43.4-3.2-64zm112.6-32H376.7c-10-63.9-29.8-117.4-55.3-151.6c78.3 20.7 142 77.5 171.9 151.6zm-149.1 0H167.7c6.1-36.4 15.5-68.6 27-94.7c10.5-23.6 22.2-40.7 33.5-51.5C239.4 3.2 248.7 0 256 0s16.6 3.2 27.8 13.8c11.3 10.8 23 27.9 33.5 51.5c11.6 26 20.9 58.2 27 94.7zm-209 0H18.6C48.6 85.9 112.2 29.1 190.6 8.4C165.1 42.6 145.3 96.1 135.3 160zM8.1 192H131.2c-2.1 20.6-3.2 42-3.2 64s1.1 43.4 3.2 64H8.1C2.8 299.5 0 278.1 0 256s2.8-43.5 8.1-64zM194.7 446.6c-11.6-26-20.9-58.2-27-94.6H344.3c-6.1 36.4-15.5 68.6-27 94.6c-10.5 23.6-22.2 40.7-33.5 51.5C272.6 508.8 263.3 512 256 512s-16.6-3.2-27.8-13.8c-11.3-10.8-23-27.9-33.5-51.5zM135.3 352c10 63.9 29.8 117.4 55.3 151.6C112.2 482.9 48.6 426.1 18.6 352H135.3zm358.1 0c-30 74.1-93.6 130.9-171.9 151.6c25.5-34.2 45.2-87.7 55.3-151.6H493.4z",
                  }),
                }),
              }),
            ],
          }),
          !!s &&
            ce.jsx("div", {
              className: "w-full text-left",
              children: ce.jsxs("p", {
                className:
                  "text-sm inline-block bg-white py-1 px-2 rounded-sm text-red-600 mt-2",
                id: "hs-validation-name-error-helper",
                children: [" ", s],
              }),
            }),
        ],
      })
    );
  };
function mf(n) {
  const { className: e, ...t } = n;
  return ce.jsx("div", {
    className: `rounded-xl bg-opacity-30 bg-white ${e}`,
    ...t,
  });
}
const Gk = {
  clear: { day: "clear-day.svg", night: "clear-night.svg" },
  fog: { day: "fog-day.svg", night: "fog-night.svg" },
  partlyCloudy: {
    day: "partly-cloudy-day.svg",
    night: "partly-cloudy-night.svg",
  },
  rain: { day: "rain.svg", night: "rain.svg" },
  snow: { day: "snow.svg", night: "snow.svg" },
  thunderstorm: {
    day: "thunderstorms-day.svg",
    night: "thunderstorms-night.svg",
  },
};
function u2(n) {
  const e = n.is_day === 1 ? "day" : "night";
  let t = "clear";
  const i = n.weather_code;
  i === 0
    ? (t = "clear")
    : i >= 1 && i <= 3
      ? (t = "partlyCloudy")
      : i === 45 || i === 48
        ? (t = "fog")
        : [51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(i)
          ? (t = "rain")
          : [71, 73, 75, 77, 85, 86].includes(i)
            ? (t = "snow")
            : [95, 96, 99].includes(i) && (t = "thunderstorm");
  const r = Gk[t];
  return r ? r[e] : "clear-day.svg";
}
function Wk({ imageSize: n = "72px", isLoading: e, place: t, weather: i }) {
  var o, a;
  const r = u2(i == null ? void 0 : i.current),
    s = `${(o = i == null ? void 0 : i.current) == null ? void 0 : o.temperature_2m} ${(a = i == null ? void 0 : i.current_units) == null ? void 0 : a.temperature_2m}`;
  return ce.jsxs(mf, {
    className: "pb-6",
    children: [
      e
        ? "LOADING"
        : ce.jsx("div", {
            className: "flex justify-center align-middle",
            children: ce.jsx("img", {
              alt: "Weather icon",
              src: `/weather/${r}`,
              style: { height: n, width: n },
            }),
          }),
      ce.jsx("div", { className: "w-full text-3xl font-bold", children: s }),
      (!!(t != null && t.city) || !!(t != null && t.state)) &&
        ce.jsxs("div", {
          className: "w-full text-base font-bold opacity-80",
          children: [
            t == null ? void 0 : t.city,
            t != null && t.city ? "," : "",
            " ",
            t == null ? void 0 : t.state,
          ],
        }),
    ],
  });
}
var c2 = { exports: {} };
(function (n, e) {
  (function (t, i) {
    n.exports = i();
  })(RI, function () {
    var t = 1e3,
      i = 6e4,
      r = 36e5,
      s = "millisecond",
      o = "second",
      a = "minute",
      u = "hour",
      h = "day",
      p = "week",
      v = "month",
      y = "quarter",
      S = "year",
      x = "date",
      _ = "Invalid Date",
      f =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      d =
        /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      m = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_",
          ),
        ordinal: function (F) {
          var X = ["th", "st", "nd", "rd"],
            G = F % 100;
          return "[" + F + (X[(G - 20) % 10] || X[G] || X[0]) + "]";
        },
      },
      g = function (F, X, G) {
        var ne = String(F);
        return !ne || ne.length >= X
          ? F
          : "" + Array(X + 1 - ne.length).join(G) + F;
      },
      w = {
        s: g,
        z: function (F) {
          var X = -F.utcOffset(),
            G = Math.abs(X),
            ne = Math.floor(G / 60),
            k = G % 60;
          return (X <= 0 ? "+" : "-") + g(ne, 2, "0") + ":" + g(k, 2, "0");
        },
        m: function F(X, G) {
          if (X.date() < G.date()) return -F(G, X);
          var ne = 12 * (G.year() - X.year()) + (G.month() - X.month()),
            k = X.clone().add(ne, v),
            W = G - k < 0,
            H = X.clone().add(ne + (W ? -1 : 1), v);
          return +(-(ne + (G - k) / (W ? k - H : H - k)) || 0);
        },
        a: function (F) {
          return F < 0 ? Math.ceil(F) || 0 : Math.floor(F);
        },
        p: function (F) {
          return (
            { M: v, y: S, w: p, d: h, D: x, h: u, m: a, s: o, ms: s, Q: y }[
              F
            ] ||
            String(F || "")
              .toLowerCase()
              .replace(/s$/, "")
          );
        },
        u: function (F) {
          return F === void 0;
        },
      },
      T = "en",
      C = {};
    C[T] = m;
    var A = "$isDayjsObject",
      L = function (F) {
        return F instanceof Q || !(!F || !F[A]);
      },
      N = function F(X, G, ne) {
        var k;
        if (!X) return T;
        if (typeof X == "string") {
          var W = X.toLowerCase();
          C[W] && (k = W), G && ((C[W] = G), (k = W));
          var H = X.split("-");
          if (!k && H.length > 1) return F(H[0]);
        } else {
          var ee = X.name;
          (C[ee] = X), (k = ee);
        }
        return !ne && k && (T = k), k || (!ne && T);
      },
      P = function (F, X) {
        if (L(F)) return F.clone();
        var G = typeof X == "object" ? X : {};
        return (G.date = F), (G.args = arguments), new Q(G);
      },
      I = w;
    (I.l = N),
      (I.i = L),
      (I.w = function (F, X) {
        return P(F, { locale: X.$L, utc: X.$u, x: X.$x, $offset: X.$offset });
      });
    var Q = (function () {
        function F(G) {
          (this.$L = N(G.locale, null, !0)),
            this.parse(G),
            (this.$x = this.$x || G.x || {}),
            (this[A] = !0);
        }
        var X = F.prototype;
        return (
          (X.parse = function (G) {
            (this.$d = (function (ne) {
              var k = ne.date,
                W = ne.utc;
              if (k === null) return new Date(NaN);
              if (I.u(k)) return new Date();
              if (k instanceof Date) return new Date(k);
              if (typeof k == "string" && !/Z$/i.test(k)) {
                var H = k.match(f);
                if (H) {
                  var ee = H[2] - 1 || 0,
                    ae = (H[7] || "0").substring(0, 3);
                  return W
                    ? new Date(
                        Date.UTC(
                          H[1],
                          ee,
                          H[3] || 1,
                          H[4] || 0,
                          H[5] || 0,
                          H[6] || 0,
                          ae,
                        ),
                      )
                    : new Date(
                        H[1],
                        ee,
                        H[3] || 1,
                        H[4] || 0,
                        H[5] || 0,
                        H[6] || 0,
                        ae,
                      );
                }
              }
              return new Date(k);
            })(G)),
              this.init();
          }),
          (X.init = function () {
            var G = this.$d;
            (this.$y = G.getFullYear()),
              (this.$M = G.getMonth()),
              (this.$D = G.getDate()),
              (this.$W = G.getDay()),
              (this.$H = G.getHours()),
              (this.$m = G.getMinutes()),
              (this.$s = G.getSeconds()),
              (this.$ms = G.getMilliseconds());
          }),
          (X.$utils = function () {
            return I;
          }),
          (X.isValid = function () {
            return this.$d.toString() !== _;
          }),
          (X.isSame = function (G, ne) {
            var k = P(G);
            return this.startOf(ne) <= k && k <= this.endOf(ne);
          }),
          (X.isAfter = function (G, ne) {
            return P(G) < this.startOf(ne);
          }),
          (X.isBefore = function (G, ne) {
            return this.endOf(ne) < P(G);
          }),
          (X.$g = function (G, ne, k) {
            return I.u(G) ? this[ne] : this.set(k, G);
          }),
          (X.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }),
          (X.valueOf = function () {
            return this.$d.getTime();
          }),
          (X.startOf = function (G, ne) {
            var k = this,
              W = !!I.u(ne) || ne,
              H = I.p(G),
              ee = function (ze, tt) {
                var Ge = I.w(
                  k.$u ? Date.UTC(k.$y, tt, ze) : new Date(k.$y, tt, ze),
                  k,
                );
                return W ? Ge : Ge.endOf(h);
              },
              ae = function (ze, tt) {
                return I.w(
                  k
                    .toDate()
                    [
                      ze
                    ].apply(k.toDate("s"), (W ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(tt)),
                  k,
                );
              },
              xe = this.$W,
              te = this.$M,
              de = this.$D,
              ye = "set" + (this.$u ? "UTC" : "");
            switch (H) {
              case S:
                return W ? ee(1, 0) : ee(31, 11);
              case v:
                return W ? ee(1, te) : ee(0, te + 1);
              case p:
                var Ce = this.$locale().weekStart || 0,
                  Ze = (xe < Ce ? xe + 7 : xe) - Ce;
                return ee(W ? de - Ze : de + (6 - Ze), te);
              case h:
              case x:
                return ae(ye + "Hours", 0);
              case u:
                return ae(ye + "Minutes", 1);
              case a:
                return ae(ye + "Seconds", 2);
              case o:
                return ae(ye + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }),
          (X.endOf = function (G) {
            return this.startOf(G, !1);
          }),
          (X.$set = function (G, ne) {
            var k,
              W = I.p(G),
              H = "set" + (this.$u ? "UTC" : ""),
              ee = ((k = {}),
              (k[h] = H + "Date"),
              (k[x] = H + "Date"),
              (k[v] = H + "Month"),
              (k[S] = H + "FullYear"),
              (k[u] = H + "Hours"),
              (k[a] = H + "Minutes"),
              (k[o] = H + "Seconds"),
              (k[s] = H + "Milliseconds"),
              k)[W],
              ae = W === h ? this.$D + (ne - this.$W) : ne;
            if (W === v || W === S) {
              var xe = this.clone().set(x, 1);
              xe.$d[ee](ae),
                xe.init(),
                (this.$d = xe.set(x, Math.min(this.$D, xe.daysInMonth())).$d);
            } else ee && this.$d[ee](ae);
            return this.init(), this;
          }),
          (X.set = function (G, ne) {
            return this.clone().$set(G, ne);
          }),
          (X.get = function (G) {
            return this[I.p(G)]();
          }),
          (X.add = function (G, ne) {
            var k,
              W = this;
            G = Number(G);
            var H = I.p(ne),
              ee = function (te) {
                var de = P(W);
                return I.w(de.date(de.date() + Math.round(te * G)), W);
              };
            if (H === v) return this.set(v, this.$M + G);
            if (H === S) return this.set(S, this.$y + G);
            if (H === h) return ee(1);
            if (H === p) return ee(7);
            var ae = ((k = {}), (k[a] = i), (k[u] = r), (k[o] = t), k)[H] || 1,
              xe = this.$d.getTime() + G * ae;
            return I.w(xe, this);
          }),
          (X.subtract = function (G, ne) {
            return this.add(-1 * G, ne);
          }),
          (X.format = function (G) {
            var ne = this,
              k = this.$locale();
            if (!this.isValid()) return k.invalidDate || _;
            var W = G || "YYYY-MM-DDTHH:mm:ssZ",
              H = I.z(this),
              ee = this.$H,
              ae = this.$m,
              xe = this.$M,
              te = k.weekdays,
              de = k.months,
              ye = k.meridiem,
              Ce = function (tt, Ge, V, be) {
                return (tt && (tt[Ge] || tt(ne, W))) || V[Ge].slice(0, be);
              },
              Ze = function (tt) {
                return I.s(ee % 12 || 12, tt, "0");
              },
              ze =
                ye ||
                function (tt, Ge, V) {
                  var be = tt < 12 ? "AM" : "PM";
                  return V ? be.toLowerCase() : be;
                };
            return W.replace(d, function (tt, Ge) {
              return (
                Ge ||
                (function (V) {
                  switch (V) {
                    case "YY":
                      return String(ne.$y).slice(-2);
                    case "YYYY":
                      return I.s(ne.$y, 4, "0");
                    case "M":
                      return xe + 1;
                    case "MM":
                      return I.s(xe + 1, 2, "0");
                    case "MMM":
                      return Ce(k.monthsShort, xe, de, 3);
                    case "MMMM":
                      return Ce(de, xe);
                    case "D":
                      return ne.$D;
                    case "DD":
                      return I.s(ne.$D, 2, "0");
                    case "d":
                      return String(ne.$W);
                    case "dd":
                      return Ce(k.weekdaysMin, ne.$W, te, 2);
                    case "ddd":
                      return Ce(k.weekdaysShort, ne.$W, te, 3);
                    case "dddd":
                      return te[ne.$W];
                    case "H":
                      return String(ee);
                    case "HH":
                      return I.s(ee, 2, "0");
                    case "h":
                      return Ze(1);
                    case "hh":
                      return Ze(2);
                    case "a":
                      return ze(ee, ae, !0);
                    case "A":
                      return ze(ee, ae, !1);
                    case "m":
                      return String(ae);
                    case "mm":
                      return I.s(ae, 2, "0");
                    case "s":
                      return String(ne.$s);
                    case "ss":
                      return I.s(ne.$s, 2, "0");
                    case "SSS":
                      return I.s(ne.$ms, 3, "0");
                    case "Z":
                      return H;
                  }
                  return null;
                })(tt) ||
                H.replace(":", "")
              );
            });
          }),
          (X.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }),
          (X.diff = function (G, ne, k) {
            var W,
              H = this,
              ee = I.p(ne),
              ae = P(G),
              xe = (ae.utcOffset() - this.utcOffset()) * i,
              te = this - ae,
              de = function () {
                return I.m(H, ae);
              };
            switch (ee) {
              case S:
                W = de() / 12;
                break;
              case v:
                W = de();
                break;
              case y:
                W = de() / 3;
                break;
              case p:
                W = (te - xe) / 6048e5;
                break;
              case h:
                W = (te - xe) / 864e5;
                break;
              case u:
                W = te / r;
                break;
              case a:
                W = te / i;
                break;
              case o:
                W = te / t;
                break;
              default:
                W = te;
            }
            return k ? W : I.a(W);
          }),
          (X.daysInMonth = function () {
            return this.endOf(v).$D;
          }),
          (X.$locale = function () {
            return C[this.$L];
          }),
          (X.locale = function (G, ne) {
            if (!G) return this.$L;
            var k = this.clone(),
              W = N(G, ne, !0);
            return W && (k.$L = W), k;
          }),
          (X.clone = function () {
            return I.w(this.$d, this);
          }),
          (X.toDate = function () {
            return new Date(this.valueOf());
          }),
          (X.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }),
          (X.toISOString = function () {
            return this.$d.toISOString();
          }),
          (X.toString = function () {
            return this.$d.toUTCString();
          }),
          F
        );
      })(),
      ue = Q.prototype;
    return (
      (P.prototype = ue),
      [
        ["$ms", s],
        ["$s", o],
        ["$m", a],
        ["$H", u],
        ["$W", h],
        ["$M", v],
        ["$y", S],
        ["$D", x],
      ].forEach(function (F) {
        ue[F[1]] = function (X) {
          return this.$g(X, F[0], F[1]);
        };
      }),
      (P.extend = function (F, X) {
        return F.$i || (F(X, Q, P), (F.$i = !0)), P;
      }),
      (P.locale = N),
      (P.isDayjs = L),
      (P.unix = function (F) {
        return P(1e3 * F);
      }),
      (P.en = C[T]),
      (P.Ls = C),
      (P.p = {}),
      P
    );
  });
})(c2);
var jk = c2.exports;
const Xk = Wg(jk);
async function qk(n, e = 5) {
  if (!n) throw new Error("Location is required to fetch the forecast");
  const t = `https://api.open-meteo.com/v1/forecast?latitude=${n.latitude}&longitude=${n.longitude}&forecast_days=${e}&temperature_unit=fahrenheit&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=auto`,
    i = await fetch(t);
  if (!i.ok) throw new Error("Failed to fetch forecast data");
  return await i.json();
}
function $k(n) {
  return r2({
    queryKey: [
      "weather",
      "multiDayForecast",
      {
        lat: n == null ? void 0 : n.latitude,
        long: n == null ? void 0 : n.longitude,
      },
    ],
    queryFn: () => qk(n),
    enabled: !!n,
  });
}
function Yk({ day: n, index: e, units: t }) {
  const i = u2({ weather_code: n.weatherCode, is_day: 1 });
  return ce.jsxs(
    mf,
    {
      className: "snap-center w-20 shrink-0",
      children: [
        ce.jsx("h4", {
          className: "font-bold",
          children: Xk(n.date).format("ddd"),
        }),
        ce.jsxs("div", {
          children: [
            "L:",
            Math.round(n.temperatureMin ?? 0),
            t == null ? void 0 : t.temperature_2m_min,
          ],
        }),
        ce.jsxs("div", {
          children: [
            "H:",
            Math.round(n.temperatureMax ?? 0),
            t == null ? void 0 : t.temperature_2m_max,
          ],
        }),
        ce.jsx("div", {
          className: "flex justify-center align-middle",
          children: ce.jsx("img", {
            alt: "Weather icon",
            src: `/weather/${i}`,
            style: { height: fT, width: fT },
          }),
        }),
      ],
    },
    e,
  );
}
const fT = "72px";
function Kk({ selectedLocation: n }) {
  const { data: e } = $k(n),
    t = se.useRef(null),
    i = se.useMemo(() => (e ? Qk(e) : []), [e]);
  return (
    se.useEffect(() => {
      const r = (o) => {
          t.current.scrollLeft === 0 && o.deltaX < 0 && o.preventDefault();
        },
        s = t.current;
      return (
        s.addEventListener("wheel", r, { passive: !1 }),
        () => {
          s.removeEventListener("wheel", r);
        }
      );
    }, []),
    n
      ? ce.jsxs(ce.Fragment, {
          children: [
            ce.jsx("h1", {
              className: "text-center",
              children: "5 Day Forecast",
            }),
            ce.jsx("div", {
              className: "snap-x snap-mandatory overflow-x-auto pb-2",
              ref: t,
              children: ce.jsx("div", {
                className:
                  "flex gap-2 justify-between w-full lg:justify-center",
                children: i.map((r, s) =>
                  ce.jsx(
                    Yk,
                    {
                      day: r,
                      index: s,
                      units: e == null ? void 0 : e.daily_units,
                    },
                    r.date,
                  ),
                ),
              }),
            }),
          ],
        })
      : "No location"
  );
}
function Qk(n) {
  const { daily: e } = n;
  return e.time
    .slice(0, 5)
    .map((t, i) => ({
      date: t,
      temperatureMax: e.temperature_2m_max[i],
      temperatureMin: e.temperature_2m_min[i],
      weatherCode: e.weathercode[i],
    }));
}
const Zk = 0;
async function Jk(n) {
  if (!n) return {};
  const e = {
      latitude: n.latitude.toString(),
      longitude: n.longitude.toString(),
      current: [
        "temperature_2m",
        "relative_humidity_2m",
        "is_day",
        "precipitation",
        "snowfall",
        "weather_code",
        "cloud_cover",
        "wind_speed_10m",
        "wind_direction_10m",
      ].toString(),
      hourly: [
        "temperature_2m",
        "relative_humidity_2m",
        "apparent_temperature",
        "precipitation_probability",
        "precipitation",
        "weather_code",
        "cloud_cover",
        "visibility",
        "wind_speed_10m",
        "wind_direction_10m",
      ].toString(),
      temperature_unit: "fahrenheit",
      wind_speed_unit: "mph",
      precipitation_unit: "inch",
    },
    i = `https://api.open-meteo.com/v1/forecast?${new URLSearchParams(e).toString()}`;
  return new Promise((r, s) => {
    setTimeout(async () => {
      try {
        const o = await fetch(i);
        if (o.ok) r(await o.json());
        else {
          const a =
            o.status === 400
              ? "Invalid geolocation params."
              : "Network response was not ok";
          throw new Error(a);
        }
      } catch (o) {
        s(o);
      }
    }, Zk);
  });
}
function d2(n) {
  return r2({
    queryKey: [
      "weather",
      {
        lat: n == null ? void 0 : n.latitude,
        long: n == null ? void 0 : n.longitude,
      },
    ],
    queryFn: () => Jk(n),
    enabled: !!n,
  });
}
const eU = {
  0: {
    day: { icon: "clear-day.svg", backgroundColor: "#87CEEB" },
    night: { icon: "clear-night.svg", backgroundColor: "#2F2F2F" },
  },
  1: {
    day: { icon: "partly-cloudy-day.svg", backgroundColor: "#B0C4DE" },
    night: { icon: "partly-cloudy-night.svg", backgroundColor: "#424242" },
  },
  2: {
    day: { icon: "cloudy.svg", backgroundColor: "#A9A9A9" },
    night: { icon: "cloudy.svg", backgroundColor: "#424242" },
  },
  3: {
    day: { icon: "cloudy.svg", backgroundColor: "#A9A9A9" },
    night: { icon: "cloudy.svg", backgroundColor: "#424242" },
  },
  45: {
    day: { icon: "fog-day.svg", backgroundColor: "#696969" },
    night: { icon: "fog-night.svg", backgroundColor: "#525252" },
  },
  48: {
    day: { icon: "fog-day.svg", backgroundColor: "#696969" },
    night: { icon: "fog-night.svg", backgroundColor: "#525252" },
  },
  51: {
    day: { icon: "drizzle.svg", backgroundColor: "#B0E0E6" },
    night: { icon: "drizzle.svg", backgroundColor: "#3B3B3B" },
  },
  53: {
    day: { icon: "rain.svg", backgroundColor: "#4682B4" },
    night: { icon: "rain.svg", backgroundColor: "#363636" },
  },
  55: {
    day: { icon: "rain.svg", backgroundColor: "#00008B" },
    night: { icon: "rain.svg", backgroundColor: "#2F2F2F" },
  },
  56: {
    day: { icon: "rain.svg", backgroundColor: "#4682B4" },
    night: { icon: "rain.svg", backgroundColor: "#363636" },
  },
  57: {
    day: { icon: "rain.svg", backgroundColor: "#00008B" },
    night: { icon: "rain.svg", backgroundColor: "#2F2F2F" },
  },
  61: {
    day: { icon: "rain.svg", backgroundColor: "#4682B4" },
    night: { icon: "rain.svg", backgroundColor: "#363636" },
  },
  63: {
    day: { icon: "rain.svg", backgroundColor: "#00008B" },
    night: { icon: "rain.svg", backgroundColor: "#2F2F2F" },
  },
  65: {
    day: { icon: "rain.svg", backgroundColor: "#00008B" },
    night: { icon: "rain.svg", backgroundColor: "#2F2F2F" },
  },
  66: {
    day: { icon: "rain.svg", backgroundColor: "#4682B4" },
    night: { icon: "rain.svg", backgroundColor: "#363636" },
  },
  67: {
    day: { icon: "rain.svg", backgroundColor: "#00008B" },
    night: { icon: "rain.svg", backgroundColor: "#2F2F2F" },
  },
  71: {
    day: { icon: "snow.svg", backgroundColor: "#B3E5FC" },
    night: { icon: "snow.svg", backgroundColor: "#2E3B4E" },
  },
  73: {
    day: { icon: "snow.svg", backgroundColor: "#B3E5FC" },
    night: { icon: "snow.svg", backgroundColor: "#2E3B4E" },
  },
  75: {
    day: { icon: "snow.svg", backgroundColor: "#7B68EE" },
    night: { icon: "snow.svg", backgroundColor: "#1C2331" },
  },
  77: {
    day: { icon: "snowflake.svg", backgroundColor: "#AFEEEE" },
    night: { icon: "snowflake.svg", backgroundColor: "#305A72" },
  },
  80: {
    day: { icon: "showers.svg", backgroundColor: "#4682B4" },
    night: { icon: "showers.svg", backgroundColor: "#363636" },
  },
  81: {
    day: { icon: "showers.svg", backgroundColor: "#4682B4" },
    night: { icon: "showers.svg", backgroundColor: "#363636" },
  },
  82: {
    day: { icon: "thunderstorm.svg", backgroundColor: "#0B3D91" },
    night: { icon: "thunderstorm.svg", backgroundColor: "#1E2433" },
  },
  85: {
    day: { icon: "snow.svg", backgroundColor: "#B3E5FC" },
    night: { icon: "snow.svg", backgroundColor: "#2E3B4E" },
  },
  86: {
    day: { icon: "snow.svg", backgroundColor: "#7B68EE" },
    night: { icon: "snow.svg", backgroundColor: "#1C2331" },
  },
  95: {
    day: { icon: "thunderstorm.svg", backgroundColor: "#0B3D91" },
    night: { icon: "thunderstorm.svg", backgroundColor: "#1E2433" },
  },
  96: {
    day: { icon: "thunderstorm.svg", backgroundColor: "#0B3D91" },
    night: { icon: "thunderstorm.svg", backgroundColor: "#1E2433" },
  },
  99: {
    day: { icon: "thunderstorm.svg", backgroundColor: "#0B3D91" },
    night: { icon: "thunderstorm.svg", backgroundColor: "#1E2433" },
  },
};
function tU({ weatherCode: n, isDaytime: e }) {
  return se.useMemo(() => {
    const t = { icon: "clear-day.svg", backgroundColor: "#FFFFFF" },
      i = eU[n] || { day: t, night: t };
    return e ? i.day : i.night;
  }, [e, n]);
}
function nU(n) {
  const [e, t] = se.useState(null),
    [i, r] = se.useState(null);
  return (
    se.useEffect(() => {
      let s = !0;
      const o = new google.maps.Geocoder();
      return (
        n &&
          ((u) => {
            const h = { lat: u.latitude, lng: u.longitude };
            o.geocode({ location: h }, (p, v) => {
              const y =
                v === "INVALID_REQUEST"
                  ? "Invalid lat/long"
                  : "Geocoder failed due to: " + v;
              if (
                v === google.maps.GeocoderStatus.OK &&
                p != null &&
                p.length &&
                p[0]
              ) {
                if ((r(null), s)) {
                  const S = iU(p);
                  t({
                    latitude: u.latitude,
                    longitude: u.longitude,
                    label: p[0].formatted_address,
                    ...S,
                  });
                }
              } else
                console.error("Geocoder failed due to: " + v),
                  r(new Error(y)),
                  s && t(null);
            });
          })(n),
        () => {
          s = !1;
        }
      );
    }, [n]),
    { location: e, error: i }
  );
}
function iU(n) {
  const e = { city: "", state: "" };
  for (const t of n)
    for (const i of t.address_components)
      if (
        (i.types.includes("locality")
          ? (e.city = i.long_name)
          : i.types.includes("administrative_area_level_1") &&
            (e.state = i.short_name),
        e.city && e.state)
      )
        return e;
  return e.city && e.state ? e : null;
}
function Ma() {
  return (
    (Ma = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Ma.apply(this, arguments)
  );
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const gf = "161",
  rU = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  sU = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  h2 = 0,
  Tx = 1,
  f2 = 2,
  oU = 3,
  p2 = 0,
  hv = 1,
  eh = 2,
  Jr = 3,
  go = 0,
  Ui = 1,
  bs = 2,
  uo = 0,
  Pl = 1,
  Cx = 2,
  bx = 3,
  Ax = 4,
  m2 = 5,
  Jo = 100,
  g2 = 101,
  v2 = 102,
  Px = 103,
  Rx = 104,
  y2 = 200,
  _2 = 201,
  x2 = 202,
  S2 = 203,
  Dg = 204,
  kg = 205,
  w2 = 206,
  M2 = 207,
  E2 = 208,
  T2 = 209,
  C2 = 210,
  b2 = 211,
  A2 = 212,
  P2 = 213,
  R2 = 214,
  L2 = 0,
  I2 = 1,
  O2 = 2,
  bh = 3,
  N2 = 4,
  D2 = 5,
  k2 = 6,
  U2 = 7,
  vf = 0,
  F2 = 1,
  B2 = 2,
  Is = 0,
  z2 = 1,
  H2 = 2,
  V2 = 3,
  ww = 4,
  G2 = 5,
  W2 = 6,
  Lx = "attached",
  j2 = "detached",
  fv = 300,
  vo = 301,
  Ea = 302,
  Ah = 303,
  Ph = 304,
  jc = 306,
  Rh = 1e3,
  Mi = 1001,
  Lh = 1002,
  In = 1003,
  Ug = 1004,
  aU = 1004,
  ul = 1005,
  lU = 1005,
  xn = 1006,
  th = 1007,
  uU = 1007,
  As = 1008,
  cU = 1008,
  Os = 1009,
  X2 = 1010,
  q2 = 1011,
  pv = 1012,
  Mw = 1013,
  so = 1014,
  Br = 1015,
  Uc = 1016,
  Ew = 1017,
  Tw = 1018,
  ya = 1020,
  $2 = 1021,
  Ni = 1023,
  Y2 = 1024,
  K2 = 1025,
  _a = 1026,
  Hl = 1027,
  Q2 = 1028,
  Cw = 1029,
  Z2 = 1030,
  bw = 1031,
  Aw = 1033,
  Jm = 33776,
  eg = 33777,
  tg = 33778,
  ng = 33779,
  Ix = 35840,
  Ox = 35841,
  Nx = 35842,
  Dx = 35843,
  Pw = 36196,
  kx = 37492,
  Ux = 37496,
  Fx = 37808,
  Bx = 37809,
  zx = 37810,
  Hx = 37811,
  Vx = 37812,
  Gx = 37813,
  Wx = 37814,
  jx = 37815,
  Xx = 37816,
  qx = 37817,
  $x = 37818,
  Yx = 37819,
  Kx = 37820,
  Qx = 37821,
  ig = 36492,
  Zx = 36494,
  Jx = 36495,
  J2 = 36283,
  eS = 36284,
  tS = 36285,
  nS = 36286,
  eR = 2200,
  tR = 2201,
  nR = 2202,
  Ih = 2300,
  Oh = 2301,
  rg = 2302,
  pl = 2400,
  ml = 2401,
  Nh = 2402,
  mv = 2500,
  Rw = 2501,
  dU = 0,
  hU = 1,
  fU = 2,
  Lw = 3e3,
  xa = 3001,
  iR = 3200,
  rR = 3201,
  La = 0,
  sR = 1,
  dr = "",
  Wn = "srgb",
  Ds = "srgb-linear",
  gv = "display-p3",
  yf = "display-p3-linear",
  Dh = "linear",
  un = "srgb",
  kh = "rec709",
  Uh = "p3",
  pU = 0,
  ol = 7680,
  mU = 7681,
  gU = 7682,
  vU = 7683,
  yU = 34055,
  _U = 34056,
  xU = 5386,
  SU = 512,
  wU = 513,
  MU = 514,
  EU = 515,
  TU = 516,
  CU = 517,
  bU = 518,
  iS = 519,
  oR = 512,
  aR = 513,
  lR = 514,
  Iw = 515,
  uR = 516,
  cR = 517,
  dR = 518,
  hR = 519,
  Fh = 35044,
  rS = 35048,
  AU = 35040,
  PU = 35045,
  RU = 35049,
  LU = 35041,
  IU = 35046,
  OU = 35050,
  NU = 35042,
  DU = "100",
  sS = "300 es",
  Fg = 1035,
  Ps = 2e3,
  Bh = 2001;
class xo {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const _i = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let pT = 1234567;
const Rl = Math.PI / 180,
  Fc = 180 / Math.PI;
function gr() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    _i[n & 255] +
    _i[(n >> 8) & 255] +
    _i[(n >> 16) & 255] +
    _i[(n >> 24) & 255] +
    "-" +
    _i[e & 255] +
    _i[(e >> 8) & 255] +
    "-" +
    _i[((e >> 16) & 15) | 64] +
    _i[(e >> 24) & 255] +
    "-" +
    _i[(t & 63) | 128] +
    _i[(t >> 8) & 255] +
    "-" +
    _i[(t >> 16) & 255] +
    _i[(t >> 24) & 255] +
    _i[i & 255] +
    _i[(i >> 8) & 255] +
    _i[(i >> 16) & 255] +
    _i[(i >> 24) & 255]
  ).toLowerCase();
}
function An(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Ow(n, e) {
  return ((n % e) + e) % e;
}
function kU(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function UU(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function nh(n, e, t) {
  return (1 - t) * n + t * e;
}
function FU(n, e, t, i) {
  return nh(n, e, 1 - Math.exp(-t * i));
}
function BU(n, e = 1) {
  return e - Math.abs(Ow(n, e * 2) - e);
}
function zU(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function HU(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function VU(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function GU(n, e) {
  return n + Math.random() * (e - n);
}
function WU(n) {
  return n * (0.5 - Math.random());
}
function jU(n) {
  n !== void 0 && (pT = n);
  let e = (pT += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function XU(n) {
  return n * Rl;
}
function qU(n) {
  return n * Fc;
}
function oS(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function $U(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Bg(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function YU(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    u = o(t / 2),
    h = s((e + i) / 2),
    p = o((e + i) / 2),
    v = s((e - i) / 2),
    y = o((e - i) / 2),
    S = s((i - e) / 2),
    x = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * p, u * v, u * y, a * h);
      break;
    case "YZY":
      n.set(u * y, a * p, u * v, a * h);
      break;
    case "ZXZ":
      n.set(u * v, u * y, a * p, a * h);
      break;
    case "XZX":
      n.set(a * p, u * x, u * S, a * h);
      break;
    case "YXY":
      n.set(u * S, a * p, u * x, a * h);
      break;
    case "ZYZ":
      n.set(u * x, u * S, a * p, a * h);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r,
      );
  }
}
function Di(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Pt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const KU = {
  DEG2RAD: Rl,
  RAD2DEG: Fc,
  generateUUID: gr,
  clamp: An,
  euclideanModulo: Ow,
  mapLinear: kU,
  inverseLerp: UU,
  lerp: nh,
  damp: FU,
  pingpong: BU,
  smoothstep: zU,
  smootherstep: HU,
  randInt: VU,
  randFloat: GU,
  randFloatSpread: WU,
  seededRandom: jU,
  degToRad: XU,
  radToDeg: qU,
  isPowerOfTwo: oS,
  ceilPowerOfTwo: $U,
  floorPowerOfTwo: Bg,
  setQuaternionFromProperEuler: YU,
  normalize: Pt,
  denormalize: Di,
};
class Me {
  constructor(e = 0, t = 0) {
    (Me.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i)),
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(An(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Nt {
  constructor(e, t, i, r, s, o, a, u, h) {
    (Nt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, u, h);
  }
  set(e, t, i, r, s, o, a, u, h) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[1] = r),
      (p[2] = a),
      (p[3] = t),
      (p[4] = s),
      (p[5] = u),
      (p[6] = i),
      (p[7] = o),
      (p[8] = h),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      u = i[6],
      h = i[1],
      p = i[4],
      v = i[7],
      y = i[2],
      S = i[5],
      x = i[8],
      _ = r[0],
      f = r[3],
      d = r[6],
      m = r[1],
      g = r[4],
      w = r[7],
      T = r[2],
      C = r[5],
      A = r[8];
    return (
      (s[0] = o * _ + a * m + u * T),
      (s[3] = o * f + a * g + u * C),
      (s[6] = o * d + a * w + u * A),
      (s[1] = h * _ + p * m + v * T),
      (s[4] = h * f + p * g + v * C),
      (s[7] = h * d + p * w + v * A),
      (s[2] = y * _ + S * m + x * T),
      (s[5] = y * f + S * g + x * C),
      (s[8] = y * d + S * w + x * A),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      h = e[7],
      p = e[8];
    return (
      t * o * p - t * a * h - i * s * p + i * a * u + r * s * h - r * o * u
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      h = e[7],
      p = e[8],
      v = p * o - a * h,
      y = a * u - p * s,
      S = h * s - o * u,
      x = t * v + i * y + r * S;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / x;
    return (
      (e[0] = v * _),
      (e[1] = (r * h - p * i) * _),
      (e[2] = (a * i - r * o) * _),
      (e[3] = y * _),
      (e[4] = (p * t - r * u) * _),
      (e[5] = (r * s - a * t) * _),
      (e[6] = S * _),
      (e[7] = (i * u - h * t) * _),
      (e[8] = (o * t - i * s) * _),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const u = Math.cos(s),
      h = Math.sin(s);
    return (
      this.set(
        i * u,
        i * h,
        -i * (u * o + h * a) + o + e,
        -r * h,
        r * u,
        -r * (-h * o + u * a) + a + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(w0.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(w0.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(w0.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const w0 = new Nt();
function fR(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const QU = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ju(n, e) {
  return new QU[n](e);
}
function zh(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function pR() {
  const n = zh("canvas");
  return (n.style.display = "block"), n;
}
const mT = {};
function Ll(n) {
  n in mT || ((mT[n] = !0), console.warn(n));
}
const gT = new Nt().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199,
  ),
  vT = new Nt().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735,
  ),
  Bp = {
    [Ds]: {
      transfer: Dh,
      primaries: kh,
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Wn]: {
      transfer: un,
      primaries: kh,
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [yf]: {
      transfer: Dh,
      primaries: Uh,
      toReference: (n) => n.applyMatrix3(vT),
      fromReference: (n) => n.applyMatrix3(gT),
    },
    [gv]: {
      transfer: un,
      primaries: Uh,
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(vT),
      fromReference: (n) => n.applyMatrix3(gT).convertLinearToSRGB(),
    },
  },
  ZU = new Set([Ds, yf]),
  nn = {
    enabled: !0,
    _workingColorSpace: Ds,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!ZU.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = Bp[e].toReference,
        r = Bp[t].fromReference;
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return Bp[n].primaries;
    },
    getTransfer: function (n) {
      return n === dr ? Dh : Bp[n].transfer;
    },
  };
function dc(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function M0(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let mu;
class Nw {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      mu === void 0 && (mu = zh("canvas")),
        (mu.width = e.width),
        (mu.height = e.height);
      const i = mu.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = mu);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e,
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = zh("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = dc(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(dc(t[i] / 255) * 255))
          : (t[i] = dc(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        e
      );
  }
}
let JU = 0;
class gl {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: JU++ }),
      (this.uuid = gr()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(E0(r[o].image)) : s.push(E0(r[o]));
      } else s = E0(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function E0(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? Nw.getDataURL(n)
    : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let eF = 0;
class Mn extends xo {
  constructor(
    e = Mn.DEFAULT_IMAGE,
    t = Mn.DEFAULT_MAPPING,
    i = Mi,
    r = Mi,
    s = xn,
    o = As,
    a = Ni,
    u = Os,
    h = Mn.DEFAULT_ANISOTROPY,
    p = dr,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: eF++ }),
      (this.uuid = gr()),
      (this.name = ""),
      (this.source = new gl(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = h),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new Me(0, 0)),
      (this.repeat = new Me(1, 1)),
      (this.center = new Me(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Nt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof p == "string"
        ? (this.colorSpace = p)
        : (Ll(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace.",
          ),
          (this.colorSpace = p === xa ? Wn : dr)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== fv) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Rh:
          e.x = e.x - Math.floor(e.x);
          break;
        case Mi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Lh:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Rh:
          e.y = e.y - Math.floor(e.y);
          break;
        case Mi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Lh:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Ll("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Wn ? xa : Lw
    );
  }
  set encoding(e) {
    Ll("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === xa ? Wn : dr);
  }
}
Mn.DEFAULT_IMAGE = null;
Mn.DEFAULT_MAPPING = fv;
Mn.DEFAULT_ANISOTROPY = 1;
class rn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (rn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const u = e.elements,
      h = u[0],
      p = u[4],
      v = u[8],
      y = u[1],
      S = u[5],
      x = u[9],
      _ = u[2],
      f = u[6],
      d = u[10];
    if (
      Math.abs(p - y) < 0.01 &&
      Math.abs(v - _) < 0.01 &&
      Math.abs(x - f) < 0.01
    ) {
      if (
        Math.abs(p + y) < 0.1 &&
        Math.abs(v + _) < 0.1 &&
        Math.abs(x + f) < 0.1 &&
        Math.abs(h + S + d - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const g = (h + 1) / 2,
        w = (S + 1) / 2,
        T = (d + 1) / 2,
        C = (p + y) / 4,
        A = (v + _) / 4,
        L = (x + f) / 4;
      return (
        g > w && g > T
          ? g < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(g)), (r = C / i), (s = A / i))
          : w > T
            ? w < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(w)), (i = C / r), (s = L / r))
            : T < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(T)), (i = A / s), (r = L / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let m = Math.sqrt(
      (f - x) * (f - x) + (v - _) * (v - _) + (y - p) * (y - p),
    );
    return (
      Math.abs(m) < 0.001 && (m = 1),
      (this.x = (f - x) / m),
      (this.y = (v - _) / m),
      (this.z = (y - p) / m),
      (this.w = Math.acos((h + S + d - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i)),
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class mR extends xo {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new rn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new rn(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 &&
      (Ll(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.",
      ),
      (i.colorSpace = i.encoding === xa ? Wn : dr)),
      (i = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: xn,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        i,
      )),
      (this.texture = new Mn(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace,
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = i.generateMipmaps),
      (this.texture.internalFormat = i.internalFormat),
      (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new gl(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class as extends mR {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class vv extends Mn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = In),
      (this.minFilter = In),
      (this.wrapR = Mi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class tF extends as {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new vv(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Dw extends Mn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = In),
      (this.minFilter = In),
      (this.wrapR = Mi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class nF extends as {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Dw(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class iF extends as {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let r = 0, s = this.texture.length; r < s; r++)
        (this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, i = e.texture.length; t < i; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class li {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let u = i[r + 0],
      h = i[r + 1],
      p = i[r + 2],
      v = i[r + 3];
    const y = s[o + 0],
      S = s[o + 1],
      x = s[o + 2],
      _ = s[o + 3];
    if (a === 0) {
      (e[t + 0] = u), (e[t + 1] = h), (e[t + 2] = p), (e[t + 3] = v);
      return;
    }
    if (a === 1) {
      (e[t + 0] = y), (e[t + 1] = S), (e[t + 2] = x), (e[t + 3] = _);
      return;
    }
    if (v !== _ || u !== y || h !== S || p !== x) {
      let f = 1 - a;
      const d = u * y + h * S + p * x + v * _,
        m = d >= 0 ? 1 : -1,
        g = 1 - d * d;
      if (g > Number.EPSILON) {
        const T = Math.sqrt(g),
          C = Math.atan2(T, d * m);
        (f = Math.sin(f * C) / T), (a = Math.sin(a * C) / T);
      }
      const w = a * m;
      if (
        ((u = u * f + y * w),
        (h = h * f + S * w),
        (p = p * f + x * w),
        (v = v * f + _ * w),
        f === 1 - a)
      ) {
        const T = 1 / Math.sqrt(u * u + h * h + p * p + v * v);
        (u *= T), (h *= T), (p *= T), (v *= T);
      }
    }
    (e[t] = u), (e[t + 1] = h), (e[t + 2] = p), (e[t + 3] = v);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      u = i[r + 1],
      h = i[r + 2],
      p = i[r + 3],
      v = s[o],
      y = s[o + 1],
      S = s[o + 2],
      x = s[o + 3];
    return (
      (e[t] = a * x + p * v + u * S - h * y),
      (e[t + 1] = u * x + p * y + h * v - a * S),
      (e[t + 2] = h * x + p * S + a * y - u * v),
      (e[t + 3] = p * x - a * v - u * y - h * S),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      u = Math.sin,
      h = a(i / 2),
      p = a(r / 2),
      v = a(s / 2),
      y = u(i / 2),
      S = u(r / 2),
      x = u(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = y * p * v + h * S * x),
          (this._y = h * S * v - y * p * x),
          (this._z = h * p * x + y * S * v),
          (this._w = h * p * v - y * S * x);
        break;
      case "YXZ":
        (this._x = y * p * v + h * S * x),
          (this._y = h * S * v - y * p * x),
          (this._z = h * p * x - y * S * v),
          (this._w = h * p * v + y * S * x);
        break;
      case "ZXY":
        (this._x = y * p * v - h * S * x),
          (this._y = h * S * v + y * p * x),
          (this._z = h * p * x + y * S * v),
          (this._w = h * p * v - y * S * x);
        break;
      case "ZYX":
        (this._x = y * p * v - h * S * x),
          (this._y = h * S * v + y * p * x),
          (this._z = h * p * x - y * S * v),
          (this._w = h * p * v + y * S * x);
        break;
      case "YZX":
        (this._x = y * p * v + h * S * x),
          (this._y = h * S * v + y * p * x),
          (this._z = h * p * x - y * S * v),
          (this._w = h * p * v - y * S * x);
        break;
      case "XZY":
        (this._x = y * p * v - h * S * x),
          (this._y = h * S * v - y * p * x),
          (this._z = h * p * x + y * S * v),
          (this._w = h * p * v + y * S * x);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            o,
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      u = t[9],
      h = t[2],
      p = t[6],
      v = t[10],
      y = i + a + v;
    if (y > 0) {
      const S = 0.5 / Math.sqrt(y + 1);
      (this._w = 0.25 / S),
        (this._x = (p - u) * S),
        (this._y = (s - h) * S),
        (this._z = (o - r) * S);
    } else if (i > a && i > v) {
      const S = 2 * Math.sqrt(1 + i - a - v);
      (this._w = (p - u) / S),
        (this._x = 0.25 * S),
        (this._y = (r + o) / S),
        (this._z = (s + h) / S);
    } else if (a > v) {
      const S = 2 * Math.sqrt(1 + a - i - v);
      (this._w = (s - h) / S),
        (this._x = (r + o) / S),
        (this._y = 0.25 * S),
        (this._z = (u + p) / S);
    } else {
      const S = 2 * Math.sqrt(1 + v - i - a);
      (this._w = (o - r) / S),
        (this._x = (s + h) / S),
        (this._y = (u + p) / S),
        (this._z = 0.25 * S);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(An(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      u = t._y,
      h = t._z,
      p = t._w;
    return (
      (this._x = i * p + o * a + r * h - s * u),
      (this._y = r * p + o * u + s * a - i * h),
      (this._z = s * p + o * h + i * u - r * a),
      (this._w = o * p - i * a - r * u - s * h),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const u = 1 - a * a;
    if (u <= Number.EPSILON) {
      const S = 1 - t;
      return (
        (this._w = S * o + t * this._w),
        (this._x = S * i + t * this._x),
        (this._y = S * r + t * this._y),
        (this._z = S * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const h = Math.sqrt(u),
      p = Math.atan2(h, a),
      v = Math.sin((1 - t) * p) / h,
      y = Math.sin(t * p) / h;
    return (
      (this._w = o * v + this._w * y),
      (this._x = i * v + this._x * y),
      (this._y = r * v + this._y * y),
      (this._z = s * v + this._z * y),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r),
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class B {
  constructor(e = 0, t = 0, i = 0) {
    (B.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(yT.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(yT.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      u = e.w,
      h = 2 * (o * r - a * i),
      p = 2 * (a * t - s * r),
      v = 2 * (s * i - o * t);
    return (
      (this.x = t + u * h + o * v - a * p),
      (this.y = i + u * p + a * h - s * v),
      (this.z = r + u * v + s * p - o * h),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i)),
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      u = t.z;
    return (
      (this.x = r * u - s * a),
      (this.y = s * o - i * u),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return T0.copy(this).projectOnVector(e), this.sub(T0);
  }
  reflect(e) {
    return this.sub(T0.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(An(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const T0 = new B(),
  yT = new li();
class Fi {
  constructor(
    e = new B(1 / 0, 1 / 0, 1 / 0),
    t = new B(-1 / 0, -1 / 0, -1 / 0),
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Yr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Yr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Yr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Yr)
            : Yr.fromBufferAttribute(s, o),
            Yr.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Yr);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            zp.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            zp.copy(i.boundingBox)),
          zp.applyMatrix4(e.matrixWorld),
          this.union(zp);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Yr),
      Yr.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Md),
      Hp.subVectors(this.max, Md),
      gu.subVectors(e.a, Md),
      vu.subVectors(e.b, Md),
      yu.subVectors(e.c, Md),
      Uo.subVectors(vu, gu),
      Fo.subVectors(yu, vu),
      $a.subVectors(gu, yu);
    let t = [
      0,
      -Uo.z,
      Uo.y,
      0,
      -Fo.z,
      Fo.y,
      0,
      -$a.z,
      $a.y,
      Uo.z,
      0,
      -Uo.x,
      Fo.z,
      0,
      -Fo.x,
      $a.z,
      0,
      -$a.x,
      -Uo.y,
      Uo.x,
      0,
      -Fo.y,
      Fo.x,
      0,
      -$a.y,
      $a.x,
      0,
    ];
    return !C0(t, gu, vu, yu, Hp) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !C0(t, gu, vu, yu, Hp))
      ? !1
      : (Vp.crossVectors(Uo, Fo),
        (t = [Vp.x, Vp.y, Vp.z]),
        C0(t, gu, vu, yu, Hp));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Yr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Yr).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (qs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        qs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        qs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        qs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        qs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        qs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        qs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        qs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(qs),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const qs = [
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
  ],
  Yr = new B(),
  zp = new Fi(),
  gu = new B(),
  vu = new B(),
  yu = new B(),
  Uo = new B(),
  Fo = new B(),
  $a = new B(),
  Md = new B(),
  Hp = new B(),
  Vp = new B(),
  Ya = new B();
function C0(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    Ya.fromArray(n, s);
    const a =
        r.x * Math.abs(Ya.x) + r.y * Math.abs(Ya.y) + r.z * Math.abs(Ya.z),
      u = e.dot(Ya),
      h = t.dot(Ya),
      p = i.dot(Ya);
    if (Math.max(-Math.max(u, h, p), Math.min(u, h, p)) > a) return !1;
  }
  return !0;
}
const rF = new Fi(),
  Ed = new B(),
  b0 = new B();
class Ei {
  constructor(e = new B(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : rF.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Ed.subVectors(e, this.center);
    const t = Ed.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Ed, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (b0.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Ed.copy(e.center).add(b0)),
              this.expandByPoint(Ed.copy(e.center).sub(b0))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $s = new B(),
  A0 = new B(),
  Gp = new B(),
  Bo = new B(),
  P0 = new B(),
  Wp = new B(),
  R0 = new B();
class Xc {
  constructor(e = new B(), t = new B(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $s)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = $s.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : ($s.copy(this.origin).addScaledVector(this.direction, t),
        $s.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    A0.copy(e).add(t).multiplyScalar(0.5),
      Gp.copy(t).sub(e).normalize(),
      Bo.copy(this.origin).sub(A0);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Gp),
      a = Bo.dot(this.direction),
      u = -Bo.dot(Gp),
      h = Bo.lengthSq(),
      p = Math.abs(1 - o * o);
    let v, y, S, x;
    if (p > 0)
      if (((v = o * u - a), (y = o * a - u), (x = s * p), v >= 0))
        if (y >= -x)
          if (y <= x) {
            const _ = 1 / p;
            (v *= _),
              (y *= _),
              (S = v * (v + o * y + 2 * a) + y * (o * v + y + 2 * u) + h);
          } else
            (y = s),
              (v = Math.max(0, -(o * y + a))),
              (S = -v * v + y * (y + 2 * u) + h);
        else
          (y = -s),
            (v = Math.max(0, -(o * y + a))),
            (S = -v * v + y * (y + 2 * u) + h);
      else
        y <= -x
          ? ((v = Math.max(0, -(-o * s + a))),
            (y = v > 0 ? -s : Math.min(Math.max(-s, -u), s)),
            (S = -v * v + y * (y + 2 * u) + h))
          : y <= x
            ? ((v = 0),
              (y = Math.min(Math.max(-s, -u), s)),
              (S = y * (y + 2 * u) + h))
            : ((v = Math.max(0, -(o * s + a))),
              (y = v > 0 ? s : Math.min(Math.max(-s, -u), s)),
              (S = -v * v + y * (y + 2 * u) + h));
    else
      (y = o > 0 ? -s : s),
        (v = Math.max(0, -(o * y + a))),
        (S = -v * v + y * (y + 2 * u) + h);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, v),
      r && r.copy(A0).addScaledVector(Gp, y),
      S
    );
  }
  intersectSphere(e, t) {
    $s.subVectors(e.center, this.origin);
    const i = $s.dot(this.direction),
      r = $s.dot($s) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      u = i + o;
    return u < 0 ? null : a < 0 ? this.at(u, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, u;
    const h = 1 / this.direction.x,
      p = 1 / this.direction.y,
      v = 1 / this.direction.z,
      y = this.origin;
    return (
      h >= 0
        ? ((i = (e.min.x - y.x) * h), (r = (e.max.x - y.x) * h))
        : ((i = (e.max.x - y.x) * h), (r = (e.min.x - y.x) * h)),
      p >= 0
        ? ((s = (e.min.y - y.y) * p), (o = (e.max.y - y.y) * p))
        : ((s = (e.max.y - y.y) * p), (o = (e.min.y - y.y) * p)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      v >= 0
        ? ((a = (e.min.z - y.z) * v), (u = (e.max.z - y.z) * v))
        : ((a = (e.max.z - y.z) * v), (u = (e.min.z - y.z) * v)),
      i > u || a > r) ||
      ((a > i || i !== i) && (i = a), (u < r || r !== r) && (r = u), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, $s) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    P0.subVectors(t, e), Wp.subVectors(i, e), R0.crossVectors(P0, Wp);
    let o = this.direction.dot(R0),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    Bo.subVectors(this.origin, e);
    const u = a * this.direction.dot(Wp.crossVectors(Bo, Wp));
    if (u < 0) return null;
    const h = a * this.direction.dot(P0.cross(Bo));
    if (h < 0 || u + h > o) return null;
    const p = -a * Bo.dot(R0);
    return p < 0 ? null : this.at(p / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _t {
  constructor(e, t, i, r, s, o, a, u, h, p, v, y, S, x, _, f) {
    (_t.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, u, h, p, v, y, S, x, _, f);
  }
  set(e, t, i, r, s, o, a, u, h, p, v, y, S, x, _, f) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[4] = t),
      (d[8] = i),
      (d[12] = r),
      (d[1] = s),
      (d[5] = o),
      (d[9] = a),
      (d[13] = u),
      (d[2] = h),
      (d[6] = p),
      (d[10] = v),
      (d[14] = y),
      (d[3] = S),
      (d[7] = x),
      (d[11] = _),
      (d[15] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new _t().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / _u.setFromMatrixColumn(e, 0).length(),
      s = 1 / _u.setFromMatrixColumn(e, 1).length(),
      o = 1 / _u.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      u = Math.cos(r),
      h = Math.sin(r),
      p = Math.cos(s),
      v = Math.sin(s);
    if (e.order === "XYZ") {
      const y = o * p,
        S = o * v,
        x = a * p,
        _ = a * v;
      (t[0] = u * p),
        (t[4] = -u * v),
        (t[8] = h),
        (t[1] = S + x * h),
        (t[5] = y - _ * h),
        (t[9] = -a * u),
        (t[2] = _ - y * h),
        (t[6] = x + S * h),
        (t[10] = o * u);
    } else if (e.order === "YXZ") {
      const y = u * p,
        S = u * v,
        x = h * p,
        _ = h * v;
      (t[0] = y + _ * a),
        (t[4] = x * a - S),
        (t[8] = o * h),
        (t[1] = o * v),
        (t[5] = o * p),
        (t[9] = -a),
        (t[2] = S * a - x),
        (t[6] = _ + y * a),
        (t[10] = o * u);
    } else if (e.order === "ZXY") {
      const y = u * p,
        S = u * v,
        x = h * p,
        _ = h * v;
      (t[0] = y - _ * a),
        (t[4] = -o * v),
        (t[8] = x + S * a),
        (t[1] = S + x * a),
        (t[5] = o * p),
        (t[9] = _ - y * a),
        (t[2] = -o * h),
        (t[6] = a),
        (t[10] = o * u);
    } else if (e.order === "ZYX") {
      const y = o * p,
        S = o * v,
        x = a * p,
        _ = a * v;
      (t[0] = u * p),
        (t[4] = x * h - S),
        (t[8] = y * h + _),
        (t[1] = u * v),
        (t[5] = _ * h + y),
        (t[9] = S * h - x),
        (t[2] = -h),
        (t[6] = a * u),
        (t[10] = o * u);
    } else if (e.order === "YZX") {
      const y = o * u,
        S = o * h,
        x = a * u,
        _ = a * h;
      (t[0] = u * p),
        (t[4] = _ - y * v),
        (t[8] = x * v + S),
        (t[1] = v),
        (t[5] = o * p),
        (t[9] = -a * p),
        (t[2] = -h * p),
        (t[6] = S * v + x),
        (t[10] = y - _ * v);
    } else if (e.order === "XZY") {
      const y = o * u,
        S = o * h,
        x = a * u,
        _ = a * h;
      (t[0] = u * p),
        (t[4] = -v),
        (t[8] = h * p),
        (t[1] = y * v + _),
        (t[5] = o * p),
        (t[9] = S * v - x),
        (t[2] = x * v - S),
        (t[6] = a * p),
        (t[10] = _ * v + y);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(sF, e, oF);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      or.subVectors(e, t),
      or.lengthSq() === 0 && (or.z = 1),
      or.normalize(),
      zo.crossVectors(i, or),
      zo.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (or.x += 1e-4) : (or.z += 1e-4),
        or.normalize(),
        zo.crossVectors(i, or)),
      zo.normalize(),
      jp.crossVectors(or, zo),
      (r[0] = zo.x),
      (r[4] = jp.x),
      (r[8] = or.x),
      (r[1] = zo.y),
      (r[5] = jp.y),
      (r[9] = or.y),
      (r[2] = zo.z),
      (r[6] = jp.z),
      (r[10] = or.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      u = i[8],
      h = i[12],
      p = i[1],
      v = i[5],
      y = i[9],
      S = i[13],
      x = i[2],
      _ = i[6],
      f = i[10],
      d = i[14],
      m = i[3],
      g = i[7],
      w = i[11],
      T = i[15],
      C = r[0],
      A = r[4],
      L = r[8],
      N = r[12],
      P = r[1],
      I = r[5],
      Q = r[9],
      ue = r[13],
      F = r[2],
      X = r[6],
      G = r[10],
      ne = r[14],
      k = r[3],
      W = r[7],
      H = r[11],
      ee = r[15];
    return (
      (s[0] = o * C + a * P + u * F + h * k),
      (s[4] = o * A + a * I + u * X + h * W),
      (s[8] = o * L + a * Q + u * G + h * H),
      (s[12] = o * N + a * ue + u * ne + h * ee),
      (s[1] = p * C + v * P + y * F + S * k),
      (s[5] = p * A + v * I + y * X + S * W),
      (s[9] = p * L + v * Q + y * G + S * H),
      (s[13] = p * N + v * ue + y * ne + S * ee),
      (s[2] = x * C + _ * P + f * F + d * k),
      (s[6] = x * A + _ * I + f * X + d * W),
      (s[10] = x * L + _ * Q + f * G + d * H),
      (s[14] = x * N + _ * ue + f * ne + d * ee),
      (s[3] = m * C + g * P + w * F + T * k),
      (s[7] = m * A + g * I + w * X + T * W),
      (s[11] = m * L + g * Q + w * G + T * H),
      (s[15] = m * N + g * ue + w * ne + T * ee),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      u = e[9],
      h = e[13],
      p = e[2],
      v = e[6],
      y = e[10],
      S = e[14],
      x = e[3],
      _ = e[7],
      f = e[11],
      d = e[15];
    return (
      x *
        (+s * u * v -
          r * h * v -
          s * a * y +
          i * h * y +
          r * a * S -
          i * u * S) +
      _ *
        (+t * u * S -
          t * h * y +
          s * o * y -
          r * o * S +
          r * h * p -
          s * u * p) +
      f *
        (+t * h * v -
          t * a * S -
          s * o * v +
          i * o * S +
          s * a * p -
          i * h * p) +
      d *
        (-r * a * p - t * u * v + t * a * y + r * o * v - i * o * y + i * u * p)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      u = e[6],
      h = e[7],
      p = e[8],
      v = e[9],
      y = e[10],
      S = e[11],
      x = e[12],
      _ = e[13],
      f = e[14],
      d = e[15],
      m = v * f * h - _ * y * h + _ * u * S - a * f * S - v * u * d + a * y * d,
      g = x * y * h - p * f * h - x * u * S + o * f * S + p * u * d - o * y * d,
      w = p * _ * h - x * v * h + x * a * S - o * _ * S - p * a * d + o * v * d,
      T = x * v * u - p * _ * u - x * a * y + o * _ * y + p * a * f - o * v * f,
      C = t * m + i * g + r * w + s * T;
    if (C === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / C;
    return (
      (e[0] = m * A),
      (e[1] =
        (_ * y * s -
          v * f * s -
          _ * r * S +
          i * f * S +
          v * r * d -
          i * y * d) *
        A),
      (e[2] =
        (a * f * s -
          _ * u * s +
          _ * r * h -
          i * f * h -
          a * r * d +
          i * u * d) *
        A),
      (e[3] =
        (v * u * s -
          a * y * s -
          v * r * h +
          i * y * h +
          a * r * S -
          i * u * S) *
        A),
      (e[4] = g * A),
      (e[5] =
        (p * f * s -
          x * y * s +
          x * r * S -
          t * f * S -
          p * r * d +
          t * y * d) *
        A),
      (e[6] =
        (x * u * s -
          o * f * s -
          x * r * h +
          t * f * h +
          o * r * d -
          t * u * d) *
        A),
      (e[7] =
        (o * y * s -
          p * u * s +
          p * r * h -
          t * y * h -
          o * r * S +
          t * u * S) *
        A),
      (e[8] = w * A),
      (e[9] =
        (x * v * s -
          p * _ * s -
          x * i * S +
          t * _ * S +
          p * i * d -
          t * v * d) *
        A),
      (e[10] =
        (o * _ * s -
          x * a * s +
          x * i * h -
          t * _ * h -
          o * i * d +
          t * a * d) *
        A),
      (e[11] =
        (p * a * s -
          o * v * s -
          p * i * h +
          t * v * h +
          o * i * S -
          t * a * S) *
        A),
      (e[12] = T * A),
      (e[13] =
        (p * _ * r -
          x * v * r +
          x * i * y -
          t * _ * y -
          p * i * f +
          t * v * f) *
        A),
      (e[14] =
        (x * a * r -
          o * _ * r -
          x * i * u +
          t * _ * u +
          o * i * f -
          t * a * f) *
        A),
      (e[15] =
        (o * v * r -
          p * a * r +
          p * i * u -
          t * v * u -
          o * i * y +
          t * a * y) *
        A),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      u = e.z,
      h = s * o,
      p = s * a;
    return (
      this.set(
        h * o + i,
        h * a - r * u,
        h * u + r * a,
        0,
        h * a + r * u,
        p * a + i,
        p * u - r * o,
        0,
        h * u - r * a,
        p * u + r * o,
        s * u * u + i,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      u = t._w,
      h = s + s,
      p = o + o,
      v = a + a,
      y = s * h,
      S = s * p,
      x = s * v,
      _ = o * p,
      f = o * v,
      d = a * v,
      m = u * h,
      g = u * p,
      w = u * v,
      T = i.x,
      C = i.y,
      A = i.z;
    return (
      (r[0] = (1 - (_ + d)) * T),
      (r[1] = (S + w) * T),
      (r[2] = (x - g) * T),
      (r[3] = 0),
      (r[4] = (S - w) * C),
      (r[5] = (1 - (y + d)) * C),
      (r[6] = (f + m) * C),
      (r[7] = 0),
      (r[8] = (x + g) * A),
      (r[9] = (f - m) * A),
      (r[10] = (1 - (y + _)) * A),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = _u.set(r[0], r[1], r[2]).length();
    const o = _u.set(r[4], r[5], r[6]).length(),
      a = _u.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Kr.copy(this);
    const h = 1 / s,
      p = 1 / o,
      v = 1 / a;
    return (
      (Kr.elements[0] *= h),
      (Kr.elements[1] *= h),
      (Kr.elements[2] *= h),
      (Kr.elements[4] *= p),
      (Kr.elements[5] *= p),
      (Kr.elements[6] *= p),
      (Kr.elements[8] *= v),
      (Kr.elements[9] *= v),
      (Kr.elements[10] *= v),
      t.setFromRotationMatrix(Kr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = Ps) {
    const u = this.elements,
      h = (2 * s) / (t - e),
      p = (2 * s) / (i - r),
      v = (t + e) / (t - e),
      y = (i + r) / (i - r);
    let S, x;
    if (a === Ps) (S = -(o + s) / (o - s)), (x = (-2 * o * s) / (o - s));
    else if (a === Bh) (S = -o / (o - s)), (x = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a,
      );
    return (
      (u[0] = h),
      (u[4] = 0),
      (u[8] = v),
      (u[12] = 0),
      (u[1] = 0),
      (u[5] = p),
      (u[9] = y),
      (u[13] = 0),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = S),
      (u[14] = x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = -1),
      (u[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = Ps) {
    const u = this.elements,
      h = 1 / (t - e),
      p = 1 / (i - r),
      v = 1 / (o - s),
      y = (t + e) * h,
      S = (i + r) * p;
    let x, _;
    if (a === Ps) (x = (o + s) * v), (_ = -2 * v);
    else if (a === Bh) (x = s * v), (_ = -1 * v);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a,
      );
    return (
      (u[0] = 2 * h),
      (u[4] = 0),
      (u[8] = 0),
      (u[12] = -y),
      (u[1] = 0),
      (u[5] = 2 * p),
      (u[9] = 0),
      (u[13] = -S),
      (u[2] = 0),
      (u[6] = 0),
      (u[10] = _),
      (u[14] = -x),
      (u[3] = 0),
      (u[7] = 0),
      (u[11] = 0),
      (u[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const _u = new B(),
  Kr = new _t(),
  sF = new B(0, 0, 0),
  oF = new B(1, 1, 1),
  zo = new B(),
  jp = new B(),
  or = new B(),
  _T = new _t(),
  xT = new li();
class _f {
  constructor(e = 0, t = 0, i = 0, r = _f.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      u = r[1],
      h = r[5],
      p = r[9],
      v = r[2],
      y = r[6],
      S = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(An(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-p, S)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(y, h)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-An(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(a, S)), (this._z = Math.atan2(u, h)))
            : ((this._y = Math.atan2(-v, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(An(y, -1, 1))),
          Math.abs(y) < 0.9999999
            ? ((this._y = Math.atan2(-v, S)), (this._z = Math.atan2(-o, h)))
            : ((this._y = 0), (this._z = Math.atan2(u, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-An(v, -1, 1))),
          Math.abs(v) < 0.9999999
            ? ((this._x = Math.atan2(y, S)), (this._z = Math.atan2(u, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, h)));
        break;
      case "YZX":
        (this._z = Math.asin(An(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-p, h)), (this._y = Math.atan2(-v, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, S)));
        break;
      case "XZY":
        (this._z = Math.asin(-An(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(y, h)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-p, S)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t,
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      _T.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_T, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return xT.setFromEuler(this), this.setFromQuaternion(xT, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
_f.DEFAULT_ORDER = "XYZ";
class Il {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let aF = 0;
const ST = new B(),
  xu = new li(),
  Ys = new _t(),
  Xp = new B(),
  Td = new B(),
  lF = new B(),
  uF = new li(),
  wT = new B(1, 0, 0),
  MT = new B(0, 1, 0),
  ET = new B(0, 0, 1),
  cF = { type: "added" },
  dF = { type: "removed" };
class Kt extends xo {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: aF++ }),
      (this.uuid = gr()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Kt.DEFAULT_UP.clone());
    const e = new B(),
      t = new _f(),
      i = new li(),
      r = new B(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new _t() },
        normalMatrix: { value: new Nt() },
      }),
      (this.matrix = new _t()),
      (this.matrixWorld = new _t()),
      (this.matrixAutoUpdate = Kt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Kt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Il()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return xu.setFromAxisAngle(e, t), this.quaternion.multiply(xu), this;
  }
  rotateOnWorldAxis(e, t) {
    return xu.setFromAxisAngle(e, t), this.quaternion.premultiply(xu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(wT, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(MT, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ET, e);
  }
  translateOnAxis(e, t) {
    return (
      ST.copy(e).applyQuaternion(this.quaternion),
      this.position.add(ST.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(wT, e);
  }
  translateY(e) {
    return this.translateOnAxis(MT, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ET, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Ys.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? Xp.copy(e) : Xp.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Td.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ys.lookAt(Td, Xp, this.up)
        : Ys.lookAt(Xp, Td, this.up),
      this.quaternion.setFromRotationMatrix(Ys),
      r &&
        (Ys.extractRotation(r.matrixWorld),
        xu.setFromRotationMatrix(Ys),
        this.quaternion.premultiply(xu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(cF))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e,
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(dF)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ys.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Ys.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ys),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Td, e, lF), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Td, uF, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix,
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxGeometryCount = this._maxGeometryCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(a, u) {
      return a[u.uuid] === void 0 && (a[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const u = a.shapes;
        if (Array.isArray(u))
          for (let h = 0, p = u.length; h < p; h++) {
            const v = u[h];
            s(e.shapes, v);
          }
        else s(e.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let u = 0, h = this.material.length; u < h; u++)
          a.push(s(e.materials, this.material[u]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const u = this.animations[a];
        r.animations.push(s(e.animations, u));
      }
    }
    if (t) {
      const a = o(e.geometries),
        u = o(e.materials),
        h = o(e.textures),
        p = o(e.images),
        v = o(e.shapes),
        y = o(e.skeletons),
        S = o(e.animations),
        x = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        u.length > 0 && (i.materials = u),
        h.length > 0 && (i.textures = h),
        p.length > 0 && (i.images = p),
        v.length > 0 && (i.shapes = v),
        y.length > 0 && (i.skeletons = y),
        S.length > 0 && (i.animations = S),
        x.length > 0 && (i.nodes = x);
    }
    return (i.object = r), i;
    function o(a) {
      const u = [];
      for (const h in a) {
        const p = a[h];
        delete p.metadata, u.push(p);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Kt.DEFAULT_UP = new B(0, 1, 0);
Kt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Kt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Qr = new B(),
  Ks = new B(),
  L0 = new B(),
  Qs = new B(),
  Su = new B(),
  wu = new B(),
  TT = new B(),
  I0 = new B(),
  O0 = new B(),
  N0 = new B();
class hr {
  constructor(e = new B(), t = new B(), i = new B()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Qr.subVectors(e, t), r.cross(Qr);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    Qr.subVectors(r, t), Ks.subVectors(i, t), L0.subVectors(e, t);
    const o = Qr.dot(Qr),
      a = Qr.dot(Ks),
      u = Qr.dot(L0),
      h = Ks.dot(Ks),
      p = Ks.dot(L0),
      v = o * h - a * a;
    if (v === 0) return s.set(0, 0, 0), null;
    const y = 1 / v,
      S = (h * u - a * p) * y,
      x = (o * p - a * u) * y;
    return s.set(1 - S - x, x, S);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, Qs) === null
      ? !1
      : Qs.x >= 0 && Qs.y >= 0 && Qs.x + Qs.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, o, a, u) {
    return this.getBarycoord(e, t, i, r, Qs) === null
      ? ((u.x = 0),
        (u.y = 0),
        "z" in u && (u.z = 0),
        "w" in u && (u.w = 0),
        null)
      : (u.setScalar(0),
        u.addScaledVector(s, Qs.x),
        u.addScaledVector(o, Qs.y),
        u.addScaledVector(a, Qs.z),
        u);
  }
  static isFrontFacing(e, t, i, r) {
    return Qr.subVectors(i, t), Ks.subVectors(e, t), Qr.cross(Ks).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Qr.subVectors(this.c, this.b),
      Ks.subVectors(this.a, this.b),
      Qr.cross(Ks).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return hr.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return hr.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return hr.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return hr.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return hr.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Su.subVectors(r, i), wu.subVectors(s, i), I0.subVectors(e, i);
    const u = Su.dot(I0),
      h = wu.dot(I0);
    if (u <= 0 && h <= 0) return t.copy(i);
    O0.subVectors(e, r);
    const p = Su.dot(O0),
      v = wu.dot(O0);
    if (p >= 0 && v <= p) return t.copy(r);
    const y = u * v - p * h;
    if (y <= 0 && u >= 0 && p <= 0)
      return (o = u / (u - p)), t.copy(i).addScaledVector(Su, o);
    N0.subVectors(e, s);
    const S = Su.dot(N0),
      x = wu.dot(N0);
    if (x >= 0 && S <= x) return t.copy(s);
    const _ = S * h - u * x;
    if (_ <= 0 && h >= 0 && x <= 0)
      return (a = h / (h - x)), t.copy(i).addScaledVector(wu, a);
    const f = p * x - S * v;
    if (f <= 0 && v - p >= 0 && S - x >= 0)
      return (
        TT.subVectors(s, r),
        (a = (v - p) / (v - p + (S - x))),
        t.copy(r).addScaledVector(TT, a)
      );
    const d = 1 / (f + _ + y);
    return (
      (o = _ * d),
      (a = y * d),
      t.copy(i).addScaledVector(Su, o).addScaledVector(wu, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const gR = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ho = { h: 0, s: 0, l: 0 },
  qp = { h: 0, s: 0, l: 0 };
function D0(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * 6 * (2 / 3 - t)
          : n
  );
}
class Qe {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
          ? this.setHex(r)
          : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Wn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      nn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = nn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      nn.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = nn.workingColorSpace) {
    if (((e = Ow(e, 1)), (t = An(t, 0, 1)), (i = An(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = D0(o, s, e + 1 / 3)),
        (this.g = D0(o, s, e)),
        (this.b = D0(o, s, e - 1 / 3));
    }
    return nn.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Wn) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored.",
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Wn) {
    const i = gR[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = dc(e.r)), (this.g = dc(e.g)), (this.b = dc(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = M0(e.r)), (this.g = M0(e.g)), (this.b = M0(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Wn) {
    return (
      nn.fromWorkingColorSpace(xi.copy(this), e),
      Math.round(An(xi.r * 255, 0, 255)) * 65536 +
        Math.round(An(xi.g * 255, 0, 255)) * 256 +
        Math.round(An(xi.b * 255, 0, 255))
    );
  }
  getHexString(e = Wn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = nn.workingColorSpace) {
    nn.fromWorkingColorSpace(xi.copy(this), t);
    const i = xi.r,
      r = xi.g,
      s = xi.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let u, h;
    const p = (a + o) / 2;
    if (a === o) (u = 0), (h = 0);
    else {
      const v = o - a;
      switch (((h = p <= 0.5 ? v / (o + a) : v / (2 - o - a)), o)) {
        case i:
          u = (r - s) / v + (r < s ? 6 : 0);
          break;
        case r:
          u = (s - i) / v + 2;
          break;
        case s:
          u = (i - r) / v + 4;
          break;
      }
      u /= 6;
    }
    return (e.h = u), (e.s = h), (e.l = p), e;
  }
  getRGB(e, t = nn.workingColorSpace) {
    return (
      nn.fromWorkingColorSpace(xi.copy(this), t),
      (e.r = xi.r),
      (e.g = xi.g),
      (e.b = xi.b),
      e
    );
  }
  getStyle(e = Wn) {
    nn.fromWorkingColorSpace(xi.copy(this), e);
    const t = xi.r,
      i = xi.g,
      r = xi.b;
    return e !== Wn
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(Ho), this.setHSL(Ho.h + e, Ho.s + t, Ho.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Ho), e.getHSL(qp);
    const i = nh(Ho.h, qp.h, t),
      r = nh(Ho.s, qp.s, t),
      s = nh(Ho.l, qp.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const xi = new Qe();
Qe.NAMES = gR;
let hF = 0;
class ci extends xo {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: hF++ }),
      (this.uuid = gr()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Pl),
      (this.side = go),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Dg),
      (this.blendDst = kg),
      (this.blendEquation = Jo),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Qe(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = bh),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = iS),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ol),
      (this.stencilZFail = ol),
      (this.stencilZPass = ol),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`,
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
            ? r.copy(i)
            : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Pl && (i.blending = this.blending),
      this.side !== go && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== Dg && (i.blendSrc = this.blendSrc),
      this.blendDst !== kg && (i.blendDst = this.blendDst),
      this.blendEquation !== Jo && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== bh && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== iS && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ol && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== ol && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ol && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const u = s[a];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Ia extends ci {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = vf),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const no = fF();
function fF() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const h = u - 127;
    h < -27
      ? ((i[u] = 0), (i[u | 256] = 32768), (r[u] = 24), (r[u | 256] = 24))
      : h < -14
        ? ((i[u] = 1024 >> (-h - 14)),
          (i[u | 256] = (1024 >> (-h - 14)) | 32768),
          (r[u] = -h - 1),
          (r[u | 256] = -h - 1))
        : h <= 15
          ? ((i[u] = (h + 15) << 10),
            (i[u | 256] = ((h + 15) << 10) | 32768),
            (r[u] = 13),
            (r[u | 256] = 13))
          : h < 128
            ? ((i[u] = 31744),
              (i[u | 256] = 64512),
              (r[u] = 24),
              (r[u | 256] = 24))
            : ((i[u] = 31744),
              (i[u | 256] = 64512),
              (r[u] = 13),
              (r[u | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let h = u << 13,
      p = 0;
    for (; !(h & 8388608); ) (h <<= 1), (p -= 8388608);
    (h &= -8388609), (p += 947912704), (s[u] = h | p);
  }
  for (let u = 1024; u < 2048; ++u) s[u] = 939524096 + ((u - 1024) << 13);
  for (let u = 1; u < 31; ++u) o[u] = u << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let u = 33; u < 63; ++u) o[u] = 2147483648 + ((u - 32) << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (a[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function Xi(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = An(n, -65504, 65504)),
    (no.floatView[0] = n);
  const e = no.uint32View[0],
    t = (e >> 23) & 511;
  return no.baseTable[t] + ((e & 8388607) >> no.shiftTable[t]);
}
function Vd(n) {
  const e = n >> 10;
  return (
    (no.uint32View[0] =
      no.mantissaTable[no.offsetTable[e] + (n & 1023)] + no.exponentTable[e]),
    no.floatView[0]
  );
}
const pF = { toHalfFloat: Xi, fromHalfFloat: Vd },
  Un = new B(),
  $p = new Me();
class Jt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = Fh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = Br),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      Ll(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.",
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        $p.fromBufferAttribute(this, t),
          $p.applyMatrix3(e),
          this.setXY(t, $p.x, $p.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Un.fromBufferAttribute(this, t),
          Un.applyMatrix3(e),
          this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Un.fromBufferAttribute(this, t),
        Un.applyMatrix4(e),
        this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Un.fromBufferAttribute(this, t),
        Un.applyNormalMatrix(e),
        this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Un.fromBufferAttribute(this, t),
        Un.transformDirection(e),
        this.setXYZ(t, Un.x, Un.y, Un.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Di(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Pt(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Pt(t, this.array)), (i = Pt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array)),
        (s = Pt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Fh && (e.usage = this.usage),
      e
    );
  }
}
class mF extends Jt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class gF extends Jt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class vF extends Jt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class yF extends Jt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class kw extends Jt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class _F extends Jt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class Uw extends Jt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class xF extends Jt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Vd(this.array[e * this.itemSize]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize] = Xi(t)),
      this
    );
  }
  getY(e) {
    let t = Vd(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 1] = Xi(t)),
      this
    );
  }
  getZ(e) {
    let t = Vd(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 2] = Xi(t)),
      this
    );
  }
  getW(e) {
    let t = Vd(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.array[e * this.itemSize + 3] = Xi(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Pt(t, this.array)), (i = Pt(i, this.array))),
      (this.array[e + 0] = Xi(t)),
      (this.array[e + 1] = Xi(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array))),
      (this.array[e + 0] = Xi(t)),
      (this.array[e + 1] = Xi(i)),
      (this.array[e + 2] = Xi(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array)),
        (s = Pt(s, this.array))),
      (this.array[e + 0] = Xi(t)),
      (this.array[e + 1] = Xi(i)),
      (this.array[e + 2] = Xi(r)),
      (this.array[e + 3] = Xi(s)),
      this
    );
  }
}
class lt extends Jt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class SF extends Jt {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let wF = 0;
const Lr = new _t(),
  k0 = new Kt(),
  Mu = new B(),
  ar = new Fi(),
  Cd = new Fi(),
  Qn = new B();
class Rt extends xo {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: wF++ }),
      (this.uuid = gr()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (fR(e) ? Uw : kw)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Nt().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Lr.makeRotationFromQuaternion(e), this.applyMatrix4(Lr), this;
  }
  rotateX(e) {
    return Lr.makeRotationX(e), this.applyMatrix4(Lr), this;
  }
  rotateY(e) {
    return Lr.makeRotationY(e), this.applyMatrix4(Lr), this;
  }
  rotateZ(e) {
    return Lr.makeRotationZ(e), this.applyMatrix4(Lr), this;
  }
  translate(e, t, i) {
    return Lr.makeTranslation(e, t, i), this.applyMatrix4(Lr), this;
  }
  scale(e, t, i) {
    return Lr.makeScale(e, t, i), this.applyMatrix4(Lr), this;
  }
  lookAt(e) {
    return k0.lookAt(e), k0.updateMatrix(), this.applyMatrix4(k0.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Mu).negate(),
      this.translate(Mu.x, Mu.y, Mu.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new lt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Fi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this,
      ),
        this.boundingBox.set(
          new B(-1 / 0, -1 / 0, -1 / 0),
          new B(1 / 0, 1 / 0, 1 / 0),
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          ar.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Qn.addVectors(this.boundingBox.min, ar.min),
                this.boundingBox.expandByPoint(Qn),
                Qn.addVectors(this.boundingBox.max, ar.max),
                this.boundingBox.expandByPoint(Qn))
              : (this.boundingBox.expandByPoint(ar.min),
                this.boundingBox.expandByPoint(ar.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ei());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this,
      ),
        this.boundingSphere.set(new B(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((ar.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Cd.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Qn.addVectors(ar.min, Cd.min),
                ar.expandByPoint(Qn),
                Qn.addVectors(ar.max, Cd.max),
                ar.expandByPoint(Qn))
              : (ar.expandByPoint(Cd.min), ar.expandByPoint(Cd.max));
        }
      ar.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Qn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Qn)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            u = this.morphTargetsRelative;
          for (let h = 0, p = a.count; h < p; h++)
            Qn.fromBufferAttribute(a, h),
              u && (Mu.fromBufferAttribute(e, h), Qn.add(Mu)),
              (r = Math.max(r, i.distanceToSquared(Qn)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Jt(new Float32Array(4 * a), 4));
    const u = this.getAttribute("tangent").array,
      h = [],
      p = [];
    for (let P = 0; P < a; P++) (h[P] = new B()), (p[P] = new B());
    const v = new B(),
      y = new B(),
      S = new B(),
      x = new Me(),
      _ = new Me(),
      f = new Me(),
      d = new B(),
      m = new B();
    function g(P, I, Q) {
      v.fromArray(r, P * 3),
        y.fromArray(r, I * 3),
        S.fromArray(r, Q * 3),
        x.fromArray(o, P * 2),
        _.fromArray(o, I * 2),
        f.fromArray(o, Q * 2),
        y.sub(v),
        S.sub(v),
        _.sub(x),
        f.sub(x);
      const ue = 1 / (_.x * f.y - f.x * _.y);
      isFinite(ue) &&
        (d
          .copy(y)
          .multiplyScalar(f.y)
          .addScaledVector(S, -_.y)
          .multiplyScalar(ue),
        m
          .copy(S)
          .multiplyScalar(_.x)
          .addScaledVector(y, -f.x)
          .multiplyScalar(ue),
        h[P].add(d),
        h[I].add(d),
        h[Q].add(d),
        p[P].add(m),
        p[I].add(m),
        p[Q].add(m));
    }
    let w = this.groups;
    w.length === 0 && (w = [{ start: 0, count: i.length }]);
    for (let P = 0, I = w.length; P < I; ++P) {
      const Q = w[P],
        ue = Q.start,
        F = Q.count;
      for (let X = ue, G = ue + F; X < G; X += 3)
        g(i[X + 0], i[X + 1], i[X + 2]);
    }
    const T = new B(),
      C = new B(),
      A = new B(),
      L = new B();
    function N(P) {
      A.fromArray(s, P * 3), L.copy(A);
      const I = h[P];
      T.copy(I),
        T.sub(A.multiplyScalar(A.dot(I))).normalize(),
        C.crossVectors(L, I);
      const ue = C.dot(p[P]) < 0 ? -1 : 1;
      (u[P * 4] = T.x),
        (u[P * 4 + 1] = T.y),
        (u[P * 4 + 2] = T.z),
        (u[P * 4 + 3] = ue);
    }
    for (let P = 0, I = w.length; P < I; ++P) {
      const Q = w[P],
        ue = Q.start,
        F = Q.count;
      for (let X = ue, G = ue + F; X < G; X += 3)
        N(i[X + 0]), N(i[X + 1]), N(i[X + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Jt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let y = 0, S = i.count; y < S; y++) i.setXYZ(y, 0, 0, 0);
      const r = new B(),
        s = new B(),
        o = new B(),
        a = new B(),
        u = new B(),
        h = new B(),
        p = new B(),
        v = new B();
      if (e)
        for (let y = 0, S = e.count; y < S; y += 3) {
          const x = e.getX(y + 0),
            _ = e.getX(y + 1),
            f = e.getX(y + 2);
          r.fromBufferAttribute(t, x),
            s.fromBufferAttribute(t, _),
            o.fromBufferAttribute(t, f),
            p.subVectors(o, s),
            v.subVectors(r, s),
            p.cross(v),
            a.fromBufferAttribute(i, x),
            u.fromBufferAttribute(i, _),
            h.fromBufferAttribute(i, f),
            a.add(p),
            u.add(p),
            h.add(p),
            i.setXYZ(x, a.x, a.y, a.z),
            i.setXYZ(_, u.x, u.y, u.z),
            i.setXYZ(f, h.x, h.y, h.z);
        }
      else
        for (let y = 0, S = t.count; y < S; y += 3)
          r.fromBufferAttribute(t, y + 0),
            s.fromBufferAttribute(t, y + 1),
            o.fromBufferAttribute(t, y + 2),
            p.subVectors(o, s),
            v.subVectors(r, s),
            p.cross(v),
            i.setXYZ(y + 0, p.x, p.y, p.z),
            i.setXYZ(y + 1, p.x, p.y, p.z),
            i.setXYZ(y + 2, p.x, p.y, p.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Qn.fromBufferAttribute(e, t),
        Qn.normalize(),
        e.setXYZ(t, Qn.x, Qn.y, Qn.z);
  }
  toNonIndexed() {
    function e(a, u) {
      const h = a.array,
        p = a.itemSize,
        v = a.normalized,
        y = new h.constructor(u.length * p);
      let S = 0,
        x = 0;
      for (let _ = 0, f = u.length; _ < f; _++) {
        a.isInterleavedBufferAttribute
          ? (S = u[_] * a.data.stride + a.offset)
          : (S = u[_] * p);
        for (let d = 0; d < p; d++) y[x++] = h[S++];
      }
      return new Jt(y, p, v);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
        this
      );
    const t = new Rt(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const u = r[a],
        h = e(u, i);
      t.setAttribute(a, h);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const u = [],
        h = s[a];
      for (let p = 0, v = h.length; p < v; p++) {
        const y = h[p],
          S = e(y, i);
        u.push(S);
      }
      t.morphAttributes[a] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, u = o.length; a < u; a++) {
      const h = o[a];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const h in u) u[h] !== void 0 && (e[h] = u[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const u in i) {
      const h = i[u];
      e.data.attributes[u] = h.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const u in this.morphAttributes) {
      const h = this.morphAttributes[u],
        p = [];
      for (let v = 0, y = h.length; v < y; v++) {
        const S = h[v];
        p.push(S.toJSON(e.data));
      }
      p.length > 0 && ((r[u] = p), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const h in r) {
      const p = r[h];
      this.setAttribute(h, p.clone(t));
    }
    const s = e.morphAttributes;
    for (const h in s) {
      const p = [],
        v = s[h];
      for (let y = 0, S = v.length; y < S; y++) p.push(v[y].clone(t));
      this.morphAttributes[h] = p;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let h = 0, p = o.length; h < p; h++) {
      const v = o[h];
      this.addGroup(v.start, v.count, v.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const u = e.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const CT = new _t(),
  Ka = new Xc(),
  Yp = new Ei(),
  bT = new B(),
  Eu = new B(),
  Tu = new B(),
  Cu = new B(),
  U0 = new B(),
  Kp = new B(),
  Qp = new Me(),
  Zp = new Me(),
  Jp = new Me(),
  AT = new B(),
  PT = new B(),
  RT = new B(),
  em = new B(),
  tm = new B();
class Bn extends Kt {
  constructor(e = new Rt(), t = new Ia()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Kp.set(0, 0, 0);
      for (let u = 0, h = s.length; u < h; u++) {
        const p = a[u],
          v = s[u];
        p !== 0 &&
          (U0.fromBufferAttribute(v, e),
          o ? Kp.addScaledVector(U0, p) : Kp.addScaledVector(U0.sub(t), p));
      }
      t.add(Kp);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Yp.copy(i.boundingSphere),
      Yp.applyMatrix4(s),
      Ka.copy(e.ray).recast(e.near),
      !(
        Yp.containsPoint(Ka.origin) === !1 &&
        (Ka.intersectSphere(Yp, bT) === null ||
          Ka.origin.distanceToSquared(bT) > (e.far - e.near) ** 2)
      ) &&
        (CT.copy(s).invert(),
        Ka.copy(e.ray).applyMatrix4(CT),
        !(i.boundingBox !== null && Ka.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, Ka)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      u = s.attributes.position,
      h = s.attributes.uv,
      p = s.attributes.uv1,
      v = s.attributes.normal,
      y = s.groups,
      S = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let x = 0, _ = y.length; x < _; x++) {
          const f = y[x],
            d = o[f.materialIndex],
            m = Math.max(f.start, S.start),
            g = Math.min(
              a.count,
              Math.min(f.start + f.count, S.start + S.count),
            );
          for (let w = m, T = g; w < T; w += 3) {
            const C = a.getX(w),
              A = a.getX(w + 1),
              L = a.getX(w + 2);
            (r = nm(this, d, e, i, h, p, v, C, A, L)),
              r &&
                ((r.faceIndex = Math.floor(w / 3)),
                (r.face.materialIndex = f.materialIndex),
                t.push(r));
          }
        }
      else {
        const x = Math.max(0, S.start),
          _ = Math.min(a.count, S.start + S.count);
        for (let f = x, d = _; f < d; f += 3) {
          const m = a.getX(f),
            g = a.getX(f + 1),
            w = a.getX(f + 2);
          (r = nm(this, o, e, i, h, p, v, m, g, w)),
            r && ((r.faceIndex = Math.floor(f / 3)), t.push(r));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let x = 0, _ = y.length; x < _; x++) {
          const f = y[x],
            d = o[f.materialIndex],
            m = Math.max(f.start, S.start),
            g = Math.min(
              u.count,
              Math.min(f.start + f.count, S.start + S.count),
            );
          for (let w = m, T = g; w < T; w += 3) {
            const C = w,
              A = w + 1,
              L = w + 2;
            (r = nm(this, d, e, i, h, p, v, C, A, L)),
              r &&
                ((r.faceIndex = Math.floor(w / 3)),
                (r.face.materialIndex = f.materialIndex),
                t.push(r));
          }
        }
      else {
        const x = Math.max(0, S.start),
          _ = Math.min(u.count, S.start + S.count);
        for (let f = x, d = _; f < d; f += 3) {
          const m = f,
            g = f + 1,
            w = f + 2;
          (r = nm(this, o, e, i, h, p, v, m, g, w)),
            r && ((r.faceIndex = Math.floor(f / 3)), t.push(r));
        }
      }
  }
}
function MF(n, e, t, i, r, s, o, a) {
  let u;
  if (
    (e.side === Ui
      ? (u = i.intersectTriangle(o, s, r, !0, a))
      : (u = i.intersectTriangle(r, s, o, e.side === go, a)),
    u === null)
  )
    return null;
  tm.copy(a), tm.applyMatrix4(n.matrixWorld);
  const h = t.ray.origin.distanceTo(tm);
  return h < t.near || h > t.far
    ? null
    : { distance: h, point: tm.clone(), object: n };
}
function nm(n, e, t, i, r, s, o, a, u, h) {
  n.getVertexPosition(a, Eu),
    n.getVertexPosition(u, Tu),
    n.getVertexPosition(h, Cu);
  const p = MF(n, e, t, i, Eu, Tu, Cu, em);
  if (p) {
    r &&
      (Qp.fromBufferAttribute(r, a),
      Zp.fromBufferAttribute(r, u),
      Jp.fromBufferAttribute(r, h),
      (p.uv = hr.getInterpolation(em, Eu, Tu, Cu, Qp, Zp, Jp, new Me()))),
      s &&
        (Qp.fromBufferAttribute(s, a),
        Zp.fromBufferAttribute(s, u),
        Jp.fromBufferAttribute(s, h),
        (p.uv1 = hr.getInterpolation(em, Eu, Tu, Cu, Qp, Zp, Jp, new Me())),
        (p.uv2 = p.uv1)),
      o &&
        (AT.fromBufferAttribute(o, a),
        PT.fromBufferAttribute(o, u),
        RT.fromBufferAttribute(o, h),
        (p.normal = hr.getInterpolation(em, Eu, Tu, Cu, AT, PT, RT, new B())),
        p.normal.dot(i.direction) > 0 && p.normal.multiplyScalar(-1));
    const v = { a, b: u, c: h, normal: new B(), materialIndex: 0 };
    hr.getNormal(Eu, Tu, Cu, v.normal), (p.face = v);
  }
  return p;
}
class ql extends Rt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const u = [],
      h = [],
      p = [],
      v = [];
    let y = 0,
      S = 0;
    x("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      x("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      x("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      x("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      x("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      x("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(u),
      this.setAttribute("position", new lt(h, 3)),
      this.setAttribute("normal", new lt(p, 3)),
      this.setAttribute("uv", new lt(v, 2));
    function x(_, f, d, m, g, w, T, C, A, L, N) {
      const P = w / A,
        I = T / L,
        Q = w / 2,
        ue = T / 2,
        F = C / 2,
        X = A + 1,
        G = L + 1;
      let ne = 0,
        k = 0;
      const W = new B();
      for (let H = 0; H < G; H++) {
        const ee = H * I - ue;
        for (let ae = 0; ae < X; ae++) {
          const xe = ae * P - Q;
          (W[_] = xe * m),
            (W[f] = ee * g),
            (W[d] = F),
            h.push(W.x, W.y, W.z),
            (W[_] = 0),
            (W[f] = 0),
            (W[d] = C > 0 ? 1 : -1),
            p.push(W.x, W.y, W.z),
            v.push(ae / A),
            v.push(1 - H / L),
            (ne += 1);
        }
      }
      for (let H = 0; H < L; H++)
        for (let ee = 0; ee < A; ee++) {
          const ae = y + ee + X * H,
            xe = y + ee + X * (H + 1),
            te = y + (ee + 1) + X * (H + 1),
            de = y + (ee + 1) + X * H;
          u.push(ae, xe, de), u.push(xe, te, de), (k += 6);
        }
      a.addGroup(S, k, N), (S += k), (y += ne);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ql(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
}
function Bc(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r);
    }
  }
  return e;
}
function Li(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Bc(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function EF(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function vR(n) {
  return n.getRenderTarget() === null
    ? n.outputColorSpace
    : nn.workingColorSpace;
}
const yR = { clone: Bc, merge: Li };
var TF = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  CF = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ls extends ci {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = TF),
      (this.fragmentShader = CF),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
        clipCullDistance: !1,
        multiDraw: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Bc(e.uniforms)),
      (this.uniformsGroups = EF(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
          ? (t.uniforms[r] = { type: "c", value: o.getHex() })
          : o && o.isVector2
            ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
            : o && o.isVector3
              ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
                ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
                : o && o.isMatrix3
                  ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
                  : o && o.isMatrix4
                    ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
                    : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class xf extends Kt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new _t()),
      (this.projectionMatrix = new _t()),
      (this.projectionMatrixInverse = new _t()),
      (this.coordinateSystem = Ps);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vo = new B(),
  LT = new Me(),
  IT = new Me();
class ei extends xf {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Fc * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Rl * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Fc * 2 * Math.atan(Math.tan(Rl * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    Vo.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Vo.x, Vo.y).multiplyScalar(-e / Vo.z),
      Vo.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(Vo.x, Vo.y).multiplyScalar(-e / Vo.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, LT, IT), t.subVectors(IT, LT);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Rl * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth,
        h = o.fullHeight;
      (s += (o.offsetX * r) / u),
        (t -= (o.offsetY * i) / h),
        (r *= o.width / u),
        (i *= o.height / h);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const bu = -90,
  Au = 1;
class _R extends Kt {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new ei(bu, Au, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new ei(bu, Au, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new ei(bu, Au, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new ei(bu, Au, e, t);
    (a.layers = this.layers), this.add(a);
    const u = new ei(bu, Au, e, t);
    (u.layers = this.layers), this.add(u);
    const h = new ei(bu, Au, e, t);
    (h.layers = this.layers), this.add(h);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, u] = t;
    for (const h of t) this.remove(h);
    if (e === Ps)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, -1);
    else if (e === Bh)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e,
      );
    for (const h of t) this.add(h), h.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, u, h, p] = this.children,
      v = e.getRenderTarget(),
      y = e.getActiveCubeFace(),
      S = e.getActiveMipmapLevel(),
      x = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, u),
      e.setRenderTarget(i, 4, r),
      e.render(t, h),
      (i.texture.generateMipmaps = _),
      e.setRenderTarget(i, 5, r),
      e.render(t, p),
      e.setRenderTarget(v, y, S),
      (e.xr.enabled = x),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Sf extends Mn {
  constructor(e, t, i, r, s, o, a, u, h, p) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : vo),
      super(e, t, i, r, s, o, a, u, h, p),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class xR extends as {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    t.encoding !== void 0 &&
      (Ll(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.",
      ),
      (t.colorSpace = t.encoding === xa ? Wn : dr)),
      (this.texture = new Sf(
        r,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace,
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : xn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new ql(5, 5, 5),
      s = new ls({
        name: "CubemapFromEquirect",
        uniforms: Bc(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Ui,
        blending: uo,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Bn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === As && (t.minFilter = xn),
      new _R(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const F0 = new B(),
  bF = new B(),
  AF = new Nt();
class Yo {
  constructor(e = new B(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = F0.subVectors(i, t).cross(bF.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(F0),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || AF.getNormalMatrix(e),
      r = this.coplanarPoint(F0).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Qa = new Ei(),
  im = new B();
class wf {
  constructor(
    e = new Yo(),
    t = new Yo(),
    i = new Yo(),
    r = new Yo(),
    s = new Yo(),
    o = new Yo(),
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ps) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      u = r[3],
      h = r[4],
      p = r[5],
      v = r[6],
      y = r[7],
      S = r[8],
      x = r[9],
      _ = r[10],
      f = r[11],
      d = r[12],
      m = r[13],
      g = r[14],
      w = r[15];
    if (
      (i[0].setComponents(u - s, y - h, f - S, w - d).normalize(),
      i[1].setComponents(u + s, y + h, f + S, w + d).normalize(),
      i[2].setComponents(u + o, y + p, f + x, w + m).normalize(),
      i[3].setComponents(u - o, y - p, f - x, w - m).normalize(),
      i[4].setComponents(u - a, y - v, f - _, w - g).normalize(),
      t === Ps)
    )
      i[5].setComponents(u + a, y + v, f + _, w + g).normalize();
    else if (t === Bh) i[5].setComponents(a, v, _, g).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t,
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Qa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Qa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Qa);
  }
  intersectsSprite(e) {
    return (
      Qa.center.set(0, 0, 0),
      (Qa.radius = 0.7071067811865476),
      Qa.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Qa)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((im.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (im.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (im.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(im) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function SR() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function PF(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(h, p) {
    const v = h.array,
      y = h.usage,
      S = v.byteLength,
      x = n.createBuffer();
    n.bindBuffer(p, x), n.bufferData(p, v, y), h.onUploadCallback();
    let _;
    if (v instanceof Float32Array) _ = n.FLOAT;
    else if (v instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (t) _ = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
          );
      else _ = n.UNSIGNED_SHORT;
    else if (v instanceof Int16Array) _ = n.SHORT;
    else if (v instanceof Uint32Array) _ = n.UNSIGNED_INT;
    else if (v instanceof Int32Array) _ = n.INT;
    else if (v instanceof Int8Array) _ = n.BYTE;
    else if (v instanceof Uint8Array) _ = n.UNSIGNED_BYTE;
    else if (v instanceof Uint8ClampedArray) _ = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + v,
      );
    return {
      buffer: x,
      type: _,
      bytesPerElement: v.BYTES_PER_ELEMENT,
      version: h.version,
      size: S,
    };
  }
  function s(h, p, v) {
    const y = p.array,
      S = p._updateRange,
      x = p.updateRanges;
    if (
      (n.bindBuffer(v, h),
      S.count === -1 && x.length === 0 && n.bufferSubData(v, 0, y),
      x.length !== 0)
    ) {
      for (let _ = 0, f = x.length; _ < f; _++) {
        const d = x[_];
        t
          ? n.bufferSubData(
              v,
              d.start * y.BYTES_PER_ELEMENT,
              y,
              d.start,
              d.count,
            )
          : n.bufferSubData(
              v,
              d.start * y.BYTES_PER_ELEMENT,
              y.subarray(d.start, d.start + d.count),
            );
      }
      p.clearUpdateRanges();
    }
    S.count !== -1 &&
      (t
        ? n.bufferSubData(
            v,
            S.offset * y.BYTES_PER_ELEMENT,
            y,
            S.offset,
            S.count,
          )
        : n.bufferSubData(
            v,
            S.offset * y.BYTES_PER_ELEMENT,
            y.subarray(S.offset, S.offset + S.count),
          ),
      (S.count = -1)),
      p.onUploadCallback();
  }
  function o(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), i.get(h);
  }
  function a(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const p = i.get(h);
    p && (n.deleteBuffer(p.buffer), i.delete(h));
  }
  function u(h, p) {
    if (h.isGLBufferAttribute) {
      const y = i.get(h);
      (!y || y.version < h.version) &&
        i.set(h, {
          buffer: h.buffer,
          type: h.type,
          bytesPerElement: h.elementSize,
          version: h.version,
        });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const v = i.get(h);
    if (v === void 0) i.set(h, r(h, p));
    else if (v.version < h.version) {
      if (v.size !== h.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      s(v.buffer, h, p), (v.version = h.version);
    }
  }
  return { get: o, remove: a, update: u };
}
class qc extends Rt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      u = Math.floor(r),
      h = a + 1,
      p = u + 1,
      v = e / a,
      y = t / u,
      S = [],
      x = [],
      _ = [],
      f = [];
    for (let d = 0; d < p; d++) {
      const m = d * y - o;
      for (let g = 0; g < h; g++) {
        const w = g * v - s;
        x.push(w, -m, 0), _.push(0, 0, 1), f.push(g / a), f.push(1 - d / u);
      }
    }
    for (let d = 0; d < u; d++)
      for (let m = 0; m < a; m++) {
        const g = m + h * d,
          w = m + h * (d + 1),
          T = m + 1 + h * (d + 1),
          C = m + 1 + h * d;
        S.push(g, w, C), S.push(w, T, C);
      }
    this.setIndex(S),
      this.setAttribute("position", new lt(x, 3)),
      this.setAttribute("normal", new lt(_, 3)),
      this.setAttribute("uv", new lt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new qc(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var RF = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  LF = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  IF = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  OF = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  NF = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  DF = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  kF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  UF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  FF = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  BF = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  zF = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  HF = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  VF = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  GF = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  WF = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  jF = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  XF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  qF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  $F = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  YF = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  KF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  QF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  ZF = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  JF = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  eB = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  tB = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  nB = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  iB = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  rB = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  sB = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  oB = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  aB = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  lB = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  uB = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  cB = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  dB = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  hB = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fB = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  pB = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  mB = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  gB = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  vB = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  yB = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  _B = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  xB = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  SB = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  wB = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  MB = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  EB = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  TB = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  CB = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  bB = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  AB = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  PB = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  RB = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  LB = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  IB = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  OB = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  NB = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  DB = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  kB = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  UB = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  FB = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  BB = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  zB = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  HB = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  VB = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  GB = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  WB = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  jB = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  XB = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  qB = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  $B = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  YB = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  KB = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  QB = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  ZB = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  JB = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  ez = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  tz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  nz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  iz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  rz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  sz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  oz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  az = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  lz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  uz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  cz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  dz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  hz = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  fz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  pz = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  mz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  gz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  vz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  yz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  _z = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  xz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  Sz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  wz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  Mz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  Ez = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  Tz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Cz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  bz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Az = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Pz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Rz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Lz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Iz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Oz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Nz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Dz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  kz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  Uz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Fz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Bz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  zz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Hz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Vz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Gz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Wz = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  jz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Xz = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  qz = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  $z = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Yz = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Kz = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  Qz = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Zz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Jz = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  e4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  t4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  n4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  i4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  r4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  s4 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  o4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  a4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  l4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  It = {
    alphahash_fragment: RF,
    alphahash_pars_fragment: LF,
    alphamap_fragment: IF,
    alphamap_pars_fragment: OF,
    alphatest_fragment: NF,
    alphatest_pars_fragment: DF,
    aomap_fragment: kF,
    aomap_pars_fragment: UF,
    batching_pars_vertex: FF,
    batching_vertex: BF,
    begin_vertex: zF,
    beginnormal_vertex: HF,
    bsdfs: VF,
    iridescence_fragment: GF,
    bumpmap_pars_fragment: WF,
    clipping_planes_fragment: jF,
    clipping_planes_pars_fragment: XF,
    clipping_planes_pars_vertex: qF,
    clipping_planes_vertex: $F,
    color_fragment: YF,
    color_pars_fragment: KF,
    color_pars_vertex: QF,
    color_vertex: ZF,
    common: JF,
    cube_uv_reflection_fragment: eB,
    defaultnormal_vertex: tB,
    displacementmap_pars_vertex: nB,
    displacementmap_vertex: iB,
    emissivemap_fragment: rB,
    emissivemap_pars_fragment: sB,
    colorspace_fragment: oB,
    colorspace_pars_fragment: aB,
    envmap_fragment: lB,
    envmap_common_pars_fragment: uB,
    envmap_pars_fragment: cB,
    envmap_pars_vertex: dB,
    envmap_physical_pars_fragment: MB,
    envmap_vertex: hB,
    fog_vertex: fB,
    fog_pars_vertex: pB,
    fog_fragment: mB,
    fog_pars_fragment: gB,
    gradientmap_pars_fragment: vB,
    lightmap_fragment: yB,
    lightmap_pars_fragment: _B,
    lights_lambert_fragment: xB,
    lights_lambert_pars_fragment: SB,
    lights_pars_begin: wB,
    lights_toon_fragment: EB,
    lights_toon_pars_fragment: TB,
    lights_phong_fragment: CB,
    lights_phong_pars_fragment: bB,
    lights_physical_fragment: AB,
    lights_physical_pars_fragment: PB,
    lights_fragment_begin: RB,
    lights_fragment_maps: LB,
    lights_fragment_end: IB,
    logdepthbuf_fragment: OB,
    logdepthbuf_pars_fragment: NB,
    logdepthbuf_pars_vertex: DB,
    logdepthbuf_vertex: kB,
    map_fragment: UB,
    map_pars_fragment: FB,
    map_particle_fragment: BB,
    map_particle_pars_fragment: zB,
    metalnessmap_fragment: HB,
    metalnessmap_pars_fragment: VB,
    morphcolor_vertex: GB,
    morphnormal_vertex: WB,
    morphtarget_pars_vertex: jB,
    morphtarget_vertex: XB,
    normal_fragment_begin: qB,
    normal_fragment_maps: $B,
    normal_pars_fragment: YB,
    normal_pars_vertex: KB,
    normal_vertex: QB,
    normalmap_pars_fragment: ZB,
    clearcoat_normal_fragment_begin: JB,
    clearcoat_normal_fragment_maps: ez,
    clearcoat_pars_fragment: tz,
    iridescence_pars_fragment: nz,
    opaque_fragment: iz,
    packing: rz,
    premultiplied_alpha_fragment: sz,
    project_vertex: oz,
    dithering_fragment: az,
    dithering_pars_fragment: lz,
    roughnessmap_fragment: uz,
    roughnessmap_pars_fragment: cz,
    shadowmap_pars_fragment: dz,
    shadowmap_pars_vertex: hz,
    shadowmap_vertex: fz,
    shadowmask_pars_fragment: pz,
    skinbase_vertex: mz,
    skinning_pars_vertex: gz,
    skinning_vertex: vz,
    skinnormal_vertex: yz,
    specularmap_fragment: _z,
    specularmap_pars_fragment: xz,
    tonemapping_fragment: Sz,
    tonemapping_pars_fragment: wz,
    transmission_fragment: Mz,
    transmission_pars_fragment: Ez,
    uv_pars_fragment: Tz,
    uv_pars_vertex: Cz,
    uv_vertex: bz,
    worldpos_vertex: Az,
    background_vert: Pz,
    background_frag: Rz,
    backgroundCube_vert: Lz,
    backgroundCube_frag: Iz,
    cube_vert: Oz,
    cube_frag: Nz,
    depth_vert: Dz,
    depth_frag: kz,
    distanceRGBA_vert: Uz,
    distanceRGBA_frag: Fz,
    equirect_vert: Bz,
    equirect_frag: zz,
    linedashed_vert: Hz,
    linedashed_frag: Vz,
    meshbasic_vert: Gz,
    meshbasic_frag: Wz,
    meshlambert_vert: jz,
    meshlambert_frag: Xz,
    meshmatcap_vert: qz,
    meshmatcap_frag: $z,
    meshnormal_vert: Yz,
    meshnormal_frag: Kz,
    meshphong_vert: Qz,
    meshphong_frag: Zz,
    meshphysical_vert: Jz,
    meshphysical_frag: e4,
    meshtoon_vert: t4,
    meshtoon_frag: n4,
    points_vert: i4,
    points_frag: r4,
    shadow_vert: s4,
    shadow_frag: o4,
    sprite_vert: a4,
    sprite_frag: l4,
  },
  He = {
    common: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Nt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Nt() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Nt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Nt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Nt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Nt() },
      normalScale: { value: new Me(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Nt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Nt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Nt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Nt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Qe(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Nt() },
    },
    sprite: {
      diffuse: { value: new Qe(16777215) },
      opacity: { value: 1 },
      center: { value: new Me(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Nt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
    },
  },
  is = {
    basic: {
      uniforms: Li([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.fog,
      ]),
      vertexShader: It.meshbasic_vert,
      fragmentShader: It.meshbasic_frag,
    },
    lambert: {
      uniforms: Li([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        He.lights,
        { emissive: { value: new Qe(0) } },
      ]),
      vertexShader: It.meshlambert_vert,
      fragmentShader: It.meshlambert_frag,
    },
    phong: {
      uniforms: Li([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        He.lights,
        {
          emissive: { value: new Qe(0) },
          specular: { value: new Qe(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: It.meshphong_vert,
      fragmentShader: It.meshphong_frag,
    },
    standard: {
      uniforms: Li([
        He.common,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.roughnessmap,
        He.metalnessmap,
        He.fog,
        He.lights,
        {
          emissive: { value: new Qe(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: It.meshphysical_vert,
      fragmentShader: It.meshphysical_frag,
    },
    toon: {
      uniforms: Li([
        He.common,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.gradientmap,
        He.fog,
        He.lights,
        { emissive: { value: new Qe(0) } },
      ]),
      vertexShader: It.meshtoon_vert,
      fragmentShader: It.meshtoon_frag,
    },
    matcap: {
      uniforms: Li([
        He.common,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: It.meshmatcap_vert,
      fragmentShader: It.meshmatcap_frag,
    },
    points: {
      uniforms: Li([He.points, He.fog]),
      vertexShader: It.points_vert,
      fragmentShader: It.points_frag,
    },
    dashed: {
      uniforms: Li([
        He.common,
        He.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: It.linedashed_vert,
      fragmentShader: It.linedashed_frag,
    },
    depth: {
      uniforms: Li([He.common, He.displacementmap]),
      vertexShader: It.depth_vert,
      fragmentShader: It.depth_frag,
    },
    normal: {
      uniforms: Li([
        He.common,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: It.meshnormal_vert,
      fragmentShader: It.meshnormal_frag,
    },
    sprite: {
      uniforms: Li([He.sprite, He.fog]),
      vertexShader: It.sprite_vert,
      fragmentShader: It.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Nt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: It.background_vert,
      fragmentShader: It.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: It.backgroundCube_vert,
      fragmentShader: It.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: It.cube_vert,
      fragmentShader: It.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: It.equirect_vert,
      fragmentShader: It.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Li([
        He.common,
        He.displacementmap,
        {
          referencePosition: { value: new B() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: It.distanceRGBA_vert,
      fragmentShader: It.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Li([
        He.lights,
        He.fog,
        { color: { value: new Qe(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: It.shadow_vert,
      fragmentShader: It.shadow_frag,
    },
  };
is.physical = {
  uniforms: Li([
    is.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Nt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Nt() },
      clearcoatNormalScale: { value: new Me(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Nt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Nt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Nt() },
      sheen: { value: 0 },
      sheenColor: { value: new Qe(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Nt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Nt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Nt() },
      transmissionSamplerSize: { value: new Me() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Nt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Qe(0) },
      specularColor: { value: new Qe(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Nt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Nt() },
      anisotropyVector: { value: new Me() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Nt() },
    },
  ]),
  vertexShader: It.meshphysical_vert,
  fragmentShader: It.meshphysical_frag,
};
const rm = { r: 0, b: 0, g: 0 };
function u4(n, e, t, i, r, s, o) {
  const a = new Qe(0);
  let u = s === !0 ? 0 : 1,
    h,
    p,
    v = null,
    y = 0,
    S = null;
  function x(f, d) {
    let m = !1,
      g = d.isScene === !0 ? d.background : null;
    g && g.isTexture && (g = (d.backgroundBlurriness > 0 ? t : e).get(g)),
      g === null ? _(a, u) : g && g.isColor && (_(g, 1), (m = !0));
    const w = n.xr.getEnvironmentBlendMode();
    w === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : w === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || m) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      g && (g.isCubeTexture || g.mapping === jc)
        ? (p === void 0 &&
            ((p = new Bn(
              new ql(1, 1, 1),
              new ls({
                name: "BackgroundCubeMaterial",
                uniforms: Bc(is.backgroundCube.uniforms),
                vertexShader: is.backgroundCube.vertexShader,
                fragmentShader: is.backgroundCube.fragmentShader,
                side: Ui,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              }),
            )),
            p.geometry.deleteAttribute("normal"),
            p.geometry.deleteAttribute("uv"),
            (p.onBeforeRender = function (T, C, A) {
              this.matrixWorld.copyPosition(A.matrixWorld);
            }),
            Object.defineProperty(p.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(p)),
          (p.material.uniforms.envMap.value = g),
          (p.material.uniforms.flipEnvMap.value =
            g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1),
          (p.material.uniforms.backgroundBlurriness.value =
            d.backgroundBlurriness),
          (p.material.uniforms.backgroundIntensity.value =
            d.backgroundIntensity),
          (p.material.toneMapped = nn.getTransfer(g.colorSpace) !== un),
          (v !== g || y !== g.version || S !== n.toneMapping) &&
            ((p.material.needsUpdate = !0),
            (v = g),
            (y = g.version),
            (S = n.toneMapping)),
          p.layers.enableAll(),
          f.unshift(p, p.geometry, p.material, 0, 0, null))
        : g &&
          g.isTexture &&
          (h === void 0 &&
            ((h = new Bn(
              new qc(2, 2),
              new ls({
                name: "BackgroundMaterial",
                uniforms: Bc(is.background.uniforms),
                vertexShader: is.background.vertexShader,
                fragmentShader: is.background.fragmentShader,
                side: go,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              }),
            )),
            h.geometry.deleteAttribute("normal"),
            Object.defineProperty(h.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(h)),
          (h.material.uniforms.t2D.value = g),
          (h.material.uniforms.backgroundIntensity.value =
            d.backgroundIntensity),
          (h.material.toneMapped = nn.getTransfer(g.colorSpace) !== un),
          g.matrixAutoUpdate === !0 && g.updateMatrix(),
          h.material.uniforms.uvTransform.value.copy(g.matrix),
          (v !== g || y !== g.version || S !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (v = g),
            (y = g.version),
            (S = n.toneMapping)),
          h.layers.enableAll(),
          f.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function _(f, d) {
    f.getRGB(rm, vR(n)), i.buffers.color.setClear(rm.r, rm.g, rm.b, d, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (f, d = 1) {
      a.set(f), (u = d), _(a, u);
    },
    getClearAlpha: function () {
      return u;
    },
    setClearAlpha: function (f) {
      (u = f), _(a, u);
    },
    render: x,
  };
}
function c4(n, e, t, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    u = f(null);
  let h = u,
    p = !1;
  function v(F, X, G, ne, k) {
    let W = !1;
    if (o) {
      const H = _(ne, G, X);
      h !== H && ((h = H), S(h.object)),
        (W = d(F, ne, G, k)),
        W && m(F, ne, G, k);
    } else {
      const H = X.wireframe === !0;
      (h.geometry !== ne.id || h.program !== G.id || h.wireframe !== H) &&
        ((h.geometry = ne.id), (h.program = G.id), (h.wireframe = H), (W = !0));
    }
    k !== null && t.update(k, n.ELEMENT_ARRAY_BUFFER),
      (W || p) &&
        ((p = !1),
        L(F, X, G, ne),
        k !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(k).buffer));
  }
  function y() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function S(F) {
    return i.isWebGL2 ? n.bindVertexArray(F) : s.bindVertexArrayOES(F);
  }
  function x(F) {
    return i.isWebGL2 ? n.deleteVertexArray(F) : s.deleteVertexArrayOES(F);
  }
  function _(F, X, G) {
    const ne = G.wireframe === !0;
    let k = a[F.id];
    k === void 0 && ((k = {}), (a[F.id] = k));
    let W = k[X.id];
    W === void 0 && ((W = {}), (k[X.id] = W));
    let H = W[ne];
    return H === void 0 && ((H = f(y())), (W[ne] = H)), H;
  }
  function f(F) {
    const X = [],
      G = [],
      ne = [];
    for (let k = 0; k < r; k++) (X[k] = 0), (G[k] = 0), (ne[k] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: X,
      enabledAttributes: G,
      attributeDivisors: ne,
      object: F,
      attributes: {},
      index: null,
    };
  }
  function d(F, X, G, ne) {
    const k = h.attributes,
      W = X.attributes;
    let H = 0;
    const ee = G.getAttributes();
    for (const ae in ee)
      if (ee[ae].location >= 0) {
        const te = k[ae];
        let de = W[ae];
        if (
          (de === void 0 &&
            (ae === "instanceMatrix" &&
              F.instanceMatrix &&
              (de = F.instanceMatrix),
            ae === "instanceColor" &&
              F.instanceColor &&
              (de = F.instanceColor)),
          te === void 0 || te.attribute !== de || (de && te.data !== de.data))
        )
          return !0;
        H++;
      }
    return h.attributesNum !== H || h.index !== ne;
  }
  function m(F, X, G, ne) {
    const k = {},
      W = X.attributes;
    let H = 0;
    const ee = G.getAttributes();
    for (const ae in ee)
      if (ee[ae].location >= 0) {
        let te = W[ae];
        te === void 0 &&
          (ae === "instanceMatrix" &&
            F.instanceMatrix &&
            (te = F.instanceMatrix),
          ae === "instanceColor" && F.instanceColor && (te = F.instanceColor));
        const de = {};
        (de.attribute = te),
          te && te.data && (de.data = te.data),
          (k[ae] = de),
          H++;
      }
    (h.attributes = k), (h.attributesNum = H), (h.index = ne);
  }
  function g() {
    const F = h.newAttributes;
    for (let X = 0, G = F.length; X < G; X++) F[X] = 0;
  }
  function w(F) {
    T(F, 0);
  }
  function T(F, X) {
    const G = h.newAttributes,
      ne = h.enabledAttributes,
      k = h.attributeDivisors;
    (G[F] = 1),
      ne[F] === 0 && (n.enableVertexAttribArray(F), (ne[F] = 1)),
      k[F] !== X &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](F, X),
        (k[F] = X));
  }
  function C() {
    const F = h.newAttributes,
      X = h.enabledAttributes;
    for (let G = 0, ne = X.length; G < ne; G++)
      X[G] !== F[G] && (n.disableVertexAttribArray(G), (X[G] = 0));
  }
  function A(F, X, G, ne, k, W, H) {
    H === !0
      ? n.vertexAttribIPointer(F, X, G, k, W)
      : n.vertexAttribPointer(F, X, G, ne, k, W);
  }
  function L(F, X, G, ne) {
    if (
      i.isWebGL2 === !1 &&
      (F.isInstancedMesh || ne.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    g();
    const k = ne.attributes,
      W = G.getAttributes(),
      H = X.defaultAttributeValues;
    for (const ee in W) {
      const ae = W[ee];
      if (ae.location >= 0) {
        let xe = k[ee];
        if (
          (xe === void 0 &&
            (ee === "instanceMatrix" &&
              F.instanceMatrix &&
              (xe = F.instanceMatrix),
            ee === "instanceColor" &&
              F.instanceColor &&
              (xe = F.instanceColor)),
          xe !== void 0)
        ) {
          const te = xe.normalized,
            de = xe.itemSize,
            ye = t.get(xe);
          if (ye === void 0) continue;
          const Ce = ye.buffer,
            Ze = ye.type,
            ze = ye.bytesPerElement,
            tt =
              i.isWebGL2 === !0 &&
              (Ze === n.INT || Ze === n.UNSIGNED_INT || xe.gpuType === Mw);
          if (xe.isInterleavedBufferAttribute) {
            const Ge = xe.data,
              V = Ge.stride,
              be = xe.offset;
            if (Ge.isInstancedInterleavedBuffer) {
              for (let ge = 0; ge < ae.locationSize; ge++)
                T(ae.location + ge, Ge.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                ne._maxInstanceCount === void 0 &&
                (ne._maxInstanceCount = Ge.meshPerAttribute * Ge.count);
            } else
              for (let ge = 0; ge < ae.locationSize; ge++) w(ae.location + ge);
            n.bindBuffer(n.ARRAY_BUFFER, Ce);
            for (let ge = 0; ge < ae.locationSize; ge++)
              A(
                ae.location + ge,
                de / ae.locationSize,
                Ze,
                te,
                V * ze,
                (be + (de / ae.locationSize) * ge) * ze,
                tt,
              );
          } else {
            if (xe.isInstancedBufferAttribute) {
              for (let Ge = 0; Ge < ae.locationSize; Ge++)
                T(ae.location + Ge, xe.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                ne._maxInstanceCount === void 0 &&
                (ne._maxInstanceCount = xe.meshPerAttribute * xe.count);
            } else
              for (let Ge = 0; Ge < ae.locationSize; Ge++) w(ae.location + Ge);
            n.bindBuffer(n.ARRAY_BUFFER, Ce);
            for (let Ge = 0; Ge < ae.locationSize; Ge++)
              A(
                ae.location + Ge,
                de / ae.locationSize,
                Ze,
                te,
                de * ze,
                (de / ae.locationSize) * Ge * ze,
                tt,
              );
          }
        } else if (H !== void 0) {
          const te = H[ee];
          if (te !== void 0)
            switch (te.length) {
              case 2:
                n.vertexAttrib2fv(ae.location, te);
                break;
              case 3:
                n.vertexAttrib3fv(ae.location, te);
                break;
              case 4:
                n.vertexAttrib4fv(ae.location, te);
                break;
              default:
                n.vertexAttrib1fv(ae.location, te);
            }
        }
      }
    }
    C();
  }
  function N() {
    Q();
    for (const F in a) {
      const X = a[F];
      for (const G in X) {
        const ne = X[G];
        for (const k in ne) x(ne[k].object), delete ne[k];
        delete X[G];
      }
      delete a[F];
    }
  }
  function P(F) {
    if (a[F.id] === void 0) return;
    const X = a[F.id];
    for (const G in X) {
      const ne = X[G];
      for (const k in ne) x(ne[k].object), delete ne[k];
      delete X[G];
    }
    delete a[F.id];
  }
  function I(F) {
    for (const X in a) {
      const G = a[X];
      if (G[F.id] === void 0) continue;
      const ne = G[F.id];
      for (const k in ne) x(ne[k].object), delete ne[k];
      delete G[F.id];
    }
  }
  function Q() {
    ue(), (p = !0), h !== u && ((h = u), S(h.object));
  }
  function ue() {
    (u.geometry = null), (u.program = null), (u.wireframe = !1);
  }
  return {
    setup: v,
    reset: Q,
    resetDefaultState: ue,
    dispose: N,
    releaseStatesOfGeometry: P,
    releaseStatesOfProgram: I,
    initAttributes: g,
    enableAttribute: w,
    disableUnusedAttributes: C,
  };
}
function d4(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(p) {
    s = p;
  }
  function a(p, v) {
    n.drawArrays(s, p, v), t.update(v, s, 1);
  }
  function u(p, v, y) {
    if (y === 0) return;
    let S, x;
    if (r) (S = n), (x = "drawArraysInstanced");
    else if (
      ((S = e.get("ANGLE_instanced_arrays")),
      (x = "drawArraysInstancedANGLE"),
      S === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
      );
      return;
    }
    S[x](s, p, v, y), t.update(v, s, y);
  }
  function h(p, v, y) {
    if (y === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null) for (let x = 0; x < y; x++) this.render(p[x], v[x]);
    else {
      S.multiDrawArraysWEBGL(s, p, 0, v, 0, y);
      let x = 0;
      for (let _ = 0; _ < y; _++) x += v[_];
      t.update(x, s, 1);
    }
  }
  (this.setMode = o),
    (this.render = a),
    (this.renderInstances = u),
    (this.renderMultiDraw = h);
}
function h4(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const A = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(A) {
    if (A === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      A = "mediump";
    }
    return A === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const u = s(a);
  u !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      u,
      "instead.",
    ),
    (a = u));
  const h = o || e.has("WEBGL_draw_buffers"),
    p = t.logarithmicDepthBuffer === !0,
    v = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    y = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    S = n.getParameter(n.MAX_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    f = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    d = n.getParameter(n.MAX_VARYING_VECTORS),
    m = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    g = y > 0,
    w = o || e.has("OES_texture_float"),
    T = g && w,
    C = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: h,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: p,
    maxTextures: v,
    maxVertexTextures: y,
    maxTextureSize: S,
    maxCubemapSize: x,
    maxAttributes: _,
    maxVertexUniforms: f,
    maxVaryings: d,
    maxFragmentUniforms: m,
    vertexTextures: g,
    floatFragmentTextures: w,
    floatVertexTextures: T,
    maxSamples: C,
  };
}
function f4(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Yo(),
    a = new Nt(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (v, y) {
      const S = v.length !== 0 || y || i !== 0 || r;
      return (r = y), (i = v.length), S;
    }),
    (this.beginShadows = function () {
      (s = !0), p(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (v, y) {
      t = p(v, y, 0);
    }),
    (this.setState = function (v, y, S) {
      const x = v.clippingPlanes,
        _ = v.clipIntersection,
        f = v.clipShadows,
        d = n.get(v);
      if (!r || x === null || x.length === 0 || (s && !f)) s ? p(null) : h();
      else {
        const m = s ? 0 : i,
          g = m * 4;
        let w = d.clippingState || null;
        (u.value = w), (w = p(x, y, g, S));
        for (let T = 0; T !== g; ++T) w[T] = t[T];
        (d.clippingState = w),
          (this.numIntersection = _ ? this.numPlanes : 0),
          (this.numPlanes += m);
      }
    });
  function h() {
    u.value !== t && ((u.value = t), (u.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function p(v, y, S, x) {
    const _ = v !== null ? v.length : 0;
    let f = null;
    if (_ !== 0) {
      if (((f = u.value), x !== !0 || f === null)) {
        const d = S + _ * 4,
          m = y.matrixWorldInverse;
        a.getNormalMatrix(m),
          (f === null || f.length < d) && (f = new Float32Array(d));
        for (let g = 0, w = S; g !== _; ++g, w += 4)
          o.copy(v[g]).applyMatrix4(m, a),
            o.normal.toArray(f, w),
            (f[w + 3] = o.constant);
      }
      (u.value = f), (u.needsUpdate = !0);
    }
    return (e.numPlanes = _), (e.numIntersection = 0), f;
  }
}
function p4(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Ah ? (o.mapping = vo) : a === Ph && (o.mapping = Ea), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Ah || a === Ph)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return t(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const h = new xR(u.height);
            return (
              h.fromEquirectangularTexture(n, o),
              e.set(o, h),
              o.addEventListener("dispose", r),
              t(h.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const u = e.get(a);
    u !== void 0 && (e.delete(a), u.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class Mf extends xf {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      u = r - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
        p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += h * this.view.offsetX),
        (o = s + h * this.view.width),
        (a -= p * this.view.offsetY),
        (u = a - p * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      u,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const ec = 4,
  OT = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  cl = 20,
  B0 = new Mf(),
  NT = new Qe();
let z0 = null,
  H0 = 0,
  V0 = 0;
const al = (1 + Math.sqrt(5)) / 2,
  Pu = 1 / al,
  DT = [
    new B(1, 1, 1),
    new B(-1, 1, 1),
    new B(1, 1, -1),
    new B(-1, 1, -1),
    new B(0, al, Pu),
    new B(0, al, -Pu),
    new B(Pu, 0, al),
    new B(-Pu, 0, al),
    new B(al, Pu, 0),
    new B(-al, Pu, 0),
  ];
class aS {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (z0 = this._renderer.getRenderTarget()),
      (H0 = this._renderer.getActiveCubeFace()),
      (V0 = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = FT()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = UT()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(z0, H0, V0),
      (e.scissorTest = !1),
      sm(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === vo || e.mapping === Ea
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (z0 = this._renderer.getRenderTarget()),
      (H0 = this._renderer.getActiveCubeFace()),
      (V0 = this._renderer.getActiveMipmapLevel());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: xn,
        minFilter: xn,
        generateMipmaps: !1,
        type: Uc,
        format: Ni,
        colorSpace: Ds,
        depthBuffer: !1,
      },
      r = kT(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = kT(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = m4(s)),
        (this._blurMaterial = g4(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Bn(this._lodPlanes[0], e);
    this._renderer.compile(t, B0);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new ei(90, 1, t, i),
      u = [1, -1, 1, 1, 1, 1],
      h = [1, 1, 1, -1, -1, -1],
      p = this._renderer,
      v = p.autoClear,
      y = p.toneMapping;
    p.getClearColor(NT), (p.toneMapping = Is), (p.autoClear = !1);
    const S = new Ia({
        name: "PMREM.Background",
        side: Ui,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new Bn(new ql(), S);
    let _ = !1;
    const f = e.background;
    f
      ? f.isColor && (S.color.copy(f), (e.background = null), (_ = !0))
      : (S.color.copy(NT), (_ = !0));
    for (let d = 0; d < 6; d++) {
      const m = d % 3;
      m === 0
        ? (a.up.set(0, u[d], 0), a.lookAt(h[d], 0, 0))
        : m === 1
          ? (a.up.set(0, 0, u[d]), a.lookAt(0, h[d], 0))
          : (a.up.set(0, u[d], 0), a.lookAt(0, 0, h[d]));
      const g = this._cubeSize;
      sm(r, m * g, d > 2 ? g : 0, g, g),
        p.setRenderTarget(r),
        _ && p.render(x, a),
        p.render(e, a);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (p.toneMapping = y),
      (p.autoClear = v),
      (e.background = f);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === vo || e.mapping === Ea;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = FT()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = UT());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Bn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const u = this._cubeSize;
    sm(t, 0, 0, 3 * u, 2 * u), i.setRenderTarget(t), i.render(o, B0);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1],
        ),
        o = DT[(r - 1) % DT.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const u = this._renderer,
      h = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!",
      );
    const p = 3,
      v = new Bn(this._lodPlanes[r], h),
      y = h.uniforms,
      S = this._sizeLods[i] - 1,
      x = isFinite(s) ? Math.PI / (2 * S) : (2 * Math.PI) / (2 * cl - 1),
      _ = s / x,
      f = isFinite(s) ? 1 + Math.floor(p * _) : cl;
    f > cl &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${cl}`,
      );
    const d = [];
    let m = 0;
    for (let A = 0; A < cl; ++A) {
      const L = A / _,
        N = Math.exp((-L * L) / 2);
      d.push(N), A === 0 ? (m += N) : A < f && (m += 2 * N);
    }
    for (let A = 0; A < d.length; A++) d[A] = d[A] / m;
    (y.envMap.value = e.texture),
      (y.samples.value = f),
      (y.weights.value = d),
      (y.latitudinal.value = o === "latitudinal"),
      a && (y.poleAxis.value = a);
    const { _lodMax: g } = this;
    (y.dTheta.value = x), (y.mipInt.value = g - i);
    const w = this._sizeLods[r],
      T = 3 * w * (r > g - ec ? r - g + ec : 0),
      C = 4 * (this._cubeSize - w);
    sm(t, T, C, 3 * w, 2 * w), u.setRenderTarget(t), u.render(v, B0);
  }
}
function m4(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - ec + 1 + OT.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let u = 1 / a;
    o > n - ec ? (u = OT[o - n + ec - 1]) : o === 0 && (u = 0), i.push(u);
    const h = 1 / (a - 2),
      p = -h,
      v = 1 + h,
      y = [p, p, v, p, v, v, p, p, v, v, p, v],
      S = 6,
      x = 6,
      _ = 3,
      f = 2,
      d = 1,
      m = new Float32Array(_ * x * S),
      g = new Float32Array(f * x * S),
      w = new Float32Array(d * x * S);
    for (let C = 0; C < S; C++) {
      const A = ((C % 3) * 2) / 3 - 1,
        L = C > 2 ? 0 : -1,
        N = [
          A,
          L,
          0,
          A + 2 / 3,
          L,
          0,
          A + 2 / 3,
          L + 1,
          0,
          A,
          L,
          0,
          A + 2 / 3,
          L + 1,
          0,
          A,
          L + 1,
          0,
        ];
      m.set(N, _ * x * C), g.set(y, f * x * C);
      const P = [C, C, C, C, C, C];
      w.set(P, d * x * C);
    }
    const T = new Rt();
    T.setAttribute("position", new Jt(m, _)),
      T.setAttribute("uv", new Jt(g, f)),
      T.setAttribute("faceIndex", new Jt(w, d)),
      e.push(T),
      r > ec && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function kT(n, e, t) {
  const i = new as(n, e, t);
  return (
    (i.texture.mapping = jc),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function sm(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function g4(n, e, t) {
  const i = new Float32Array(cl),
    r = new B(0, 1, 0);
  return new ls({
    name: "SphericalGaussianBlur",
    defines: {
      n: cl,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: Fw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: uo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function UT() {
  return new ls({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Fw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: uo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function FT() {
  return new ls({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Fw(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: uo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Fw() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function v4(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const u = a.mapping,
        h = u === Ah || u === Ph,
        p = u === vo || u === Ea;
      if (h || p)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let v = e.get(a);
          return (
            t === null && (t = new aS(n)),
            (v = h ? t.fromEquirectangular(a, v) : t.fromCubemap(a, v)),
            e.set(a, v),
            v.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const v = a.image;
            if ((h && v && v.height > 0) || (p && v && r(v))) {
              t === null && (t = new aS(n));
              const y = h ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, y), a.addEventListener("dispose", s), y.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let u = 0;
    const h = 6;
    for (let p = 0; p < h; p++) a[p] !== void 0 && u++;
    return u === h;
  }
  function s(a) {
    const u = a.target;
    u.removeEventListener("dispose", s);
    const h = e.get(u);
    h !== void 0 && (e.delete(u), h.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function y4(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"))
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported.",
          ),
        r
      );
    },
  };
}
function _4(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(v) {
    const y = v.target;
    y.index !== null && e.remove(y.index);
    for (const x in y.attributes) e.remove(y.attributes[x]);
    for (const x in y.morphAttributes) {
      const _ = y.morphAttributes[x];
      for (let f = 0, d = _.length; f < d; f++) e.remove(_[f]);
    }
    y.removeEventListener("dispose", o), delete r[y.id];
    const S = s.get(y);
    S && (e.remove(S), s.delete(y)),
      i.releaseStatesOfGeometry(y),
      y.isInstancedBufferGeometry === !0 && delete y._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(v, y) {
    return (
      r[y.id] === !0 ||
        (y.addEventListener("dispose", o),
        (r[y.id] = !0),
        t.memory.geometries++),
      y
    );
  }
  function u(v) {
    const y = v.attributes;
    for (const x in y) e.update(y[x], n.ARRAY_BUFFER);
    const S = v.morphAttributes;
    for (const x in S) {
      const _ = S[x];
      for (let f = 0, d = _.length; f < d; f++) e.update(_[f], n.ARRAY_BUFFER);
    }
  }
  function h(v) {
    const y = [],
      S = v.index,
      x = v.attributes.position;
    let _ = 0;
    if (S !== null) {
      const m = S.array;
      _ = S.version;
      for (let g = 0, w = m.length; g < w; g += 3) {
        const T = m[g + 0],
          C = m[g + 1],
          A = m[g + 2];
        y.push(T, C, C, A, A, T);
      }
    } else if (x !== void 0) {
      const m = x.array;
      _ = x.version;
      for (let g = 0, w = m.length / 3 - 1; g < w; g += 3) {
        const T = g + 0,
          C = g + 1,
          A = g + 2;
        y.push(T, C, C, A, A, T);
      }
    } else return;
    const f = new (fR(y) ? Uw : kw)(y, 1);
    f.version = _;
    const d = s.get(v);
    d && e.remove(d), s.set(v, f);
  }
  function p(v) {
    const y = s.get(v);
    if (y) {
      const S = v.index;
      S !== null && y.version < S.version && h(v);
    } else h(v);
    return s.get(v);
  }
  return { get: a, update: u, getWireframeAttribute: p };
}
function x4(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(S) {
    s = S;
  }
  let a, u;
  function h(S) {
    (a = S.type), (u = S.bytesPerElement);
  }
  function p(S, x) {
    n.drawElements(s, x, a, S * u), t.update(x, s, 1);
  }
  function v(S, x, _) {
    if (_ === 0) return;
    let f, d;
    if (r) (f = n), (d = "drawElementsInstanced");
    else if (
      ((f = e.get("ANGLE_instanced_arrays")),
      (d = "drawElementsInstancedANGLE"),
      f === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
      );
      return;
    }
    f[d](s, x, a, S * u, _), t.update(x, s, _);
  }
  function y(S, x, _) {
    if (_ === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null) for (let d = 0; d < _; d++) this.render(S[d] / u, x[d]);
    else {
      f.multiDrawElementsWEBGL(s, x, 0, a, S, 0, _);
      let d = 0;
      for (let m = 0; m < _; m++) d += x[m];
      t.update(d, s, 1);
    }
  }
  (this.setMode = o),
    (this.setIndex = h),
    (this.render = p),
    (this.renderInstances = v),
    (this.renderMultiDraw = y);
}
function S4(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function w4(n, e) {
  return n[0] - e[0];
}
function M4(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function E4(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new rn(),
    a = [];
  for (let h = 0; h < 8; h++) a[h] = [h, 0];
  function u(h, p, v) {
    const y = h.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const x =
          p.morphAttributes.position ||
          p.morphAttributes.normal ||
          p.morphAttributes.color,
        _ = x !== void 0 ? x.length : 0;
      let f = s.get(p);
      if (f === void 0 || f.count !== _) {
        let X = function () {
          ue.dispose(), s.delete(p), p.removeEventListener("dispose", X);
        };
        var S = X;
        f !== void 0 && f.texture.dispose();
        const g = p.morphAttributes.position !== void 0,
          w = p.morphAttributes.normal !== void 0,
          T = p.morphAttributes.color !== void 0,
          C = p.morphAttributes.position || [],
          A = p.morphAttributes.normal || [],
          L = p.morphAttributes.color || [];
        let N = 0;
        g === !0 && (N = 1), w === !0 && (N = 2), T === !0 && (N = 3);
        let P = p.attributes.position.count * N,
          I = 1;
        P > e.maxTextureSize &&
          ((I = Math.ceil(P / e.maxTextureSize)), (P = e.maxTextureSize));
        const Q = new Float32Array(P * I * 4 * _),
          ue = new vv(Q, P, I, _);
        (ue.type = Br), (ue.needsUpdate = !0);
        const F = N * 4;
        for (let G = 0; G < _; G++) {
          const ne = C[G],
            k = A[G],
            W = L[G],
            H = P * I * 4 * G;
          for (let ee = 0; ee < ne.count; ee++) {
            const ae = ee * F;
            g === !0 &&
              (o.fromBufferAttribute(ne, ee),
              (Q[H + ae + 0] = o.x),
              (Q[H + ae + 1] = o.y),
              (Q[H + ae + 2] = o.z),
              (Q[H + ae + 3] = 0)),
              w === !0 &&
                (o.fromBufferAttribute(k, ee),
                (Q[H + ae + 4] = o.x),
                (Q[H + ae + 5] = o.y),
                (Q[H + ae + 6] = o.z),
                (Q[H + ae + 7] = 0)),
              T === !0 &&
                (o.fromBufferAttribute(W, ee),
                (Q[H + ae + 8] = o.x),
                (Q[H + ae + 9] = o.y),
                (Q[H + ae + 10] = o.z),
                (Q[H + ae + 11] = W.itemSize === 4 ? o.w : 1));
          }
        }
        (f = { count: _, texture: ue, size: new Me(P, I) }),
          s.set(p, f),
          p.addEventListener("dispose", X);
      }
      let d = 0;
      for (let g = 0; g < y.length; g++) d += y[g];
      const m = p.morphTargetsRelative ? 1 : 1 - d;
      v.getUniforms().setValue(n, "morphTargetBaseInfluence", m),
        v.getUniforms().setValue(n, "morphTargetInfluences", y),
        v.getUniforms().setValue(n, "morphTargetsTexture", f.texture, t),
        v.getUniforms().setValue(n, "morphTargetsTextureSize", f.size);
    } else {
      const x = y === void 0 ? 0 : y.length;
      let _ = i[p.id];
      if (_ === void 0 || _.length !== x) {
        _ = [];
        for (let w = 0; w < x; w++) _[w] = [w, 0];
        i[p.id] = _;
      }
      for (let w = 0; w < x; w++) {
        const T = _[w];
        (T[0] = w), (T[1] = y[w]);
      }
      _.sort(M4);
      for (let w = 0; w < 8; w++)
        w < x && _[w][1]
          ? ((a[w][0] = _[w][0]), (a[w][1] = _[w][1]))
          : ((a[w][0] = Number.MAX_SAFE_INTEGER), (a[w][1] = 0));
      a.sort(w4);
      const f = p.morphAttributes.position,
        d = p.morphAttributes.normal;
      let m = 0;
      for (let w = 0; w < 8; w++) {
        const T = a[w],
          C = T[0],
          A = T[1];
        C !== Number.MAX_SAFE_INTEGER && A
          ? (f &&
              p.getAttribute("morphTarget" + w) !== f[C] &&
              p.setAttribute("morphTarget" + w, f[C]),
            d &&
              p.getAttribute("morphNormal" + w) !== d[C] &&
              p.setAttribute("morphNormal" + w, d[C]),
            (r[w] = A),
            (m += A))
          : (f &&
              p.hasAttribute("morphTarget" + w) === !0 &&
              p.deleteAttribute("morphTarget" + w),
            d &&
              p.hasAttribute("morphNormal" + w) === !0 &&
              p.deleteAttribute("morphNormal" + w),
            (r[w] = 0));
      }
      const g = p.morphTargetsRelative ? 1 : 1 - m;
      v.getUniforms().setValue(n, "morphTargetBaseInfluence", g),
        v.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: u };
}
function T4(n, e, t, i) {
  let r = new WeakMap();
  function s(u) {
    const h = i.render.frame,
      p = u.geometry,
      v = e.get(u, p);
    if (
      (r.get(v) !== h && (e.update(v), r.set(v, h)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", a) === !1 &&
          u.addEventListener("dispose", a),
        r.get(u) !== h &&
          (t.update(u.instanceMatrix, n.ARRAY_BUFFER),
          u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER),
          r.set(u, h))),
      u.isSkinnedMesh)
    ) {
      const y = u.skeleton;
      r.get(y) !== h && (y.update(), r.set(y, h));
    }
    return v;
  }
  function o() {
    r = new WeakMap();
  }
  function a(u) {
    const h = u.target;
    h.removeEventListener("dispose", a),
      t.remove(h.instanceMatrix),
      h.instanceColor !== null && t.remove(h.instanceColor);
  }
  return { update: s, dispose: o };
}
class Bw extends Mn {
  constructor(e, t, i, r, s, o, a, u, h, p) {
    if (((p = p !== void 0 ? p : _a), p !== _a && p !== Hl))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    i === void 0 && p === _a && (i = so),
      i === void 0 && p === Hl && (i = ya),
      super(null, r, s, o, a, u, p, i, h),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : In),
      (this.minFilter = u !== void 0 ? u : In),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const wR = new Mn(),
  MR = new Bw(1, 1);
MR.compareFunction = Iw;
const ER = new vv(),
  TR = new Dw(),
  CR = new Sf(),
  BT = [],
  zT = [],
  HT = new Float32Array(16),
  VT = new Float32Array(9),
  GT = new Float32Array(4);
function $c(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = BT[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (BT[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Xn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function qn(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function yv(n, e) {
  let t = zT[e];
  t === void 0 && ((t = new Int32Array(e)), (zT[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function C4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function b4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xn(t, e)) return;
    n.uniform2fv(this.addr, e), qn(t, e);
  }
}
function A4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Xn(t, e)) return;
    n.uniform3fv(this.addr, e), qn(t, e);
  }
}
function P4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xn(t, e)) return;
    n.uniform4fv(this.addr, e), qn(t, e);
  }
}
function R4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Xn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), qn(t, e);
  } else {
    if (Xn(t, i)) return;
    GT.set(i), n.uniformMatrix2fv(this.addr, !1, GT), qn(t, i);
  }
}
function L4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Xn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), qn(t, e);
  } else {
    if (Xn(t, i)) return;
    VT.set(i), n.uniformMatrix3fv(this.addr, !1, VT), qn(t, i);
  }
}
function I4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Xn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), qn(t, e);
  } else {
    if (Xn(t, i)) return;
    HT.set(i), n.uniformMatrix4fv(this.addr, !1, HT), qn(t, i);
  }
}
function O4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function N4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xn(t, e)) return;
    n.uniform2iv(this.addr, e), qn(t, e);
  }
}
function D4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Xn(t, e)) return;
    n.uniform3iv(this.addr, e), qn(t, e);
  }
}
function k4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xn(t, e)) return;
    n.uniform4iv(this.addr, e), qn(t, e);
  }
}
function U4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function F4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xn(t, e)) return;
    n.uniform2uiv(this.addr, e), qn(t, e);
  }
}
function B4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Xn(t, e)) return;
    n.uniform3uiv(this.addr, e), qn(t, e);
  }
}
function z4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xn(t, e)) return;
    n.uniform4uiv(this.addr, e), qn(t, e);
  }
}
function H4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
  const s = this.type === n.SAMPLER_2D_SHADOW ? MR : wR;
  t.setTexture2D(e || s, r);
}
function V4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || TR, r);
}
function G4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || CR, r);
}
function W4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || ER, r);
}
function j4(n) {
  switch (n) {
    case 5126:
      return C4;
    case 35664:
      return b4;
    case 35665:
      return A4;
    case 35666:
      return P4;
    case 35674:
      return R4;
    case 35675:
      return L4;
    case 35676:
      return I4;
    case 5124:
    case 35670:
      return O4;
    case 35667:
    case 35671:
      return N4;
    case 35668:
    case 35672:
      return D4;
    case 35669:
    case 35673:
      return k4;
    case 5125:
      return U4;
    case 36294:
      return F4;
    case 36295:
      return B4;
    case 36296:
      return z4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return H4;
    case 35679:
    case 36299:
    case 36307:
      return V4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return G4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return W4;
  }
}
function X4(n, e) {
  n.uniform1fv(this.addr, e);
}
function q4(n, e) {
  const t = $c(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function $4(n, e) {
  const t = $c(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Y4(n, e) {
  const t = $c(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function K4(n, e) {
  const t = $c(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Q4(n, e) {
  const t = $c(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function Z4(n, e) {
  const t = $c(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function J4(n, e) {
  n.uniform1iv(this.addr, e);
}
function eH(n, e) {
  n.uniform2iv(this.addr, e);
}
function tH(n, e) {
  n.uniform3iv(this.addr, e);
}
function nH(n, e) {
  n.uniform4iv(this.addr, e);
}
function iH(n, e) {
  n.uniform1uiv(this.addr, e);
}
function rH(n, e) {
  n.uniform2uiv(this.addr, e);
}
function sH(n, e) {
  n.uniform3uiv(this.addr, e);
}
function oH(n, e) {
  n.uniform4uiv(this.addr, e);
}
function aH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = yv(t, r);
  Xn(i, s) || (n.uniform1iv(this.addr, s), qn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || wR, s[o]);
}
function lH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = yv(t, r);
  Xn(i, s) || (n.uniform1iv(this.addr, s), qn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || TR, s[o]);
}
function uH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = yv(t, r);
  Xn(i, s) || (n.uniform1iv(this.addr, s), qn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || CR, s[o]);
}
function cH(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = yv(t, r);
  Xn(i, s) || (n.uniform1iv(this.addr, s), qn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || ER, s[o]);
}
function dH(n) {
  switch (n) {
    case 5126:
      return X4;
    case 35664:
      return q4;
    case 35665:
      return $4;
    case 35666:
      return Y4;
    case 35674:
      return K4;
    case 35675:
      return Q4;
    case 35676:
      return Z4;
    case 5124:
    case 35670:
      return J4;
    case 35667:
    case 35671:
      return eH;
    case 35668:
    case 35672:
      return tH;
    case 35669:
    case 35673:
      return nH;
    case 5125:
      return iH;
    case 36294:
      return rH;
    case 36295:
      return sH;
    case 36296:
      return oH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return aH;
    case 35679:
    case 36299:
    case 36307:
      return lH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return uH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return cH;
  }
}
class hH {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = j4(t.type));
  }
}
class fH {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = dH(t.type));
  }
}
class pH {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const G0 = /(\w+)(\])?(\[|\.)?/g;
function WT(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function mH(n, e, t) {
  const i = n.name,
    r = i.length;
  for (G0.lastIndex = 0; ; ) {
    const s = G0.exec(i),
      o = G0.lastIndex;
    let a = s[1];
    const u = s[2] === "]",
      h = s[3];
    if ((u && (a = a | 0), h === void 0 || (h === "[" && o + 2 === r))) {
      WT(t, h === void 0 ? new hH(a, n, e) : new fH(a, n, e));
      break;
    } else {
      let v = t.map[a];
      v === void 0 && ((v = new pH(a)), WT(t, v)), (t = v);
    }
  }
}
class sg {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      mH(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        u = i[a.id];
      u.needsUpdate !== !1 && a.setValue(e, u.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function jT(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
const gH = 37297;
let vH = 0;
function yH(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function _H(n) {
  const e = nn.getPrimaries(nn.workingColorSpace),
    t = nn.getPrimaries(n);
  let i;
  switch (
    (e === t
      ? (i = "")
      : e === Uh && t === kh
        ? (i = "LinearDisplayP3ToLinearSRGB")
        : e === kh && t === Uh && (i = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case Ds:
    case yf:
      return [i, "LinearTransferOETF"];
    case Wn:
    case gv:
      return [i, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
      );
  }
}
function XT(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      yH(n.getShaderSource(e), o)
    );
  } else return r;
}
function xH(n, e) {
  const t = _H(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function SH(n, e) {
  let t;
  switch (e) {
    case z2:
      t = "Linear";
      break;
    case H2:
      t = "Reinhard";
      break;
    case V2:
      t = "OptimizedCineon";
      break;
    case ww:
      t = "ACESFilmic";
      break;
    case W2:
      t = "AgX";
      break;
    case G2:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function wH(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.alphaToCoverage ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(tc).join(`
`);
}
function MH(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(tc).join(`
`);
}
function EH(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function TH(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function tc(n) {
  return n !== "";
}
function qT(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function $T(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    );
}
const CH = /^[ \t]*#include +<([\w\d./]+)>/gm;
function lS(n) {
  return n.replace(CH, AH);
}
const bH = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function AH(n, e) {
  let t = It[e];
  if (t === void 0) {
    const i = bH.get(e);
    if (i !== void 0)
      (t = It[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i,
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return lS(t);
}
const PH =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function YT(n) {
  return n.replace(PH, RH);
}
function RH(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function KT(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	`;
  return (
    n.isWebGL2 &&
      (e += `precision ${n.precision} sampler3D;
		precision ${n.precision} sampler2DArray;
		precision ${n.precision} sampler2DShadow;
		precision ${n.precision} samplerCubeShadow;
		precision ${n.precision} sampler2DArrayShadow;
		precision ${n.precision} isampler2D;
		precision ${n.precision} isampler3D;
		precision ${n.precision} isamplerCube;
		precision ${n.precision} isampler2DArray;
		precision ${n.precision} usampler2D;
		precision ${n.precision} usampler3D;
		precision ${n.precision} usamplerCube;
		precision ${n.precision} usampler2DArray;
		`),
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : n.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function LH(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === hv
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === eh
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : n.shadowMapType === Jr && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function IH(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case vo:
      case Ea:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case jc:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function OH(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Ea:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function NH(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case vf:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case F2:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case B2:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function DH(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function kH(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const u = LH(t),
    h = IH(t),
    p = OH(t),
    v = NH(t),
    y = DH(t),
    S = t.isWebGL2 ? "" : wH(t),
    x = MH(t),
    _ = EH(s),
    f = r.createProgram();
  let d,
    m,
    g = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((d = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(tc).join(`
`)),
      d.length > 0 &&
        (d += `
`),
      (m = [
        S,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(tc).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((d = [
        KT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + p : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(tc).join(`
`)),
      (m = [
        S,
        KT(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + p : "",
        t.envMap ? "#define " + v : "",
        y ? "#define CUBEUV_TEXEL_WIDTH " + y.texelWidth : "",
        y ? "#define CUBEUV_TEXEL_HEIGHT " + y.texelHeight : "",
        y ? "#define CUBEUV_MAX_MIP " + y.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + u : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Is ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Is ? It.tonemapping_pars_fragment : "",
        t.toneMapping !== Is ? SH("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        It.colorspace_pars_fragment,
        xH("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(tc).join(`
`))),
    (o = lS(o)),
    (o = qT(o, t)),
    (o = $T(o, t)),
    (a = lS(a)),
    (a = qT(a, t)),
    (a = $T(a, t)),
    (o = YT(o)),
    (a = YT(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((g = `#version 300 es
`),
      (d =
        [
          x,
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        d),
      (m =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          t.glslVersion === sS
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === sS ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        m));
  const w = g + d + o,
    T = g + m + a,
    C = jT(r, r.VERTEX_SHADER, w),
    A = jT(r, r.FRAGMENT_SHADER, T);
  r.attachShader(f, C),
    r.attachShader(f, A),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(f, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(f, 0, "position"),
    r.linkProgram(f);
  function L(Q) {
    if (n.debug.checkShaderErrors) {
      const ue = r.getProgramInfoLog(f).trim(),
        F = r.getShaderInfoLog(C).trim(),
        X = r.getShaderInfoLog(A).trim();
      let G = !0,
        ne = !0;
      if (r.getProgramParameter(f, r.LINK_STATUS) === !1)
        if (((G = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(r, f, C, A);
        else {
          const k = XT(r, C, "vertex"),
            W = XT(r, A, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(f, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              Q.name +
              `
Material Type: ` +
              Q.type +
              `

Program Info Log: ` +
              ue +
              `
` +
              k +
              `
` +
              W,
          );
        }
      else
        ue !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", ue)
          : (F === "" || X === "") && (ne = !1);
      ne &&
        (Q.diagnostics = {
          runnable: G,
          programLog: ue,
          vertexShader: { log: F, prefix: d },
          fragmentShader: { log: X, prefix: m },
        });
    }
    r.deleteShader(C), r.deleteShader(A), (N = new sg(r, f)), (P = TH(r, f));
  }
  let N;
  this.getUniforms = function () {
    return N === void 0 && L(this), N;
  };
  let P;
  this.getAttributes = function () {
    return P === void 0 && L(this), P;
  };
  let I = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return I === !1 && (I = r.getProgramParameter(f, gH)), I;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(f),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = vH++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = f),
    (this.vertexShader = C),
    (this.fragmentShader = A),
    this
  );
}
let UH = 0;
class FH {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new BH(e)), t.set(e, i)), i;
  }
}
class BH {
  constructor(e) {
    (this.id = UH++), (this.code = e), (this.usedTimes = 0);
  }
}
function zH(n, e, t, i, r, s, o) {
  const a = new Il(),
    u = new FH(),
    h = new Set(),
    p = [],
    v = r.isWebGL2,
    y = r.logarithmicDepthBuffer,
    S = r.vertexTextures;
  let x = r.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function f(P) {
    return h.add(P), P === 0 ? "uv" : `uv${P}`;
  }
  function d(P, I, Q, ue, F) {
    const X = ue.fog,
      G = F.geometry,
      ne = P.isMeshStandardMaterial ? ue.environment : null,
      k = (P.isMeshStandardMaterial ? t : e).get(P.envMap || ne),
      W = k && k.mapping === jc ? k.image.height : null,
      H = _[P.type];
    P.precision !== null &&
      ((x = r.getMaxPrecision(P.precision)),
      x !== P.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          P.precision,
          "not supported, using",
          x,
          "instead.",
        ));
    const ee =
        G.morphAttributes.position ||
        G.morphAttributes.normal ||
        G.morphAttributes.color,
      ae = ee !== void 0 ? ee.length : 0;
    let xe = 0;
    G.morphAttributes.position !== void 0 && (xe = 1),
      G.morphAttributes.normal !== void 0 && (xe = 2),
      G.morphAttributes.color !== void 0 && (xe = 3);
    let te, de, ye, Ce;
    if (H) {
      const Xt = is[H];
      (te = Xt.vertexShader), (de = Xt.fragmentShader);
    } else
      (te = P.vertexShader),
        (de = P.fragmentShader),
        u.update(P),
        (ye = u.getVertexShaderID(P)),
        (Ce = u.getFragmentShaderID(P));
    const Ze = n.getRenderTarget(),
      ze = F.isInstancedMesh === !0,
      tt = F.isBatchedMesh === !0,
      Ge = !!P.map,
      V = !!P.matcap,
      be = !!k,
      ge = !!P.aoMap,
      Le = !!P.lightMap,
      Se = !!P.bumpMap,
      at = !!P.normalMap,
      We = !!P.displacementMap,
      U = !!P.emissiveMap,
      D = !!P.metalnessMap,
      le = !!P.roughnessMap,
      Re = P.anisotropy > 0,
      Ee = P.clearcoat > 0,
      Te = P.iridescence > 0,
      rt = P.sheen > 0,
      Be = P.transmission > 0,
      Ke = Re && !!P.anisotropyMap,
      mt = Ee && !!P.clearcoatMap,
      wt = Ee && !!P.clearcoatNormalMap,
      Ae = Ee && !!P.clearcoatRoughnessMap,
      Ht = Te && !!P.iridescenceMap,
      Ct = Te && !!P.iridescenceThicknessMap,
      yt = rt && !!P.sheenColorMap,
      dt = rt && !!P.sheenRoughnessMap,
      nt = !!P.specularMap,
      Mt = !!P.specularColorMap,
      kt = !!P.specularIntensityMap,
      Qt = Be && !!P.transmissionMap,
      Lt = Be && !!P.thicknessMap,
      Zt = !!P.gradientMap,
      j = !!P.alphaMap,
      Oe = P.alphaTest > 0,
      De = !!P.alphaHash,
      ot = !!P.extensions;
    let ft = Is;
    P.toneMapped &&
      (Ze === null || Ze.isXRRenderTarget === !0) &&
      (ft = n.toneMapping);
    const Vt = {
      isWebGL2: v,
      shaderID: H,
      shaderType: P.type,
      shaderName: P.name,
      vertexShader: te,
      fragmentShader: de,
      defines: P.defines,
      customVertexShaderID: ye,
      customFragmentShaderID: Ce,
      isRawShaderMaterial: P.isRawShaderMaterial === !0,
      glslVersion: P.glslVersion,
      precision: x,
      batching: tt,
      instancing: ze,
      instancingColor: ze && F.instanceColor !== null,
      supportsVertexTextures: S,
      outputColorSpace:
        Ze === null
          ? n.outputColorSpace
          : Ze.isXRRenderTarget === !0
            ? Ze.texture.colorSpace
            : Ds,
      alphaToCoverage: !!P.alphaToCoverage,
      map: Ge,
      matcap: V,
      envMap: be,
      envMapMode: be && k.mapping,
      envMapCubeUVHeight: W,
      aoMap: ge,
      lightMap: Le,
      bumpMap: Se,
      normalMap: at,
      displacementMap: S && We,
      emissiveMap: U,
      normalMapObjectSpace: at && P.normalMapType === sR,
      normalMapTangentSpace: at && P.normalMapType === La,
      metalnessMap: D,
      roughnessMap: le,
      anisotropy: Re,
      anisotropyMap: Ke,
      clearcoat: Ee,
      clearcoatMap: mt,
      clearcoatNormalMap: wt,
      clearcoatRoughnessMap: Ae,
      iridescence: Te,
      iridescenceMap: Ht,
      iridescenceThicknessMap: Ct,
      sheen: rt,
      sheenColorMap: yt,
      sheenRoughnessMap: dt,
      specularMap: nt,
      specularColorMap: Mt,
      specularIntensityMap: kt,
      transmission: Be,
      transmissionMap: Qt,
      thicknessMap: Lt,
      gradientMap: Zt,
      opaque:
        P.transparent === !1 && P.blending === Pl && P.alphaToCoverage === !1,
      alphaMap: j,
      alphaTest: Oe,
      alphaHash: De,
      combine: P.combine,
      mapUv: Ge && f(P.map.channel),
      aoMapUv: ge && f(P.aoMap.channel),
      lightMapUv: Le && f(P.lightMap.channel),
      bumpMapUv: Se && f(P.bumpMap.channel),
      normalMapUv: at && f(P.normalMap.channel),
      displacementMapUv: We && f(P.displacementMap.channel),
      emissiveMapUv: U && f(P.emissiveMap.channel),
      metalnessMapUv: D && f(P.metalnessMap.channel),
      roughnessMapUv: le && f(P.roughnessMap.channel),
      anisotropyMapUv: Ke && f(P.anisotropyMap.channel),
      clearcoatMapUv: mt && f(P.clearcoatMap.channel),
      clearcoatNormalMapUv: wt && f(P.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ae && f(P.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ht && f(P.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ct && f(P.iridescenceThicknessMap.channel),
      sheenColorMapUv: yt && f(P.sheenColorMap.channel),
      sheenRoughnessMapUv: dt && f(P.sheenRoughnessMap.channel),
      specularMapUv: nt && f(P.specularMap.channel),
      specularColorMapUv: Mt && f(P.specularColorMap.channel),
      specularIntensityMapUv: kt && f(P.specularIntensityMap.channel),
      transmissionMapUv: Qt && f(P.transmissionMap.channel),
      thicknessMapUv: Lt && f(P.thicknessMap.channel),
      alphaMapUv: j && f(P.alphaMap.channel),
      vertexTangents: !!G.attributes.tangent && (at || Re),
      vertexColors: P.vertexColors,
      vertexAlphas:
        P.vertexColors === !0 &&
        !!G.attributes.color &&
        G.attributes.color.itemSize === 4,
      pointsUvs: F.isPoints === !0 && !!G.attributes.uv && (Ge || j),
      fog: !!X,
      useFog: P.fog === !0,
      fogExp2: !!X && X.isFogExp2,
      flatShading: P.flatShading === !0,
      sizeAttenuation: P.sizeAttenuation === !0,
      logarithmicDepthBuffer: y,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: G.morphAttributes.position !== void 0,
      morphNormals: G.morphAttributes.normal !== void 0,
      morphColors: G.morphAttributes.color !== void 0,
      morphTargetsCount: ae,
      morphTextureStride: xe,
      numDirLights: I.directional.length,
      numPointLights: I.point.length,
      numSpotLights: I.spot.length,
      numSpotLightMaps: I.spotLightMap.length,
      numRectAreaLights: I.rectArea.length,
      numHemiLights: I.hemi.length,
      numDirLightShadows: I.directionalShadowMap.length,
      numPointLightShadows: I.pointShadowMap.length,
      numSpotLightShadows: I.spotShadowMap.length,
      numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
      numLightProbes: I.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: P.dithering,
      shadowMapEnabled: n.shadowMap.enabled && Q.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: ft,
      useLegacyLights: n._useLegacyLights,
      decodeVideoTexture:
        Ge &&
        P.map.isVideoTexture === !0 &&
        nn.getTransfer(P.map.colorSpace) === un,
      premultipliedAlpha: P.premultipliedAlpha,
      doubleSided: P.side === bs,
      flipSided: P.side === Ui,
      useDepthPacking: P.depthPacking >= 0,
      depthPacking: P.depthPacking || 0,
      index0AttributeName: P.index0AttributeName,
      extensionDerivatives: ot && P.extensions.derivatives === !0,
      extensionFragDepth: ot && P.extensions.fragDepth === !0,
      extensionDrawBuffers: ot && P.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: ot && P.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance:
        ot &&
        P.extensions.clipCullDistance === !0 &&
        i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ot && P.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"),
      rendererExtensionFragDepth: v || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: v || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: v || i.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: i.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: P.customProgramCacheKey(),
    };
    return (
      (Vt.vertexUv1s = h.has(1)),
      (Vt.vertexUv2s = h.has(2)),
      (Vt.vertexUv3s = h.has(3)),
      h.clear(),
      Vt
    );
  }
  function m(P) {
    const I = [];
    if (
      (P.shaderID
        ? I.push(P.shaderID)
        : (I.push(P.customVertexShaderID), I.push(P.customFragmentShaderID)),
      P.defines !== void 0)
    )
      for (const Q in P.defines) I.push(Q), I.push(P.defines[Q]);
    return (
      P.isRawShaderMaterial === !1 &&
        (g(I, P), w(I, P), I.push(n.outputColorSpace)),
      I.push(P.customProgramCacheKey),
      I.join()
    );
  }
  function g(P, I) {
    P.push(I.precision),
      P.push(I.outputColorSpace),
      P.push(I.envMapMode),
      P.push(I.envMapCubeUVHeight),
      P.push(I.mapUv),
      P.push(I.alphaMapUv),
      P.push(I.lightMapUv),
      P.push(I.aoMapUv),
      P.push(I.bumpMapUv),
      P.push(I.normalMapUv),
      P.push(I.displacementMapUv),
      P.push(I.emissiveMapUv),
      P.push(I.metalnessMapUv),
      P.push(I.roughnessMapUv),
      P.push(I.anisotropyMapUv),
      P.push(I.clearcoatMapUv),
      P.push(I.clearcoatNormalMapUv),
      P.push(I.clearcoatRoughnessMapUv),
      P.push(I.iridescenceMapUv),
      P.push(I.iridescenceThicknessMapUv),
      P.push(I.sheenColorMapUv),
      P.push(I.sheenRoughnessMapUv),
      P.push(I.specularMapUv),
      P.push(I.specularColorMapUv),
      P.push(I.specularIntensityMapUv),
      P.push(I.transmissionMapUv),
      P.push(I.thicknessMapUv),
      P.push(I.combine),
      P.push(I.fogExp2),
      P.push(I.sizeAttenuation),
      P.push(I.morphTargetsCount),
      P.push(I.morphAttributeCount),
      P.push(I.numDirLights),
      P.push(I.numPointLights),
      P.push(I.numSpotLights),
      P.push(I.numSpotLightMaps),
      P.push(I.numHemiLights),
      P.push(I.numRectAreaLights),
      P.push(I.numDirLightShadows),
      P.push(I.numPointLightShadows),
      P.push(I.numSpotLightShadows),
      P.push(I.numSpotLightShadowsWithMaps),
      P.push(I.numLightProbes),
      P.push(I.shadowMapType),
      P.push(I.toneMapping),
      P.push(I.numClippingPlanes),
      P.push(I.numClipIntersection),
      P.push(I.depthPacking);
  }
  function w(P, I) {
    a.disableAll(),
      I.isWebGL2 && a.enable(0),
      I.supportsVertexTextures && a.enable(1),
      I.instancing && a.enable(2),
      I.instancingColor && a.enable(3),
      I.matcap && a.enable(4),
      I.envMap && a.enable(5),
      I.normalMapObjectSpace && a.enable(6),
      I.normalMapTangentSpace && a.enable(7),
      I.clearcoat && a.enable(8),
      I.iridescence && a.enable(9),
      I.alphaTest && a.enable(10),
      I.vertexColors && a.enable(11),
      I.vertexAlphas && a.enable(12),
      I.vertexUv1s && a.enable(13),
      I.vertexUv2s && a.enable(14),
      I.vertexUv3s && a.enable(15),
      I.vertexTangents && a.enable(16),
      I.anisotropy && a.enable(17),
      I.alphaHash && a.enable(18),
      I.batching && a.enable(19),
      P.push(a.mask),
      a.disableAll(),
      I.fog && a.enable(0),
      I.useFog && a.enable(1),
      I.flatShading && a.enable(2),
      I.logarithmicDepthBuffer && a.enable(3),
      I.skinning && a.enable(4),
      I.morphTargets && a.enable(5),
      I.morphNormals && a.enable(6),
      I.morphColors && a.enable(7),
      I.premultipliedAlpha && a.enable(8),
      I.shadowMapEnabled && a.enable(9),
      I.useLegacyLights && a.enable(10),
      I.doubleSided && a.enable(11),
      I.flipSided && a.enable(12),
      I.useDepthPacking && a.enable(13),
      I.dithering && a.enable(14),
      I.transmission && a.enable(15),
      I.sheen && a.enable(16),
      I.opaque && a.enable(17),
      I.pointsUvs && a.enable(18),
      I.decodeVideoTexture && a.enable(19),
      I.alphaToCoverage && a.enable(20),
      P.push(a.mask);
  }
  function T(P) {
    const I = _[P.type];
    let Q;
    if (I) {
      const ue = is[I];
      Q = yR.clone(ue.uniforms);
    } else Q = P.uniforms;
    return Q;
  }
  function C(P, I) {
    let Q;
    for (let ue = 0, F = p.length; ue < F; ue++) {
      const X = p[ue];
      if (X.cacheKey === I) {
        (Q = X), ++Q.usedTimes;
        break;
      }
    }
    return Q === void 0 && ((Q = new kH(n, I, P, s)), p.push(Q)), Q;
  }
  function A(P) {
    if (--P.usedTimes === 0) {
      const I = p.indexOf(P);
      (p[I] = p[p.length - 1]), p.pop(), P.destroy();
    }
  }
  function L(P) {
    u.remove(P);
  }
  function N() {
    u.dispose();
  }
  return {
    getParameters: d,
    getProgramCacheKey: m,
    getUniforms: T,
    acquireProgram: C,
    releaseProgram: A,
    releaseShaderCache: L,
    programs: p,
    dispose: N,
  };
}
function HH() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function VH(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
}
function QT(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id;
}
function ZT() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(v, y, S, x, _, f) {
    let d = n[e];
    return (
      d === void 0
        ? ((d = {
            id: v.id,
            object: v,
            geometry: y,
            material: S,
            groupOrder: x,
            renderOrder: v.renderOrder,
            z: _,
            group: f,
          }),
          (n[e] = d))
        : ((d.id = v.id),
          (d.object = v),
          (d.geometry = y),
          (d.material = S),
          (d.groupOrder = x),
          (d.renderOrder = v.renderOrder),
          (d.z = _),
          (d.group = f)),
      e++,
      d
    );
  }
  function a(v, y, S, x, _, f) {
    const d = o(v, y, S, x, _, f);
    S.transmission > 0
      ? i.push(d)
      : S.transparent === !0
        ? r.push(d)
        : t.push(d);
  }
  function u(v, y, S, x, _, f) {
    const d = o(v, y, S, x, _, f);
    S.transmission > 0
      ? i.unshift(d)
      : S.transparent === !0
        ? r.unshift(d)
        : t.unshift(d);
  }
  function h(v, y) {
    t.length > 1 && t.sort(v || VH),
      i.length > 1 && i.sort(y || QT),
      r.length > 1 && r.sort(y || QT);
  }
  function p() {
    for (let v = e, y = n.length; v < y; v++) {
      const S = n[v];
      if (S.id === null) break;
      (S.id = null),
        (S.object = null),
        (S.geometry = null),
        (S.material = null),
        (S.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: u,
    finish: p,
    sort: h,
  };
}
function GH() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new ZT()), n.set(i, [o]))
        : r >= s.length
          ? ((o = new ZT()), s.push(o))
          : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function WH() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new B(), color: new Qe() };
          break;
        case "SpotLight":
          t = {
            position: new B(),
            direction: new B(),
            color: new Qe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new B(), color: new Qe(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new B(), skyColor: new Qe(), groundColor: new Qe() };
          break;
        case "RectAreaLight":
          t = {
            color: new Qe(),
            position: new B(),
            halfWidth: new B(),
            halfHeight: new B(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function jH() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Me(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Me(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Me(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let XH = 0;
function qH(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function $H(n, e) {
  const t = new WH(),
    i = jH(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let p = 0; p < 9; p++) r.probe.push(new B());
  const s = new B(),
    o = new _t(),
    a = new _t();
  function u(p, v) {
    let y = 0,
      S = 0,
      x = 0;
    for (let Q = 0; Q < 9; Q++) r.probe[Q].set(0, 0, 0);
    let _ = 0,
      f = 0,
      d = 0,
      m = 0,
      g = 0,
      w = 0,
      T = 0,
      C = 0,
      A = 0,
      L = 0,
      N = 0;
    p.sort(qH);
    const P = v === !0 ? Math.PI : 1;
    for (let Q = 0, ue = p.length; Q < ue; Q++) {
      const F = p[Q],
        X = F.color,
        G = F.intensity,
        ne = F.distance,
        k = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
      if (F.isAmbientLight)
        (y += X.r * G * P), (S += X.g * G * P), (x += X.b * G * P);
      else if (F.isLightProbe) {
        for (let W = 0; W < 9; W++)
          r.probe[W].addScaledVector(F.sh.coefficients[W], G);
        N++;
      } else if (F.isDirectionalLight) {
        const W = t.get(F);
        if (
          (W.color.copy(F.color).multiplyScalar(F.intensity * P), F.castShadow)
        ) {
          const H = F.shadow,
            ee = i.get(F);
          (ee.shadowBias = H.bias),
            (ee.shadowNormalBias = H.normalBias),
            (ee.shadowRadius = H.radius),
            (ee.shadowMapSize = H.mapSize),
            (r.directionalShadow[_] = ee),
            (r.directionalShadowMap[_] = k),
            (r.directionalShadowMatrix[_] = F.shadow.matrix),
            w++;
        }
        (r.directional[_] = W), _++;
      } else if (F.isSpotLight) {
        const W = t.get(F);
        W.position.setFromMatrixPosition(F.matrixWorld),
          W.color.copy(X).multiplyScalar(G * P),
          (W.distance = ne),
          (W.coneCos = Math.cos(F.angle)),
          (W.penumbraCos = Math.cos(F.angle * (1 - F.penumbra))),
          (W.decay = F.decay),
          (r.spot[d] = W);
        const H = F.shadow;
        if (
          (F.map &&
            ((r.spotLightMap[A] = F.map),
            A++,
            H.updateMatrices(F),
            F.castShadow && L++),
          (r.spotLightMatrix[d] = H.matrix),
          F.castShadow)
        ) {
          const ee = i.get(F);
          (ee.shadowBias = H.bias),
            (ee.shadowNormalBias = H.normalBias),
            (ee.shadowRadius = H.radius),
            (ee.shadowMapSize = H.mapSize),
            (r.spotShadow[d] = ee),
            (r.spotShadowMap[d] = k),
            C++;
        }
        d++;
      } else if (F.isRectAreaLight) {
        const W = t.get(F);
        W.color.copy(X).multiplyScalar(G),
          W.halfWidth.set(F.width * 0.5, 0, 0),
          W.halfHeight.set(0, F.height * 0.5, 0),
          (r.rectArea[m] = W),
          m++;
      } else if (F.isPointLight) {
        const W = t.get(F);
        if (
          (W.color.copy(F.color).multiplyScalar(F.intensity * P),
          (W.distance = F.distance),
          (W.decay = F.decay),
          F.castShadow)
        ) {
          const H = F.shadow,
            ee = i.get(F);
          (ee.shadowBias = H.bias),
            (ee.shadowNormalBias = H.normalBias),
            (ee.shadowRadius = H.radius),
            (ee.shadowMapSize = H.mapSize),
            (ee.shadowCameraNear = H.camera.near),
            (ee.shadowCameraFar = H.camera.far),
            (r.pointShadow[f] = ee),
            (r.pointShadowMap[f] = k),
            (r.pointShadowMatrix[f] = F.shadow.matrix),
            T++;
        }
        (r.point[f] = W), f++;
      } else if (F.isHemisphereLight) {
        const W = t.get(F);
        W.skyColor.copy(F.color).multiplyScalar(G * P),
          W.groundColor.copy(F.groundColor).multiplyScalar(G * P),
          (r.hemi[g] = W),
          g++;
      }
    }
    m > 0 &&
      (e.isWebGL2
        ? n.has("OES_texture_float_linear") === !0
          ? ((r.rectAreaLTC1 = He.LTC_FLOAT_1),
            (r.rectAreaLTC2 = He.LTC_FLOAT_2))
          : ((r.rectAreaLTC1 = He.LTC_HALF_1), (r.rectAreaLTC2 = He.LTC_HALF_2))
        : n.has("OES_texture_float_linear") === !0
          ? ((r.rectAreaLTC1 = He.LTC_FLOAT_1),
            (r.rectAreaLTC2 = He.LTC_FLOAT_2))
          : n.has("OES_texture_half_float_linear") === !0
            ? ((r.rectAreaLTC1 = He.LTC_HALF_1),
              (r.rectAreaLTC2 = He.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
              )),
      (r.ambient[0] = y),
      (r.ambient[1] = S),
      (r.ambient[2] = x);
    const I = r.hash;
    (I.directionalLength !== _ ||
      I.pointLength !== f ||
      I.spotLength !== d ||
      I.rectAreaLength !== m ||
      I.hemiLength !== g ||
      I.numDirectionalShadows !== w ||
      I.numPointShadows !== T ||
      I.numSpotShadows !== C ||
      I.numSpotMaps !== A ||
      I.numLightProbes !== N) &&
      ((r.directional.length = _),
      (r.spot.length = d),
      (r.rectArea.length = m),
      (r.point.length = f),
      (r.hemi.length = g),
      (r.directionalShadow.length = w),
      (r.directionalShadowMap.length = w),
      (r.pointShadow.length = T),
      (r.pointShadowMap.length = T),
      (r.spotShadow.length = C),
      (r.spotShadowMap.length = C),
      (r.directionalShadowMatrix.length = w),
      (r.pointShadowMatrix.length = T),
      (r.spotLightMatrix.length = C + A - L),
      (r.spotLightMap.length = A),
      (r.numSpotLightShadowsWithMaps = L),
      (r.numLightProbes = N),
      (I.directionalLength = _),
      (I.pointLength = f),
      (I.spotLength = d),
      (I.rectAreaLength = m),
      (I.hemiLength = g),
      (I.numDirectionalShadows = w),
      (I.numPointShadows = T),
      (I.numSpotShadows = C),
      (I.numSpotMaps = A),
      (I.numLightProbes = N),
      (r.version = XH++));
  }
  function h(p, v) {
    let y = 0,
      S = 0,
      x = 0,
      _ = 0,
      f = 0;
    const d = v.matrixWorldInverse;
    for (let m = 0, g = p.length; m < g; m++) {
      const w = p[m];
      if (w.isDirectionalLight) {
        const T = r.directional[y];
        T.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(d),
          y++;
      } else if (w.isSpotLight) {
        const T = r.spot[x];
        T.position.setFromMatrixPosition(w.matrixWorld),
          T.position.applyMatrix4(d),
          T.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(d),
          x++;
      } else if (w.isRectAreaLight) {
        const T = r.rectArea[_];
        T.position.setFromMatrixPosition(w.matrixWorld),
          T.position.applyMatrix4(d),
          a.identity(),
          o.copy(w.matrixWorld),
          o.premultiply(d),
          a.extractRotation(o),
          T.halfWidth.set(w.width * 0.5, 0, 0),
          T.halfHeight.set(0, w.height * 0.5, 0),
          T.halfWidth.applyMatrix4(a),
          T.halfHeight.applyMatrix4(a),
          _++;
      } else if (w.isPointLight) {
        const T = r.point[S];
        T.position.setFromMatrixPosition(w.matrixWorld),
          T.position.applyMatrix4(d),
          S++;
      } else if (w.isHemisphereLight) {
        const T = r.hemi[f];
        T.direction.setFromMatrixPosition(w.matrixWorld),
          T.direction.transformDirection(d),
          f++;
      }
    }
  }
  return { setup: u, setupView: h, state: r };
}
function JT(n, e) {
  const t = new $H(n, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function o(v) {
    i.push(v);
  }
  function a(v) {
    r.push(v);
  }
  function u(v) {
    t.setup(i, v);
  }
  function h(v) {
    t.setupView(i, v);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: u,
    setupLightsView: h,
    pushLight: o,
    pushShadow: a,
  };
}
function YH(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let u;
    return (
      a === void 0
        ? ((u = new JT(n, e)), t.set(s, [u]))
        : o >= a.length
          ? ((u = new JT(n, e)), a.push(u))
          : (u = a[o]),
      u
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class zw extends ci {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = iR),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Hw extends ci {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const KH = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  QH = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function ZH(n, e, t) {
  let i = new wf();
  const r = new Me(),
    s = new Me(),
    o = new rn(),
    a = new zw({ depthPacking: rR }),
    u = new Hw(),
    h = {},
    p = t.maxTextureSize,
    v = { [go]: Ui, [Ui]: go, [bs]: bs },
    y = new ls({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Me() },
        radius: { value: 4 },
      },
      vertexShader: KH,
      fragmentShader: QH,
    }),
    S = y.clone();
  S.defines.HORIZONTAL_PASS = 1;
  const x = new Rt();
  x.setAttribute(
    "position",
    new Jt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  );
  const _ = new Bn(x, y),
    f = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = hv);
  let d = this.type;
  this.render = function (C, A, L) {
    if (
      f.enabled === !1 ||
      (f.autoUpdate === !1 && f.needsUpdate === !1) ||
      C.length === 0
    )
      return;
    const N = n.getRenderTarget(),
      P = n.getActiveCubeFace(),
      I = n.getActiveMipmapLevel(),
      Q = n.state;
    Q.setBlending(uo),
      Q.buffers.color.setClear(1, 1, 1, 1),
      Q.buffers.depth.setTest(!0),
      Q.setScissorTest(!1);
    const ue = d !== Jr && this.type === Jr,
      F = d === Jr && this.type !== Jr;
    for (let X = 0, G = C.length; X < G; X++) {
      const ne = C[X],
        k = ne.shadow;
      if (k === void 0) {
        console.warn("THREE.WebGLShadowMap:", ne, "has no shadow.");
        continue;
      }
      if (k.autoUpdate === !1 && k.needsUpdate === !1) continue;
      r.copy(k.mapSize);
      const W = k.getFrameExtents();
      if (
        (r.multiply(W),
        s.copy(k.mapSize),
        (r.x > p || r.y > p) &&
          (r.x > p &&
            ((s.x = Math.floor(p / W.x)),
            (r.x = s.x * W.x),
            (k.mapSize.x = s.x)),
          r.y > p &&
            ((s.y = Math.floor(p / W.y)),
            (r.y = s.y * W.y),
            (k.mapSize.y = s.y))),
        k.map === null || ue === !0 || F === !0)
      ) {
        const ee = this.type !== Jr ? { minFilter: In, magFilter: In } : {};
        k.map !== null && k.map.dispose(),
          (k.map = new as(r.x, r.y, ee)),
          (k.map.texture.name = ne.name + ".shadowMap"),
          k.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(k.map), n.clear();
      const H = k.getViewportCount();
      for (let ee = 0; ee < H; ee++) {
        const ae = k.getViewport(ee);
        o.set(s.x * ae.x, s.y * ae.y, s.x * ae.z, s.y * ae.w),
          Q.viewport(o),
          k.updateMatrices(ne, ee),
          (i = k.getFrustum()),
          w(A, L, k.camera, ne, this.type);
      }
      k.isPointLightShadow !== !0 && this.type === Jr && m(k, L),
        (k.needsUpdate = !1);
    }
    (d = this.type), (f.needsUpdate = !1), n.setRenderTarget(N, P, I);
  };
  function m(C, A) {
    const L = e.update(_);
    y.defines.VSM_SAMPLES !== C.blurSamples &&
      ((y.defines.VSM_SAMPLES = C.blurSamples),
      (S.defines.VSM_SAMPLES = C.blurSamples),
      (y.needsUpdate = !0),
      (S.needsUpdate = !0)),
      C.mapPass === null && (C.mapPass = new as(r.x, r.y)),
      (y.uniforms.shadow_pass.value = C.map.texture),
      (y.uniforms.resolution.value = C.mapSize),
      (y.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.mapPass),
      n.clear(),
      n.renderBufferDirect(A, null, L, y, _, null),
      (S.uniforms.shadow_pass.value = C.mapPass.texture),
      (S.uniforms.resolution.value = C.mapSize),
      (S.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.map),
      n.clear(),
      n.renderBufferDirect(A, null, L, S, _, null);
  }
  function g(C, A, L, N) {
    let P = null;
    const I =
      L.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (I !== void 0) P = I;
    else if (
      ((P = L.isPointLight === !0 ? u : a),
      (n.localClippingEnabled &&
        A.clipShadows === !0 &&
        Array.isArray(A.clippingPlanes) &&
        A.clippingPlanes.length !== 0) ||
        (A.displacementMap && A.displacementScale !== 0) ||
        (A.alphaMap && A.alphaTest > 0) ||
        (A.map && A.alphaTest > 0))
    ) {
      const Q = P.uuid,
        ue = A.uuid;
      let F = h[Q];
      F === void 0 && ((F = {}), (h[Q] = F));
      let X = F[ue];
      X === void 0 &&
        ((X = P.clone()), (F[ue] = X), A.addEventListener("dispose", T)),
        (P = X);
    }
    if (
      ((P.visible = A.visible),
      (P.wireframe = A.wireframe),
      N === Jr
        ? (P.side = A.shadowSide !== null ? A.shadowSide : A.side)
        : (P.side = A.shadowSide !== null ? A.shadowSide : v[A.side]),
      (P.alphaMap = A.alphaMap),
      (P.alphaTest = A.alphaTest),
      (P.map = A.map),
      (P.clipShadows = A.clipShadows),
      (P.clippingPlanes = A.clippingPlanes),
      (P.clipIntersection = A.clipIntersection),
      (P.displacementMap = A.displacementMap),
      (P.displacementScale = A.displacementScale),
      (P.displacementBias = A.displacementBias),
      (P.wireframeLinewidth = A.wireframeLinewidth),
      (P.linewidth = A.linewidth),
      L.isPointLight === !0 && P.isMeshDistanceMaterial === !0)
    ) {
      const Q = n.properties.get(P);
      Q.light = L;
    }
    return P;
  }
  function w(C, A, L, N, P) {
    if (C.visible === !1) return;
    if (
      C.layers.test(A.layers) &&
      (C.isMesh || C.isLine || C.isPoints) &&
      (C.castShadow || (C.receiveShadow && P === Jr)) &&
      (!C.frustumCulled || i.intersectsObject(C))
    ) {
      C.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, C.matrixWorld);
      const ue = e.update(C),
        F = C.material;
      if (Array.isArray(F)) {
        const X = ue.groups;
        for (let G = 0, ne = X.length; G < ne; G++) {
          const k = X[G],
            W = F[k.materialIndex];
          if (W && W.visible) {
            const H = g(C, W, N, P);
            C.onBeforeShadow(n, C, A, L, ue, H, k),
              n.renderBufferDirect(L, null, ue, H, C, k),
              C.onAfterShadow(n, C, A, L, ue, H, k);
          }
        }
      } else if (F.visible) {
        const X = g(C, F, N, P);
        C.onBeforeShadow(n, C, A, L, ue, X, null),
          n.renderBufferDirect(L, null, ue, X, C, null),
          C.onAfterShadow(n, C, A, L, ue, X, null);
      }
    }
    const Q = C.children;
    for (let ue = 0, F = Q.length; ue < F; ue++) w(Q[ue], A, L, N, P);
  }
  function T(C) {
    C.target.removeEventListener("dispose", T);
    for (const L in h) {
      const N = h[L],
        P = C.target.uuid;
      P in N && (N[P].dispose(), delete N[P]);
    }
  }
}
function JH(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let j = !1;
    const Oe = new rn();
    let De = null;
    const ot = new rn(0, 0, 0, 0);
    return {
      setMask: function (ft) {
        De !== ft && !j && (n.colorMask(ft, ft, ft, ft), (De = ft));
      },
      setLocked: function (ft) {
        j = ft;
      },
      setClear: function (ft, Vt, Xt, mn, $n) {
        $n === !0 && ((ft *= mn), (Vt *= mn), (Xt *= mn)),
          Oe.set(ft, Vt, Xt, mn),
          ot.equals(Oe) === !1 && (n.clearColor(ft, Vt, Xt, mn), ot.copy(Oe));
      },
      reset: function () {
        (j = !1), (De = null), ot.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let j = !1,
      Oe = null,
      De = null,
      ot = null;
    return {
      setTest: function (ft) {
        ft ? ze(n.DEPTH_TEST) : tt(n.DEPTH_TEST);
      },
      setMask: function (ft) {
        Oe !== ft && !j && (n.depthMask(ft), (Oe = ft));
      },
      setFunc: function (ft) {
        if (De !== ft) {
          switch (ft) {
            case L2:
              n.depthFunc(n.NEVER);
              break;
            case I2:
              n.depthFunc(n.ALWAYS);
              break;
            case O2:
              n.depthFunc(n.LESS);
              break;
            case bh:
              n.depthFunc(n.LEQUAL);
              break;
            case N2:
              n.depthFunc(n.EQUAL);
              break;
            case D2:
              n.depthFunc(n.GEQUAL);
              break;
            case k2:
              n.depthFunc(n.GREATER);
              break;
            case U2:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          De = ft;
        }
      },
      setLocked: function (ft) {
        j = ft;
      },
      setClear: function (ft) {
        ot !== ft && (n.clearDepth(ft), (ot = ft));
      },
      reset: function () {
        (j = !1), (Oe = null), (De = null), (ot = null);
      },
    };
  }
  function o() {
    let j = !1,
      Oe = null,
      De = null,
      ot = null,
      ft = null,
      Vt = null,
      Xt = null,
      mn = null,
      $n = null;
    return {
      setTest: function (en) {
        j || (en ? ze(n.STENCIL_TEST) : tt(n.STENCIL_TEST));
      },
      setMask: function (en) {
        Oe !== en && !j && (n.stencilMask(en), (Oe = en));
      },
      setFunc: function (en, zn, Ci) {
        (De !== en || ot !== zn || ft !== Ci) &&
          (n.stencilFunc(en, zn, Ci), (De = en), (ot = zn), (ft = Ci));
      },
      setOp: function (en, zn, Ci) {
        (Vt !== en || Xt !== zn || mn !== Ci) &&
          (n.stencilOp(en, zn, Ci), (Vt = en), (Xt = zn), (mn = Ci));
      },
      setLocked: function (en) {
        j = en;
      },
      setClear: function (en) {
        $n !== en && (n.clearStencil(en), ($n = en));
      },
      reset: function () {
        (j = !1),
          (Oe = null),
          (De = null),
          (ot = null),
          (ft = null),
          (Vt = null),
          (Xt = null),
          (mn = null),
          ($n = null);
      },
    };
  }
  const a = new r(),
    u = new s(),
    h = new o(),
    p = new WeakMap(),
    v = new WeakMap();
  let y = {},
    S = {},
    x = new WeakMap(),
    _ = [],
    f = null,
    d = !1,
    m = null,
    g = null,
    w = null,
    T = null,
    C = null,
    A = null,
    L = null,
    N = new Qe(0, 0, 0),
    P = 0,
    I = !1,
    Q = null,
    ue = null,
    F = null,
    X = null,
    G = null;
  const ne = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let k = !1,
    W = 0;
  const H = n.getParameter(n.VERSION);
  H.indexOf("WebGL") !== -1
    ? ((W = parseFloat(/^WebGL (\d)/.exec(H)[1])), (k = W >= 1))
    : H.indexOf("OpenGL ES") !== -1 &&
      ((W = parseFloat(/^OpenGL ES (\d)/.exec(H)[1])), (k = W >= 2));
  let ee = null,
    ae = {};
  const xe = n.getParameter(n.SCISSOR_BOX),
    te = n.getParameter(n.VIEWPORT),
    de = new rn().fromArray(xe),
    ye = new rn().fromArray(te);
  function Ce(j, Oe, De, ot) {
    const ft = new Uint8Array(4),
      Vt = n.createTexture();
    n.bindTexture(j, Vt),
      n.texParameteri(j, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(j, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Xt = 0; Xt < De; Xt++)
      i && (j === n.TEXTURE_3D || j === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(Oe, 0, n.RGBA, 1, 1, ot, 0, n.RGBA, n.UNSIGNED_BYTE, ft)
        : n.texImage2D(
            Oe + Xt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            ft,
          );
    return Vt;
  }
  const Ze = {};
  (Ze[n.TEXTURE_2D] = Ce(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Ze[n.TEXTURE_CUBE_MAP] = Ce(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    i &&
      ((Ze[n.TEXTURE_2D_ARRAY] = Ce(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1,
      )),
      (Ze[n.TEXTURE_3D] = Ce(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    u.setClear(1),
    h.setClear(0),
    ze(n.DEPTH_TEST),
    u.setFunc(bh),
    We(!1),
    U(Tx),
    ze(n.CULL_FACE),
    Se(uo);
  function ze(j) {
    y[j] !== !0 && (n.enable(j), (y[j] = !0));
  }
  function tt(j) {
    y[j] !== !1 && (n.disable(j), (y[j] = !1));
  }
  function Ge(j, Oe) {
    return S[j] !== Oe
      ? (n.bindFramebuffer(j, Oe),
        (S[j] = Oe),
        i &&
          (j === n.DRAW_FRAMEBUFFER && (S[n.FRAMEBUFFER] = Oe),
          j === n.FRAMEBUFFER && (S[n.DRAW_FRAMEBUFFER] = Oe)),
        !0)
      : !1;
  }
  function V(j, Oe) {
    let De = _,
      ot = !1;
    if (j)
      if (
        ((De = x.get(Oe)),
        De === void 0 && ((De = []), x.set(Oe, De)),
        j.isWebGLMultipleRenderTargets)
      ) {
        const ft = j.texture;
        if (De.length !== ft.length || De[0] !== n.COLOR_ATTACHMENT0) {
          for (let Vt = 0, Xt = ft.length; Vt < Xt; Vt++)
            De[Vt] = n.COLOR_ATTACHMENT0 + Vt;
          (De.length = ft.length), (ot = !0);
        }
      } else
        De[0] !== n.COLOR_ATTACHMENT0 &&
          ((De[0] = n.COLOR_ATTACHMENT0), (ot = !0));
    else De[0] !== n.BACK && ((De[0] = n.BACK), (ot = !0));
    ot &&
      (t.isWebGL2
        ? n.drawBuffers(De)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(De));
  }
  function be(j) {
    return f !== j ? (n.useProgram(j), (f = j), !0) : !1;
  }
  const ge = {
    [Jo]: n.FUNC_ADD,
    [g2]: n.FUNC_SUBTRACT,
    [v2]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (i) (ge[Px] = n.MIN), (ge[Rx] = n.MAX);
  else {
    const j = e.get("EXT_blend_minmax");
    j !== null && ((ge[Px] = j.MIN_EXT), (ge[Rx] = j.MAX_EXT));
  }
  const Le = {
    [y2]: n.ZERO,
    [_2]: n.ONE,
    [x2]: n.SRC_COLOR,
    [Dg]: n.SRC_ALPHA,
    [C2]: n.SRC_ALPHA_SATURATE,
    [E2]: n.DST_COLOR,
    [w2]: n.DST_ALPHA,
    [S2]: n.ONE_MINUS_SRC_COLOR,
    [kg]: n.ONE_MINUS_SRC_ALPHA,
    [T2]: n.ONE_MINUS_DST_COLOR,
    [M2]: n.ONE_MINUS_DST_ALPHA,
    [b2]: n.CONSTANT_COLOR,
    [A2]: n.ONE_MINUS_CONSTANT_COLOR,
    [P2]: n.CONSTANT_ALPHA,
    [R2]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function Se(j, Oe, De, ot, ft, Vt, Xt, mn, $n, en) {
    if (j === uo) {
      d === !0 && (tt(n.BLEND), (d = !1));
      return;
    }
    if ((d === !1 && (ze(n.BLEND), (d = !0)), j !== m2)) {
      if (j !== m || en !== I) {
        if (
          ((g !== Jo || C !== Jo) &&
            (n.blendEquation(n.FUNC_ADD), (g = Jo), (C = Jo)),
          en)
        )
          switch (j) {
            case Pl:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case Cx:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case bx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Ax:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", j);
              break;
          }
        else
          switch (j) {
            case Pl:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case Cx:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case bx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Ax:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", j);
              break;
          }
        (w = null),
          (T = null),
          (A = null),
          (L = null),
          N.set(0, 0, 0),
          (P = 0),
          (m = j),
          (I = en);
      }
      return;
    }
    (ft = ft || Oe),
      (Vt = Vt || De),
      (Xt = Xt || ot),
      (Oe !== g || ft !== C) &&
        (n.blendEquationSeparate(ge[Oe], ge[ft]), (g = Oe), (C = ft)),
      (De !== w || ot !== T || Vt !== A || Xt !== L) &&
        (n.blendFuncSeparate(Le[De], Le[ot], Le[Vt], Le[Xt]),
        (w = De),
        (T = ot),
        (A = Vt),
        (L = Xt)),
      (mn.equals(N) === !1 || $n !== P) &&
        (n.blendColor(mn.r, mn.g, mn.b, $n), N.copy(mn), (P = $n)),
      (m = j),
      (I = !1);
  }
  function at(j, Oe) {
    j.side === bs ? tt(n.CULL_FACE) : ze(n.CULL_FACE);
    let De = j.side === Ui;
    Oe && (De = !De),
      We(De),
      j.blending === Pl && j.transparent === !1
        ? Se(uo)
        : Se(
            j.blending,
            j.blendEquation,
            j.blendSrc,
            j.blendDst,
            j.blendEquationAlpha,
            j.blendSrcAlpha,
            j.blendDstAlpha,
            j.blendColor,
            j.blendAlpha,
            j.premultipliedAlpha,
          ),
      u.setFunc(j.depthFunc),
      u.setTest(j.depthTest),
      u.setMask(j.depthWrite),
      a.setMask(j.colorWrite);
    const ot = j.stencilWrite;
    h.setTest(ot),
      ot &&
        (h.setMask(j.stencilWriteMask),
        h.setFunc(j.stencilFunc, j.stencilRef, j.stencilFuncMask),
        h.setOp(j.stencilFail, j.stencilZFail, j.stencilZPass)),
      le(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits),
      j.alphaToCoverage === !0
        ? ze(n.SAMPLE_ALPHA_TO_COVERAGE)
        : tt(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function We(j) {
    Q !== j && (j ? n.frontFace(n.CW) : n.frontFace(n.CCW), (Q = j));
  }
  function U(j) {
    j !== h2
      ? (ze(n.CULL_FACE),
        j !== ue &&
          (j === Tx
            ? n.cullFace(n.BACK)
            : j === f2
              ? n.cullFace(n.FRONT)
              : n.cullFace(n.FRONT_AND_BACK)))
      : tt(n.CULL_FACE),
      (ue = j);
  }
  function D(j) {
    j !== F && (k && n.lineWidth(j), (F = j));
  }
  function le(j, Oe, De) {
    j
      ? (ze(n.POLYGON_OFFSET_FILL),
        (X !== Oe || G !== De) && (n.polygonOffset(Oe, De), (X = Oe), (G = De)))
      : tt(n.POLYGON_OFFSET_FILL);
  }
  function Re(j) {
    j ? ze(n.SCISSOR_TEST) : tt(n.SCISSOR_TEST);
  }
  function Ee(j) {
    j === void 0 && (j = n.TEXTURE0 + ne - 1),
      ee !== j && (n.activeTexture(j), (ee = j));
  }
  function Te(j, Oe, De) {
    De === void 0 && (ee === null ? (De = n.TEXTURE0 + ne - 1) : (De = ee));
    let ot = ae[De];
    ot === void 0 && ((ot = { type: void 0, texture: void 0 }), (ae[De] = ot)),
      (ot.type !== j || ot.texture !== Oe) &&
        (ee !== De && (n.activeTexture(De), (ee = De)),
        n.bindTexture(j, Oe || Ze[j]),
        (ot.type = j),
        (ot.texture = Oe));
  }
  function rt() {
    const j = ae[ee];
    j !== void 0 &&
      j.type !== void 0 &&
      (n.bindTexture(j.type, null), (j.type = void 0), (j.texture = void 0));
  }
  function Be() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function Ke() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function mt() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function wt() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function Ae() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function Ht() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function Ct() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function yt() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function dt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function nt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (j) {
      console.error("THREE.WebGLState:", j);
    }
  }
  function Mt(j) {
    de.equals(j) === !1 && (n.scissor(j.x, j.y, j.z, j.w), de.copy(j));
  }
  function kt(j) {
    ye.equals(j) === !1 && (n.viewport(j.x, j.y, j.z, j.w), ye.copy(j));
  }
  function Qt(j, Oe) {
    let De = v.get(Oe);
    De === void 0 && ((De = new WeakMap()), v.set(Oe, De));
    let ot = De.get(j);
    ot === void 0 && ((ot = n.getUniformBlockIndex(Oe, j.name)), De.set(j, ot));
  }
  function Lt(j, Oe) {
    const ot = v.get(Oe).get(j);
    p.get(Oe) !== ot &&
      (n.uniformBlockBinding(Oe, ot, j.__bindingPointIndex), p.set(Oe, ot));
  }
  function Zt() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      i === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (y = {}),
      (ee = null),
      (ae = {}),
      (S = {}),
      (x = new WeakMap()),
      (_ = []),
      (f = null),
      (d = !1),
      (m = null),
      (g = null),
      (w = null),
      (T = null),
      (C = null),
      (A = null),
      (L = null),
      (N = new Qe(0, 0, 0)),
      (P = 0),
      (I = !1),
      (Q = null),
      (ue = null),
      (F = null),
      (X = null),
      (G = null),
      de.set(0, 0, n.canvas.width, n.canvas.height),
      ye.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      u.reset(),
      h.reset();
  }
  return {
    buffers: { color: a, depth: u, stencil: h },
    enable: ze,
    disable: tt,
    bindFramebuffer: Ge,
    drawBuffers: V,
    useProgram: be,
    setBlending: Se,
    setMaterial: at,
    setFlipSided: We,
    setCullFace: U,
    setLineWidth: D,
    setPolygonOffset: le,
    setScissorTest: Re,
    activeTexture: Ee,
    bindTexture: Te,
    unbindTexture: rt,
    compressedTexImage2D: Be,
    compressedTexImage3D: Ke,
    texImage2D: dt,
    texImage3D: nt,
    updateUBOMapping: Qt,
    uniformBlockBinding: Lt,
    texStorage2D: Ct,
    texStorage3D: yt,
    texSubImage2D: mt,
    texSubImage3D: wt,
    compressedTexSubImage2D: Ae,
    compressedTexSubImage3D: Ht,
    scissor: Mt,
    viewport: kt,
    reset: Zt,
  };
}
function e5(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    u = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    p = new WeakMap();
  let v;
  const y = new WeakMap();
  let S = !1;
  try {
    S =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(U, D) {
    return S ? new OffscreenCanvas(U, D) : zh("canvas");
  }
  function _(U, D, le, Re) {
    let Ee = 1;
    if (
      ((U.width > Re || U.height > Re) &&
        (Ee = Re / Math.max(U.width, U.height)),
      Ee < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && U instanceof ImageBitmap)
      ) {
        const Te = D ? Bg : Math.floor,
          rt = Te(Ee * U.width),
          Be = Te(Ee * U.height);
        v === void 0 && (v = x(rt, Be));
        const Ke = le ? x(rt, Be) : v;
        return (
          (Ke.width = rt),
          (Ke.height = Be),
          Ke.getContext("2d").drawImage(U, 0, 0, rt, Be),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              U.width +
              "x" +
              U.height +
              ") to (" +
              rt +
              "x" +
              Be +
              ").",
          ),
          Ke
        );
      } else
        return (
          "data" in U &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                U.width +
                "x" +
                U.height +
                ").",
            ),
          U
        );
    return U;
  }
  function f(U) {
    return oS(U.width) && oS(U.height);
  }
  function d(U) {
    return a
      ? !1
      : U.wrapS !== Mi ||
          U.wrapT !== Mi ||
          (U.minFilter !== In && U.minFilter !== xn);
  }
  function m(U, D) {
    return U.generateMipmaps && D && U.minFilter !== In && U.minFilter !== xn;
  }
  function g(U) {
    n.generateMipmap(U);
  }
  function w(U, D, le, Re, Ee = !1) {
    if (a === !1) return D;
    if (U !== null) {
      if (n[U] !== void 0) return n[U];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          U +
          "'",
      );
    }
    let Te = D;
    if (
      (D === n.RED &&
        (le === n.FLOAT && (Te = n.R32F),
        le === n.HALF_FLOAT && (Te = n.R16F),
        le === n.UNSIGNED_BYTE && (Te = n.R8)),
      D === n.RED_INTEGER &&
        (le === n.UNSIGNED_BYTE && (Te = n.R8UI),
        le === n.UNSIGNED_SHORT && (Te = n.R16UI),
        le === n.UNSIGNED_INT && (Te = n.R32UI),
        le === n.BYTE && (Te = n.R8I),
        le === n.SHORT && (Te = n.R16I),
        le === n.INT && (Te = n.R32I)),
      D === n.RG &&
        (le === n.FLOAT && (Te = n.RG32F),
        le === n.HALF_FLOAT && (Te = n.RG16F),
        le === n.UNSIGNED_BYTE && (Te = n.RG8)),
      D === n.RGBA)
    ) {
      const rt = Ee ? Dh : nn.getTransfer(Re);
      le === n.FLOAT && (Te = n.RGBA32F),
        le === n.HALF_FLOAT && (Te = n.RGBA16F),
        le === n.UNSIGNED_BYTE && (Te = rt === un ? n.SRGB8_ALPHA8 : n.RGBA8),
        le === n.UNSIGNED_SHORT_4_4_4_4 && (Te = n.RGBA4),
        le === n.UNSIGNED_SHORT_5_5_5_1 && (Te = n.RGB5_A1);
    }
    return (
      (Te === n.R16F ||
        Te === n.R32F ||
        Te === n.RG16F ||
        Te === n.RG32F ||
        Te === n.RGBA16F ||
        Te === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Te
    );
  }
  function T(U, D, le) {
    return m(U, le) === !0 ||
      (U.isFramebufferTexture && U.minFilter !== In && U.minFilter !== xn)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : U.mipmaps !== void 0 && U.mipmaps.length > 0
        ? U.mipmaps.length
        : U.isCompressedTexture && Array.isArray(U.image)
          ? D.mipmaps.length
          : 1;
  }
  function C(U) {
    return U === In || U === Ug || U === ul ? n.NEAREST : n.LINEAR;
  }
  function A(U) {
    const D = U.target;
    D.removeEventListener("dispose", A), N(D), D.isVideoTexture && p.delete(D);
  }
  function L(U) {
    const D = U.target;
    D.removeEventListener("dispose", L), I(D);
  }
  function N(U) {
    const D = i.get(U);
    if (D.__webglInit === void 0) return;
    const le = U.source,
      Re = y.get(le);
    if (Re) {
      const Ee = Re[D.__cacheKey];
      Ee.usedTimes--,
        Ee.usedTimes === 0 && P(U),
        Object.keys(Re).length === 0 && y.delete(le);
    }
    i.remove(U);
  }
  function P(U) {
    const D = i.get(U);
    n.deleteTexture(D.__webglTexture);
    const le = U.source,
      Re = y.get(le);
    delete Re[D.__cacheKey], o.memory.textures--;
  }
  function I(U) {
    const D = U.texture,
      le = i.get(U),
      Re = i.get(D);
    if (
      (Re.__webglTexture !== void 0 &&
        (n.deleteTexture(Re.__webglTexture), o.memory.textures--),
      U.depthTexture && U.depthTexture.dispose(),
      U.isWebGLCubeRenderTarget)
    )
      for (let Ee = 0; Ee < 6; Ee++) {
        if (Array.isArray(le.__webglFramebuffer[Ee]))
          for (let Te = 0; Te < le.__webglFramebuffer[Ee].length; Te++)
            n.deleteFramebuffer(le.__webglFramebuffer[Ee][Te]);
        else n.deleteFramebuffer(le.__webglFramebuffer[Ee]);
        le.__webglDepthbuffer &&
          n.deleteRenderbuffer(le.__webglDepthbuffer[Ee]);
      }
    else {
      if (Array.isArray(le.__webglFramebuffer))
        for (let Ee = 0; Ee < le.__webglFramebuffer.length; Ee++)
          n.deleteFramebuffer(le.__webglFramebuffer[Ee]);
      else n.deleteFramebuffer(le.__webglFramebuffer);
      if (
        (le.__webglDepthbuffer && n.deleteRenderbuffer(le.__webglDepthbuffer),
        le.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(le.__webglMultisampledFramebuffer),
        le.__webglColorRenderbuffer)
      )
        for (let Ee = 0; Ee < le.__webglColorRenderbuffer.length; Ee++)
          le.__webglColorRenderbuffer[Ee] &&
            n.deleteRenderbuffer(le.__webglColorRenderbuffer[Ee]);
      le.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(le.__webglDepthRenderbuffer);
    }
    if (U.isWebGLMultipleRenderTargets)
      for (let Ee = 0, Te = D.length; Ee < Te; Ee++) {
        const rt = i.get(D[Ee]);
        rt.__webglTexture &&
          (n.deleteTexture(rt.__webglTexture), o.memory.textures--),
          i.remove(D[Ee]);
      }
    i.remove(D), i.remove(U);
  }
  let Q = 0;
  function ue() {
    Q = 0;
  }
  function F() {
    const U = Q;
    return (
      U >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            U +
            " texture units while this GPU supports only " +
            r.maxTextures,
        ),
      (Q += 1),
      U
    );
  }
  function X(U) {
    const D = [];
    return (
      D.push(U.wrapS),
      D.push(U.wrapT),
      D.push(U.wrapR || 0),
      D.push(U.magFilter),
      D.push(U.minFilter),
      D.push(U.anisotropy),
      D.push(U.internalFormat),
      D.push(U.format),
      D.push(U.type),
      D.push(U.generateMipmaps),
      D.push(U.premultiplyAlpha),
      D.push(U.flipY),
      D.push(U.unpackAlignment),
      D.push(U.colorSpace),
      D.join()
    );
  }
  function G(U, D) {
    const le = i.get(U);
    if (
      (U.isVideoTexture && at(U),
      U.isRenderTargetTexture === !1 &&
        U.version > 0 &&
        le.__version !== U.version)
    ) {
      const Re = U.image;
      if (Re === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      else if (Re.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      else {
        de(le, U, D);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, le.__webglTexture, n.TEXTURE0 + D);
  }
  function ne(U, D) {
    const le = i.get(U);
    if (U.version > 0 && le.__version !== U.version) {
      de(le, U, D);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, le.__webglTexture, n.TEXTURE0 + D);
  }
  function k(U, D) {
    const le = i.get(U);
    if (U.version > 0 && le.__version !== U.version) {
      de(le, U, D);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, le.__webglTexture, n.TEXTURE0 + D);
  }
  function W(U, D) {
    const le = i.get(U);
    if (U.version > 0 && le.__version !== U.version) {
      ye(le, U, D);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, le.__webglTexture, n.TEXTURE0 + D);
  }
  const H = { [Rh]: n.REPEAT, [Mi]: n.CLAMP_TO_EDGE, [Lh]: n.MIRRORED_REPEAT },
    ee = {
      [In]: n.NEAREST,
      [Ug]: n.NEAREST_MIPMAP_NEAREST,
      [ul]: n.NEAREST_MIPMAP_LINEAR,
      [xn]: n.LINEAR,
      [th]: n.LINEAR_MIPMAP_NEAREST,
      [As]: n.LINEAR_MIPMAP_LINEAR,
    },
    ae = {
      [oR]: n.NEVER,
      [hR]: n.ALWAYS,
      [aR]: n.LESS,
      [Iw]: n.LEQUAL,
      [lR]: n.EQUAL,
      [dR]: n.GEQUAL,
      [uR]: n.GREATER,
      [cR]: n.NOTEQUAL,
    };
  function xe(U, D, le) {
    if (
      (D.type === Br &&
        e.has("OES_texture_float_linear") === !1 &&
        (D.magFilter === xn ||
          D.magFilter === th ||
          D.magFilter === ul ||
          D.magFilter === As ||
          D.minFilter === xn ||
          D.minFilter === th ||
          D.minFilter === ul ||
          D.minFilter === As) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
        ),
      le
        ? (n.texParameteri(U, n.TEXTURE_WRAP_S, H[D.wrapS]),
          n.texParameteri(U, n.TEXTURE_WRAP_T, H[D.wrapT]),
          (U === n.TEXTURE_3D || U === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(U, n.TEXTURE_WRAP_R, H[D.wrapR]),
          n.texParameteri(U, n.TEXTURE_MAG_FILTER, ee[D.magFilter]),
          n.texParameteri(U, n.TEXTURE_MIN_FILTER, ee[D.minFilter]))
        : (n.texParameteri(U, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(U, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (U === n.TEXTURE_3D || U === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(U, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (D.wrapS !== Mi || D.wrapT !== Mi) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
            ),
          n.texParameteri(U, n.TEXTURE_MAG_FILTER, C(D.magFilter)),
          n.texParameteri(U, n.TEXTURE_MIN_FILTER, C(D.minFilter)),
          D.minFilter !== In &&
            D.minFilter !== xn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
            )),
      D.compareFunction &&
        (n.texParameteri(U, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(U, n.TEXTURE_COMPARE_FUNC, ae[D.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Re = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === In ||
        (D.minFilter !== ul && D.minFilter !== As) ||
        (D.type === Br && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          D.type === Uc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || i.get(D).__currentAnisotropy) &&
        (n.texParameterf(
          U,
          Re.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy()),
        ),
        (i.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function te(U, D) {
    let le = !1;
    U.__webglInit === void 0 &&
      ((U.__webglInit = !0), D.addEventListener("dispose", A));
    const Re = D.source;
    let Ee = y.get(Re);
    Ee === void 0 && ((Ee = {}), y.set(Re, Ee));
    const Te = X(D);
    if (Te !== U.__cacheKey) {
      Ee[Te] === void 0 &&
        ((Ee[Te] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (le = !0)),
        Ee[Te].usedTimes++;
      const rt = Ee[U.__cacheKey];
      rt !== void 0 &&
        (Ee[U.__cacheKey].usedTimes--, rt.usedTimes === 0 && P(D)),
        (U.__cacheKey = Te),
        (U.__webglTexture = Ee[Te].texture);
    }
    return le;
  }
  function de(U, D, le) {
    let Re = n.TEXTURE_2D;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) &&
      (Re = n.TEXTURE_2D_ARRAY),
      D.isData3DTexture && (Re = n.TEXTURE_3D);
    const Ee = te(U, D),
      Te = D.source;
    t.bindTexture(Re, U.__webglTexture, n.TEXTURE0 + le);
    const rt = i.get(Te);
    if (Te.version !== rt.__version || Ee === !0) {
      t.activeTexture(n.TEXTURE0 + le);
      const Be = nn.getPrimaries(nn.workingColorSpace),
        Ke = D.colorSpace === dr ? null : nn.getPrimaries(D.colorSpace),
        mt =
          D.colorSpace === dr || Be === Ke ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, mt);
      const wt = d(D) && f(D.image) === !1;
      let Ae = _(D.image, wt, !1, r.maxTextureSize);
      Ae = We(D, Ae);
      const Ht = f(Ae) || a,
        Ct = s.convert(D.format, D.colorSpace);
      let yt = s.convert(D.type),
        dt = w(D.internalFormat, Ct, yt, D.colorSpace, D.isVideoTexture);
      xe(Re, D, Ht);
      let nt;
      const Mt = D.mipmaps,
        kt = a && D.isVideoTexture !== !0 && dt !== Pw,
        Qt = rt.__version === void 0 || Ee === !0,
        Lt = Te.dataReady,
        Zt = T(D, Ae, Ht);
      if (D.isDepthTexture)
        (dt = n.DEPTH_COMPONENT),
          a
            ? D.type === Br
              ? (dt = n.DEPTH_COMPONENT32F)
              : D.type === so
                ? (dt = n.DEPTH_COMPONENT24)
                : D.type === ya
                  ? (dt = n.DEPTH24_STENCIL8)
                  : (dt = n.DEPTH_COMPONENT16)
            : D.type === Br &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2.",
              ),
          D.format === _a &&
            dt === n.DEPTH_COMPONENT &&
            D.type !== pv &&
            D.type !== so &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
            ),
            (D.type = so),
            (yt = s.convert(D.type))),
          D.format === Hl &&
            dt === n.DEPTH_COMPONENT &&
            ((dt = n.DEPTH_STENCIL),
            D.type !== ya &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
              ),
              (D.type = ya),
              (yt = s.convert(D.type)))),
          Qt &&
            (kt
              ? t.texStorage2D(n.TEXTURE_2D, 1, dt, Ae.width, Ae.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  dt,
                  Ae.width,
                  Ae.height,
                  0,
                  Ct,
                  yt,
                  null,
                ));
      else if (D.isDataTexture)
        if (Mt.length > 0 && Ht) {
          kt &&
            Qt &&
            t.texStorage2D(n.TEXTURE_2D, Zt, dt, Mt[0].width, Mt[0].height);
          for (let j = 0, Oe = Mt.length; j < Oe; j++)
            (nt = Mt[j]),
              kt
                ? Lt &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    j,
                    0,
                    0,
                    nt.width,
                    nt.height,
                    Ct,
                    yt,
                    nt.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    j,
                    dt,
                    nt.width,
                    nt.height,
                    0,
                    Ct,
                    yt,
                    nt.data,
                  );
          D.generateMipmaps = !1;
        } else
          kt
            ? (Qt && t.texStorage2D(n.TEXTURE_2D, Zt, dt, Ae.width, Ae.height),
              Lt &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ae.width,
                  Ae.height,
                  Ct,
                  yt,
                  Ae.data,
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                dt,
                Ae.width,
                Ae.height,
                0,
                Ct,
                yt,
                Ae.data,
              );
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          kt &&
            Qt &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Zt,
              dt,
              Mt[0].width,
              Mt[0].height,
              Ae.depth,
            );
          for (let j = 0, Oe = Mt.length; j < Oe; j++)
            (nt = Mt[j]),
              D.format !== Ni
                ? Ct !== null
                  ? kt
                    ? Lt &&
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        j,
                        0,
                        0,
                        0,
                        nt.width,
                        nt.height,
                        Ae.depth,
                        Ct,
                        nt.data,
                        0,
                        0,
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        j,
                        dt,
                        nt.width,
                        nt.height,
                        Ae.depth,
                        0,
                        nt.data,
                        0,
                        0,
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : kt
                  ? Lt &&
                    t.texSubImage3D(
                      n.TEXTURE_2D_ARRAY,
                      j,
                      0,
                      0,
                      0,
                      nt.width,
                      nt.height,
                      Ae.depth,
                      Ct,
                      yt,
                      nt.data,
                    )
                  : t.texImage3D(
                      n.TEXTURE_2D_ARRAY,
                      j,
                      dt,
                      nt.width,
                      nt.height,
                      Ae.depth,
                      0,
                      Ct,
                      yt,
                      nt.data,
                    );
        } else {
          kt &&
            Qt &&
            t.texStorage2D(n.TEXTURE_2D, Zt, dt, Mt[0].width, Mt[0].height);
          for (let j = 0, Oe = Mt.length; j < Oe; j++)
            (nt = Mt[j]),
              D.format !== Ni
                ? Ct !== null
                  ? kt
                    ? Lt &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        j,
                        0,
                        0,
                        nt.width,
                        nt.height,
                        Ct,
                        nt.data,
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        j,
                        dt,
                        nt.width,
                        nt.height,
                        0,
                        nt.data,
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : kt
                  ? Lt &&
                    t.texSubImage2D(
                      n.TEXTURE_2D,
                      j,
                      0,
                      0,
                      nt.width,
                      nt.height,
                      Ct,
                      yt,
                      nt.data,
                    )
                  : t.texImage2D(
                      n.TEXTURE_2D,
                      j,
                      dt,
                      nt.width,
                      nt.height,
                      0,
                      Ct,
                      yt,
                      nt.data,
                    );
        }
      else if (D.isDataArrayTexture)
        kt
          ? (Qt &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Zt,
                dt,
                Ae.width,
                Ae.height,
                Ae.depth,
              ),
            Lt &&
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ae.width,
                Ae.height,
                Ae.depth,
                Ct,
                yt,
                Ae.data,
              ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              dt,
              Ae.width,
              Ae.height,
              Ae.depth,
              0,
              Ct,
              yt,
              Ae.data,
            );
      else if (D.isData3DTexture)
        kt
          ? (Qt &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Zt,
                dt,
                Ae.width,
                Ae.height,
                Ae.depth,
              ),
            Lt &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ae.width,
                Ae.height,
                Ae.depth,
                Ct,
                yt,
                Ae.data,
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              dt,
              Ae.width,
              Ae.height,
              Ae.depth,
              0,
              Ct,
              yt,
              Ae.data,
            );
      else if (D.isFramebufferTexture) {
        if (Qt)
          if (kt) t.texStorage2D(n.TEXTURE_2D, Zt, dt, Ae.width, Ae.height);
          else {
            let j = Ae.width,
              Oe = Ae.height;
            for (let De = 0; De < Zt; De++)
              t.texImage2D(n.TEXTURE_2D, De, dt, j, Oe, 0, Ct, yt, null),
                (j >>= 1),
                (Oe >>= 1);
          }
      } else if (Mt.length > 0 && Ht) {
        kt &&
          Qt &&
          t.texStorage2D(n.TEXTURE_2D, Zt, dt, Mt[0].width, Mt[0].height);
        for (let j = 0, Oe = Mt.length; j < Oe; j++)
          (nt = Mt[j]),
            kt
              ? Lt && t.texSubImage2D(n.TEXTURE_2D, j, 0, 0, Ct, yt, nt)
              : t.texImage2D(n.TEXTURE_2D, j, dt, Ct, yt, nt);
        D.generateMipmaps = !1;
      } else
        kt
          ? (Qt && t.texStorage2D(n.TEXTURE_2D, Zt, dt, Ae.width, Ae.height),
            Lt && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ct, yt, Ae))
          : t.texImage2D(n.TEXTURE_2D, 0, dt, Ct, yt, Ae);
      m(D, Ht) && g(Re),
        (rt.__version = Te.version),
        D.onUpdate && D.onUpdate(D);
    }
    U.__version = D.version;
  }
  function ye(U, D, le) {
    if (D.image.length !== 6) return;
    const Re = te(U, D),
      Ee = D.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, U.__webglTexture, n.TEXTURE0 + le);
    const Te = i.get(Ee);
    if (Ee.version !== Te.__version || Re === !0) {
      t.activeTexture(n.TEXTURE0 + le);
      const rt = nn.getPrimaries(nn.workingColorSpace),
        Be = D.colorSpace === dr ? null : nn.getPrimaries(D.colorSpace),
        Ke =
          D.colorSpace === dr || rt === Be ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ke);
      const mt = D.isCompressedTexture || D.image[0].isCompressedTexture,
        wt = D.image[0] && D.image[0].isDataTexture,
        Ae = [];
      for (let j = 0; j < 6; j++)
        !mt && !wt
          ? (Ae[j] = _(D.image[j], !1, !0, r.maxCubemapSize))
          : (Ae[j] = wt ? D.image[j].image : D.image[j]),
          (Ae[j] = We(D, Ae[j]));
      const Ht = Ae[0],
        Ct = f(Ht) || a,
        yt = s.convert(D.format, D.colorSpace),
        dt = s.convert(D.type),
        nt = w(D.internalFormat, yt, dt, D.colorSpace),
        Mt = a && D.isVideoTexture !== !0,
        kt = Te.__version === void 0 || Re === !0,
        Qt = Ee.dataReady;
      let Lt = T(D, Ht, Ct);
      xe(n.TEXTURE_CUBE_MAP, D, Ct);
      let Zt;
      if (mt) {
        Mt &&
          kt &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Lt, nt, Ht.width, Ht.height);
        for (let j = 0; j < 6; j++) {
          Zt = Ae[j].mipmaps;
          for (let Oe = 0; Oe < Zt.length; Oe++) {
            const De = Zt[Oe];
            D.format !== Ni
              ? yt !== null
                ? Mt
                  ? Qt &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                      Oe,
                      0,
                      0,
                      De.width,
                      De.height,
                      yt,
                      De.data,
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                      Oe,
                      nt,
                      De.width,
                      De.height,
                      0,
                      De.data,
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                  )
              : Mt
                ? Qt &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe,
                    0,
                    0,
                    De.width,
                    De.height,
                    yt,
                    dt,
                    De.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe,
                    nt,
                    De.width,
                    De.height,
                    0,
                    yt,
                    dt,
                    De.data,
                  );
          }
        }
      } else {
        (Zt = D.mipmaps),
          Mt &&
            kt &&
            (Zt.length > 0 && Lt++,
            t.texStorage2D(
              n.TEXTURE_CUBE_MAP,
              Lt,
              nt,
              Ae[0].width,
              Ae[0].height,
            ));
        for (let j = 0; j < 6; j++)
          if (wt) {
            Mt
              ? Qt &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                  0,
                  0,
                  0,
                  Ae[j].width,
                  Ae[j].height,
                  yt,
                  dt,
                  Ae[j].data,
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                  0,
                  nt,
                  Ae[j].width,
                  Ae[j].height,
                  0,
                  yt,
                  dt,
                  Ae[j].data,
                );
            for (let Oe = 0; Oe < Zt.length; Oe++) {
              const ot = Zt[Oe].image[j].image;
              Mt
                ? Qt &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe + 1,
                    0,
                    0,
                    ot.width,
                    ot.height,
                    yt,
                    dt,
                    ot.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe + 1,
                    nt,
                    ot.width,
                    ot.height,
                    0,
                    yt,
                    dt,
                    ot.data,
                  );
            }
          } else {
            Mt
              ? Qt &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                  0,
                  0,
                  0,
                  yt,
                  dt,
                  Ae[j],
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                  0,
                  nt,
                  yt,
                  dt,
                  Ae[j],
                );
            for (let Oe = 0; Oe < Zt.length; Oe++) {
              const De = Zt[Oe];
              Mt
                ? Qt &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe + 1,
                    0,
                    0,
                    yt,
                    dt,
                    De.image[j],
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                    Oe + 1,
                    nt,
                    yt,
                    dt,
                    De.image[j],
                  );
            }
          }
      }
      m(D, Ct) && g(n.TEXTURE_CUBE_MAP),
        (Te.__version = Ee.version),
        D.onUpdate && D.onUpdate(D);
    }
    U.__version = D.version;
  }
  function Ce(U, D, le, Re, Ee, Te) {
    const rt = s.convert(le.format, le.colorSpace),
      Be = s.convert(le.type),
      Ke = w(le.internalFormat, rt, Be, le.colorSpace);
    if (!i.get(D).__hasExternalTextures) {
      const wt = Math.max(1, D.width >> Te),
        Ae = Math.max(1, D.height >> Te);
      Ee === n.TEXTURE_3D || Ee === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(Ee, Te, Ke, wt, Ae, D.depth, 0, rt, Be, null)
        : t.texImage2D(Ee, Te, Ke, wt, Ae, 0, rt, Be, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, U),
      Se(D)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            Re,
            Ee,
            i.get(le).__webglTexture,
            0,
            Le(D),
          )
        : (Ee === n.TEXTURE_2D ||
            (Ee >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ee <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            Re,
            Ee,
            i.get(le).__webglTexture,
            Te,
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ze(U, D, le) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, U), D.depthBuffer && !D.stencilBuffer)
    ) {
      let Re = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
      if (le || Se(D)) {
        const Ee = D.depthTexture;
        Ee &&
          Ee.isDepthTexture &&
          (Ee.type === Br
            ? (Re = n.DEPTH_COMPONENT32F)
            : Ee.type === so && (Re = n.DEPTH_COMPONENT24));
        const Te = Le(D);
        Se(D)
          ? u.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Te,
              Re,
              D.width,
              D.height,
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Te,
              Re,
              D.width,
              D.height,
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, Re, D.width, D.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        U,
      );
    } else if (D.depthBuffer && D.stencilBuffer) {
      const Re = Le(D);
      le && Se(D) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Re,
            n.DEPTH24_STENCIL8,
            D.width,
            D.height,
          )
        : Se(D)
          ? u.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Re,
              n.DEPTH24_STENCIL8,
              D.width,
              D.height,
            )
          : n.renderbufferStorage(
              n.RENDERBUFFER,
              n.DEPTH_STENCIL,
              D.width,
              D.height,
            ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          U,
        );
    } else {
      const Re =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let Ee = 0; Ee < Re.length; Ee++) {
        const Te = Re[Ee],
          rt = s.convert(Te.format, Te.colorSpace),
          Be = s.convert(Te.type),
          Ke = w(Te.internalFormat, rt, Be, Te.colorSpace),
          mt = Le(D);
        le && Se(D) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              mt,
              Ke,
              D.width,
              D.height,
            )
          : Se(D)
            ? u.renderbufferStorageMultisampleEXT(
                n.RENDERBUFFER,
                mt,
                Ke,
                D.width,
                D.height,
              )
            : n.renderbufferStorage(n.RENDERBUFFER, Ke, D.width, D.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ze(U, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, U),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    (!i.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      G(D.depthTexture, 0);
    const Re = i.get(D.depthTexture).__webglTexture,
      Ee = Le(D);
    if (D.depthTexture.format === _a)
      Se(D)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Re,
            0,
            Ee,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Re,
            0,
          );
    else if (D.depthTexture.format === Hl)
      Se(D)
        ? u.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Re,
            0,
            Ee,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Re,
            0,
          );
    else throw new Error("Unknown depthTexture format");
  }
  function tt(U) {
    const D = i.get(U),
      le = U.isWebGLCubeRenderTarget === !0;
    if (U.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (le)
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      ze(D.__webglFramebuffer, U);
    } else if (le) {
      D.__webglDepthbuffer = [];
      for (let Re = 0; Re < 6; Re++)
        t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer[Re]),
          (D.__webglDepthbuffer[Re] = n.createRenderbuffer()),
          Ze(D.__webglDepthbuffer[Re], U, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer),
        (D.__webglDepthbuffer = n.createRenderbuffer()),
        Ze(D.__webglDepthbuffer, U, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ge(U, D, le) {
    const Re = i.get(U);
    D !== void 0 &&
      Ce(
        Re.__webglFramebuffer,
        U,
        U.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0,
      ),
      le !== void 0 && tt(U);
  }
  function V(U) {
    const D = U.texture,
      le = i.get(U),
      Re = i.get(D);
    U.addEventListener("dispose", L),
      U.isWebGLMultipleRenderTargets !== !0 &&
        (Re.__webglTexture === void 0 &&
          (Re.__webglTexture = n.createTexture()),
        (Re.__version = D.version),
        o.memory.textures++);
    const Ee = U.isWebGLCubeRenderTarget === !0,
      Te = U.isWebGLMultipleRenderTargets === !0,
      rt = f(U) || a;
    if (Ee) {
      le.__webglFramebuffer = [];
      for (let Be = 0; Be < 6; Be++)
        if (a && D.mipmaps && D.mipmaps.length > 0) {
          le.__webglFramebuffer[Be] = [];
          for (let Ke = 0; Ke < D.mipmaps.length; Ke++)
            le.__webglFramebuffer[Be][Ke] = n.createFramebuffer();
        } else le.__webglFramebuffer[Be] = n.createFramebuffer();
    } else {
      if (a && D.mipmaps && D.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let Be = 0; Be < D.mipmaps.length; Be++)
          le.__webglFramebuffer[Be] = n.createFramebuffer();
      } else le.__webglFramebuffer = n.createFramebuffer();
      if (Te)
        if (r.drawBuffers) {
          const Be = U.texture;
          for (let Ke = 0, mt = Be.length; Ke < mt; Ke++) {
            const wt = i.get(Be[Ke]);
            wt.__webglTexture === void 0 &&
              ((wt.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
          );
      if (a && U.samples > 0 && Se(U) === !1) {
        const Be = Te ? D : [D];
        (le.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (le.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let Ke = 0; Ke < Be.length; Ke++) {
          const mt = Be[Ke];
          (le.__webglColorRenderbuffer[Ke] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, le.__webglColorRenderbuffer[Ke]);
          const wt = s.convert(mt.format, mt.colorSpace),
            Ae = s.convert(mt.type),
            Ht = w(
              mt.internalFormat,
              wt,
              Ae,
              mt.colorSpace,
              U.isXRRenderTarget === !0,
            ),
            Ct = Le(U);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Ct,
            Ht,
            U.width,
            U.height,
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Ke,
              n.RENDERBUFFER,
              le.__webglColorRenderbuffer[Ke],
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          U.depthBuffer &&
            ((le.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Ze(le.__webglDepthRenderbuffer, U, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Ee) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Re.__webglTexture),
        xe(n.TEXTURE_CUBE_MAP, D, rt);
      for (let Be = 0; Be < 6; Be++)
        if (a && D.mipmaps && D.mipmaps.length > 0)
          for (let Ke = 0; Ke < D.mipmaps.length; Ke++)
            Ce(
              le.__webglFramebuffer[Be][Ke],
              U,
              D,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
              Ke,
            );
        else
          Ce(
            le.__webglFramebuffer[Be],
            U,
            D,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
            0,
          );
      m(D, rt) && g(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Te) {
      const Be = U.texture;
      for (let Ke = 0, mt = Be.length; Ke < mt; Ke++) {
        const wt = Be[Ke],
          Ae = i.get(wt);
        t.bindTexture(n.TEXTURE_2D, Ae.__webglTexture),
          xe(n.TEXTURE_2D, wt, rt),
          Ce(
            le.__webglFramebuffer,
            U,
            wt,
            n.COLOR_ATTACHMENT0 + Ke,
            n.TEXTURE_2D,
            0,
          ),
          m(wt, rt) && g(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Be = n.TEXTURE_2D;
      if (
        ((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) &&
          (a
            ? (Be = U.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
              )),
        t.bindTexture(Be, Re.__webglTexture),
        xe(Be, D, rt),
        a && D.mipmaps && D.mipmaps.length > 0)
      )
        for (let Ke = 0; Ke < D.mipmaps.length; Ke++)
          Ce(le.__webglFramebuffer[Ke], U, D, n.COLOR_ATTACHMENT0, Be, Ke);
      else Ce(le.__webglFramebuffer, U, D, n.COLOR_ATTACHMENT0, Be, 0);
      m(D, rt) && g(Be), t.unbindTexture();
    }
    U.depthBuffer && tt(U);
  }
  function be(U) {
    const D = f(U) || a,
      le = U.isWebGLMultipleRenderTargets === !0 ? U.texture : [U.texture];
    for (let Re = 0, Ee = le.length; Re < Ee; Re++) {
      const Te = le[Re];
      if (m(Te, D)) {
        const rt = U.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          Be = i.get(Te).__webglTexture;
        t.bindTexture(rt, Be), g(rt), t.unbindTexture();
      }
    }
  }
  function ge(U) {
    if (a && U.samples > 0 && Se(U) === !1) {
      const D = U.isWebGLMultipleRenderTargets ? U.texture : [U.texture],
        le = U.width,
        Re = U.height;
      let Ee = n.COLOR_BUFFER_BIT;
      const Te = [],
        rt = U.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Be = i.get(U),
        Ke = U.isWebGLMultipleRenderTargets === !0;
      if (Ke)
        for (let mt = 0; mt < D.length; mt++)
          t.bindFramebuffer(n.FRAMEBUFFER, Be.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + mt,
              n.RENDERBUFFER,
              null,
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, Be.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + mt,
              n.TEXTURE_2D,
              null,
              0,
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Be.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Be.__webglFramebuffer);
      for (let mt = 0; mt < D.length; mt++) {
        Te.push(n.COLOR_ATTACHMENT0 + mt), U.depthBuffer && Te.push(rt);
        const wt =
          Be.__ignoreDepthValues !== void 0 ? Be.__ignoreDepthValues : !1;
        if (
          (wt === !1 &&
            (U.depthBuffer && (Ee |= n.DEPTH_BUFFER_BIT),
            U.stencilBuffer && (Ee |= n.STENCIL_BUFFER_BIT)),
          Ke &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Be.__webglColorRenderbuffer[mt],
            ),
          wt === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [rt]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [rt])),
          Ke)
        ) {
          const Ae = i.get(D[mt]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            Ae,
            0,
          );
        }
        n.blitFramebuffer(0, 0, le, Re, 0, 0, le, Re, Ee, n.NEAREST),
          h && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Te);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        Ke)
      )
        for (let mt = 0; mt < D.length; mt++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Be.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + mt,
              n.RENDERBUFFER,
              Be.__webglColorRenderbuffer[mt],
            );
          const wt = i.get(D[mt]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Be.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + mt,
              n.TEXTURE_2D,
              wt,
              0,
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Be.__webglMultisampledFramebuffer);
    }
  }
  function Le(U) {
    return Math.min(r.maxSamples, U.samples);
  }
  function Se(U) {
    const D = i.get(U);
    return (
      a &&
      U.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function at(U) {
    const D = o.render.frame;
    p.get(U) !== D && (p.set(U, D), U.update());
  }
  function We(U, D) {
    const le = U.colorSpace,
      Re = U.format,
      Ee = U.type;
    return (
      U.isCompressedTexture === !0 ||
        U.isVideoTexture === !0 ||
        U.format === Fg ||
        (le !== Ds &&
          le !== dr &&
          (nn.getTransfer(le) === un
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Re === Ni
                ? ((U.format = Fg),
                  (U.minFilter = xn),
                  (U.generateMipmaps = !1))
                : (D = Nw.sRGBToLinear(D))
              : (Re !== Ni || Ee !== Os) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                le,
              ))),
      D
    );
  }
  (this.allocateTextureUnit = F),
    (this.resetTextureUnits = ue),
    (this.setTexture2D = G),
    (this.setTexture2DArray = ne),
    (this.setTexture3D = k),
    (this.setTextureCube = W),
    (this.rebindTextures = Ge),
    (this.setupRenderTarget = V),
    (this.updateRenderTargetMipmap = be),
    (this.updateMultisampleRenderTarget = ge),
    (this.setupDepthRenderbuffer = tt),
    (this.setupFrameBufferTexture = Ce),
    (this.useMultisampledRTT = Se);
}
function bR(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = dr) {
    let a;
    const u = nn.getTransfer(o);
    if (s === Os) return n.UNSIGNED_BYTE;
    if (s === Ew) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === Tw) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === X2) return n.BYTE;
    if (s === q2) return n.SHORT;
    if (s === pv) return n.UNSIGNED_SHORT;
    if (s === Mw) return n.INT;
    if (s === so) return n.UNSIGNED_INT;
    if (s === Br) return n.FLOAT;
    if (s === Uc)
      return i
        ? n.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === $2) return n.ALPHA;
    if (s === Ni) return n.RGBA;
    if (s === Y2) return n.LUMINANCE;
    if (s === K2) return n.LUMINANCE_ALPHA;
    if (s === _a) return n.DEPTH_COMPONENT;
    if (s === Hl) return n.DEPTH_STENCIL;
    if (s === Fg)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === Q2) return n.RED;
    if (s === Cw) return n.RED_INTEGER;
    if (s === Z2) return n.RG;
    if (s === bw) return n.RG_INTEGER;
    if (s === Aw) return n.RGBA_INTEGER;
    if (s === Jm || s === eg || s === tg || s === ng)
      if (u === un)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === Jm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === eg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === tg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === ng) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === Jm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === eg) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === tg) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === ng) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Ix || s === Ox || s === Nx || s === Dx)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === Ix) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Ox) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Nx) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Dx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === Pw)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === kx || s === Ux)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === kx)
          return u === un ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Ux)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Fx ||
      s === Bx ||
      s === zx ||
      s === Hx ||
      s === Vx ||
      s === Gx ||
      s === Wx ||
      s === jx ||
      s === Xx ||
      s === qx ||
      s === $x ||
      s === Yx ||
      s === Kx ||
      s === Qx
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === Fx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Bx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === zx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Hx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Vx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === Gx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Wx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === jx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Xx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === qx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === $x)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Yx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === Kx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === Qx)
          return u === un
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === ig || s === Zx || s === Jx)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === ig)
          return u === un
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === Zx) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === Jx) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === J2 || s === eS || s === tS || s === nS)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === ig) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === eS) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === tS) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === nS) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ya
      ? i
        ? n.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
        ? n[s]
        : null;
  }
  return { convert: r };
}
class AR extends ei {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class nc extends Kt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const t5 = { type: "move" };
class W0 {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new nc()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new nc()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new B()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new B())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new nc()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new B()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new B())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      u = this._grip,
      h = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (h && e.hand) {
        o = !0;
        for (const _ of e.hand.values()) {
          const f = t.getJointPose(_, i),
            d = this._getHandJoint(h, _);
          f !== null &&
            (d.matrix.fromArray(f.transform.matrix),
            d.matrix.decompose(d.position, d.rotation, d.scale),
            (d.matrixWorldNeedsUpdate = !0),
            (d.jointRadius = f.radius)),
            (d.visible = f !== null);
        }
        const p = h.joints["index-finger-tip"],
          v = h.joints["thumb-tip"],
          y = p.position.distanceTo(v.position),
          S = 0.02,
          x = 0.005;
        h.inputState.pinching && y > S + x
          ? ((h.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !h.inputState.pinching &&
            y <= S - x &&
            ((h.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        u !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (u.matrix.fromArray(s.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            (u.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(s.linearVelocity))
              : (u.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(s.angularVelocity))
              : (u.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(t5)));
    }
    return (
      a !== null && (a.visible = r !== null),
      u !== null && (u.visible = s !== null),
      h !== null && (h.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new nc();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const n5 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  i5 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class r5 {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Mn(),
        s = e.properties.get(r);
      (s.__webglTexture = t.texture),
        (t.depthNear != i.depthNear || t.depthFar != i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r);
    }
  }
  render(e, t) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const i = t.cameras[0].viewport,
          r = new ls({
            extensions: { fragDepth: !0 },
            vertexShader: n5,
            fragmentShader: i5,
            uniforms: {
              depthColor: { value: this.texture },
              depthWidth: { value: i.z },
              depthHeight: { value: i.w },
            },
          });
        this.mesh = new Bn(new qc(20, 20), r);
      }
      e.render(this.mesh, t);
    }
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
}
class s5 extends xo {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      u = 1,
      h = null,
      p = null,
      v = null,
      y = null,
      S = null,
      x = null;
    const _ = new r5(),
      f = t.getContextAttributes();
    let d = null,
      m = null;
    const g = [],
      w = [],
      T = new Me();
    let C = null;
    const A = new ei();
    A.layers.enable(1), (A.viewport = new rn());
    const L = new ei();
    L.layers.enable(2), (L.viewport = new rn());
    const N = [A, L],
      P = new AR();
    P.layers.enable(1), P.layers.enable(2);
    let I = null,
      Q = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (te) {
        let de = g[te];
        return (
          de === void 0 && ((de = new W0()), (g[te] = de)),
          de.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (te) {
        let de = g[te];
        return (
          de === void 0 && ((de = new W0()), (g[te] = de)), de.getGripSpace()
        );
      }),
      (this.getHand = function (te) {
        let de = g[te];
        return (
          de === void 0 && ((de = new W0()), (g[te] = de)), de.getHandSpace()
        );
      });
    function ue(te) {
      const de = w.indexOf(te.inputSource);
      if (de === -1) return;
      const ye = g[de];
      ye !== void 0 &&
        (ye.update(te.inputSource, te.frame, h || o),
        ye.dispatchEvent({ type: te.type, data: te.inputSource }));
    }
    function F() {
      r.removeEventListener("select", ue),
        r.removeEventListener("selectstart", ue),
        r.removeEventListener("selectend", ue),
        r.removeEventListener("squeeze", ue),
        r.removeEventListener("squeezestart", ue),
        r.removeEventListener("squeezeend", ue),
        r.removeEventListener("end", F),
        r.removeEventListener("inputsourceschange", X);
      for (let te = 0; te < g.length; te++) {
        const de = w[te];
        de !== null && ((w[te] = null), g[te].disconnect(de));
      }
      (I = null),
        (Q = null),
        _.reset(),
        e.setRenderTarget(d),
        (S = null),
        (y = null),
        (v = null),
        (r = null),
        (m = null),
        xe.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(C),
        e.setSize(T.width, T.height, !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (te) {
      (s = te),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
          );
    }),
      (this.setReferenceSpaceType = function (te) {
        (a = te),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting.",
            );
      }),
      (this.getReferenceSpace = function () {
        return h || o;
      }),
      (this.setReferenceSpace = function (te) {
        h = te;
      }),
      (this.getBaseLayer = function () {
        return y !== null ? y : S;
      }),
      (this.getBinding = function () {
        return v;
      }),
      (this.getFrame = function () {
        return x;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (te) {
        if (((r = te), r !== null)) {
          if (
            ((d = e.getRenderTarget()),
            r.addEventListener("select", ue),
            r.addEventListener("selectstart", ue),
            r.addEventListener("selectend", ue),
            r.addEventListener("squeeze", ue),
            r.addEventListener("squeezestart", ue),
            r.addEventListener("squeezeend", ue),
            r.addEventListener("end", F),
            r.addEventListener("inputsourceschange", X),
            f.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (C = e.getPixelRatio()),
            e.getSize(T),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const de = {
              antialias: r.renderState.layers === void 0 ? f.antialias : !0,
              alpha: !0,
              depth: f.depth,
              stencil: f.stencil,
              framebufferScaleFactor: s,
            };
            (S = new XRWebGLLayer(r, t, de)),
              r.updateRenderState({ baseLayer: S }),
              e.setPixelRatio(1),
              e.setSize(S.framebufferWidth, S.framebufferHeight, !1),
              (m = new as(S.framebufferWidth, S.framebufferHeight, {
                format: Ni,
                type: Os,
                colorSpace: e.outputColorSpace,
                stencilBuffer: f.stencil,
              }));
          } else {
            let de = null,
              ye = null,
              Ce = null;
            f.depth &&
              ((Ce = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (de = f.stencil ? Hl : _a),
              (ye = f.stencil ? ya : so));
            const Ze = {
              colorFormat: t.RGBA8,
              depthFormat: Ce,
              scaleFactor: s,
            };
            (v = new XRWebGLBinding(r, t)),
              (y = v.createProjectionLayer(Ze)),
              r.updateRenderState({ layers: [y] }),
              e.setPixelRatio(1),
              e.setSize(y.textureWidth, y.textureHeight, !1),
              (m = new as(y.textureWidth, y.textureHeight, {
                format: Ni,
                type: Os,
                depthTexture: new Bw(
                  y.textureWidth,
                  y.textureHeight,
                  ye,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  de,
                ),
                stencilBuffer: f.stencil,
                colorSpace: e.outputColorSpace,
                samples: f.antialias ? 4 : 0,
              }));
            const ze = e.properties.get(m);
            ze.__ignoreDepthValues = y.ignoreDepthValues;
          }
          (m.isXRRenderTarget = !0),
            this.setFoveation(u),
            (h = null),
            (o = await r.requestReferenceSpace(a)),
            xe.setContext(r),
            xe.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function X(te) {
      for (let de = 0; de < te.removed.length; de++) {
        const ye = te.removed[de],
          Ce = w.indexOf(ye);
        Ce >= 0 && ((w[Ce] = null), g[Ce].disconnect(ye));
      }
      for (let de = 0; de < te.added.length; de++) {
        const ye = te.added[de];
        let Ce = w.indexOf(ye);
        if (Ce === -1) {
          for (let ze = 0; ze < g.length; ze++)
            if (ze >= w.length) {
              w.push(ye), (Ce = ze);
              break;
            } else if (w[ze] === null) {
              (w[ze] = ye), (Ce = ze);
              break;
            }
          if (Ce === -1) break;
        }
        const Ze = g[Ce];
        Ze && Ze.connect(ye);
      }
    }
    const G = new B(),
      ne = new B();
    function k(te, de, ye) {
      G.setFromMatrixPosition(de.matrixWorld),
        ne.setFromMatrixPosition(ye.matrixWorld);
      const Ce = G.distanceTo(ne),
        Ze = de.projectionMatrix.elements,
        ze = ye.projectionMatrix.elements,
        tt = Ze[14] / (Ze[10] - 1),
        Ge = Ze[14] / (Ze[10] + 1),
        V = (Ze[9] + 1) / Ze[5],
        be = (Ze[9] - 1) / Ze[5],
        ge = (Ze[8] - 1) / Ze[0],
        Le = (ze[8] + 1) / ze[0],
        Se = tt * ge,
        at = tt * Le,
        We = Ce / (-ge + Le),
        U = We * -ge;
      de.matrixWorld.decompose(te.position, te.quaternion, te.scale),
        te.translateX(U),
        te.translateZ(We),
        te.matrixWorld.compose(te.position, te.quaternion, te.scale),
        te.matrixWorldInverse.copy(te.matrixWorld).invert();
      const D = tt + We,
        le = Ge + We,
        Re = Se - U,
        Ee = at + (Ce - U),
        Te = ((V * Ge) / le) * D,
        rt = ((be * Ge) / le) * D;
      te.projectionMatrix.makePerspective(Re, Ee, Te, rt, D, le),
        te.projectionMatrixInverse.copy(te.projectionMatrix).invert();
    }
    function W(te, de) {
      de === null
        ? te.matrixWorld.copy(te.matrix)
        : te.matrixWorld.multiplyMatrices(de.matrixWorld, te.matrix),
        te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function (te) {
      if (r === null) return;
      _.texture !== null && ((te.near = _.depthNear), (te.far = _.depthFar)),
        (P.near = L.near = A.near = te.near),
        (P.far = L.far = A.far = te.far),
        (I !== P.near || Q !== P.far) &&
          (r.updateRenderState({ depthNear: P.near, depthFar: P.far }),
          (I = P.near),
          (Q = P.far),
          (A.near = I),
          (A.far = Q),
          (L.near = I),
          (L.far = Q),
          A.updateProjectionMatrix(),
          L.updateProjectionMatrix(),
          te.updateProjectionMatrix());
      const de = te.parent,
        ye = P.cameras;
      W(P, de);
      for (let Ce = 0; Ce < ye.length; Ce++) W(ye[Ce], de);
      ye.length === 2
        ? k(P, A, L)
        : P.projectionMatrix.copy(A.projectionMatrix),
        H(te, P, de);
    };
    function H(te, de, ye) {
      ye === null
        ? te.matrix.copy(de.matrixWorld)
        : (te.matrix.copy(ye.matrixWorld),
          te.matrix.invert(),
          te.matrix.multiply(de.matrixWorld)),
        te.matrix.decompose(te.position, te.quaternion, te.scale),
        te.updateMatrixWorld(!0),
        te.projectionMatrix.copy(de.projectionMatrix),
        te.projectionMatrixInverse.copy(de.projectionMatrixInverse),
        te.isPerspectiveCamera &&
          ((te.fov = Fc * 2 * Math.atan(1 / te.projectionMatrix.elements[5])),
          (te.zoom = 1));
    }
    (this.getCamera = function () {
      return P;
    }),
      (this.getFoveation = function () {
        if (!(y === null && S === null)) return u;
      }),
      (this.setFoveation = function (te) {
        (u = te),
          y !== null && (y.fixedFoveation = te),
          S !== null && S.fixedFoveation !== void 0 && (S.fixedFoveation = te);
      }),
      (this.hasDepthSensing = function () {
        return _.texture !== null;
      });
    let ee = null;
    function ae(te, de) {
      if (((p = de.getViewerPose(h || o)), (x = de), p !== null)) {
        const ye = p.views;
        S !== null &&
          (e.setRenderTargetFramebuffer(m, S.framebuffer),
          e.setRenderTarget(m));
        let Ce = !1;
        ye.length !== P.cameras.length && ((P.cameras.length = 0), (Ce = !0));
        for (let ze = 0; ze < ye.length; ze++) {
          const tt = ye[ze];
          let Ge = null;
          if (S !== null) Ge = S.getViewport(tt);
          else {
            const be = v.getViewSubImage(y, tt);
            (Ge = be.viewport),
              ze === 0 &&
                (e.setRenderTargetTextures(
                  m,
                  be.colorTexture,
                  y.ignoreDepthValues ? void 0 : be.depthStencilTexture,
                ),
                e.setRenderTarget(m));
          }
          let V = N[ze];
          V === void 0 &&
            ((V = new ei()),
            V.layers.enable(ze),
            (V.viewport = new rn()),
            (N[ze] = V)),
            V.matrix.fromArray(tt.transform.matrix),
            V.matrix.decompose(V.position, V.quaternion, V.scale),
            V.projectionMatrix.fromArray(tt.projectionMatrix),
            V.projectionMatrixInverse.copy(V.projectionMatrix).invert(),
            V.viewport.set(Ge.x, Ge.y, Ge.width, Ge.height),
            ze === 0 &&
              (P.matrix.copy(V.matrix),
              P.matrix.decompose(P.position, P.quaternion, P.scale)),
            Ce === !0 && P.cameras.push(V);
        }
        const Ze = r.enabledFeatures;
        if (Ze && Ze.includes("depth-sensing")) {
          const ze = v.getDepthInformation(ye[0]);
          ze && ze.isValid && ze.texture && _.init(e, ze, r.renderState);
        }
      }
      for (let ye = 0; ye < g.length; ye++) {
        const Ce = w[ye],
          Ze = g[ye];
        Ce !== null && Ze !== void 0 && Ze.update(Ce, de, h || o);
      }
      _.render(e, P),
        ee && ee(te, de),
        de.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: de }),
        (x = null);
    }
    const xe = new SR();
    xe.setAnimationLoop(ae),
      (this.setAnimationLoop = function (te) {
        ee = te;
      }),
      (this.dispose = function () {});
  }
}
function o5(n, e) {
  function t(f, d) {
    f.matrixAutoUpdate === !0 && f.updateMatrix(), d.value.copy(f.matrix);
  }
  function i(f, d) {
    d.color.getRGB(f.fogColor.value, vR(n)),
      d.isFog
        ? ((f.fogNear.value = d.near), (f.fogFar.value = d.far))
        : d.isFogExp2 && (f.fogDensity.value = d.density);
  }
  function r(f, d, m, g, w) {
    d.isMeshBasicMaterial || d.isMeshLambertMaterial
      ? s(f, d)
      : d.isMeshToonMaterial
        ? (s(f, d), v(f, d))
        : d.isMeshPhongMaterial
          ? (s(f, d), p(f, d))
          : d.isMeshStandardMaterial
            ? (s(f, d), y(f, d), d.isMeshPhysicalMaterial && S(f, d, w))
            : d.isMeshMatcapMaterial
              ? (s(f, d), x(f, d))
              : d.isMeshDepthMaterial
                ? s(f, d)
                : d.isMeshDistanceMaterial
                  ? (s(f, d), _(f, d))
                  : d.isMeshNormalMaterial
                    ? s(f, d)
                    : d.isLineBasicMaterial
                      ? (o(f, d), d.isLineDashedMaterial && a(f, d))
                      : d.isPointsMaterial
                        ? u(f, d, m, g)
                        : d.isSpriteMaterial
                          ? h(f, d)
                          : d.isShadowMaterial
                            ? (f.color.value.copy(d.color),
                              (f.opacity.value = d.opacity))
                            : d.isShaderMaterial && (d.uniformsNeedUpdate = !1);
  }
  function s(f, d) {
    (f.opacity.value = d.opacity),
      d.color && f.diffuse.value.copy(d.color),
      d.emissive &&
        f.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),
      d.map && ((f.map.value = d.map), t(d.map, f.mapTransform)),
      d.alphaMap &&
        ((f.alphaMap.value = d.alphaMap), t(d.alphaMap, f.alphaMapTransform)),
      d.bumpMap &&
        ((f.bumpMap.value = d.bumpMap),
        t(d.bumpMap, f.bumpMapTransform),
        (f.bumpScale.value = d.bumpScale),
        d.side === Ui && (f.bumpScale.value *= -1)),
      d.normalMap &&
        ((f.normalMap.value = d.normalMap),
        t(d.normalMap, f.normalMapTransform),
        f.normalScale.value.copy(d.normalScale),
        d.side === Ui && f.normalScale.value.negate()),
      d.displacementMap &&
        ((f.displacementMap.value = d.displacementMap),
        t(d.displacementMap, f.displacementMapTransform),
        (f.displacementScale.value = d.displacementScale),
        (f.displacementBias.value = d.displacementBias)),
      d.emissiveMap &&
        ((f.emissiveMap.value = d.emissiveMap),
        t(d.emissiveMap, f.emissiveMapTransform)),
      d.specularMap &&
        ((f.specularMap.value = d.specularMap),
        t(d.specularMap, f.specularMapTransform)),
      d.alphaTest > 0 && (f.alphaTest.value = d.alphaTest);
    const m = e.get(d).envMap;
    if (
      (m &&
        ((f.envMap.value = m),
        (f.flipEnvMap.value =
          m.isCubeTexture && m.isRenderTargetTexture === !1 ? -1 : 1),
        (f.reflectivity.value = d.reflectivity),
        (f.ior.value = d.ior),
        (f.refractionRatio.value = d.refractionRatio)),
      d.lightMap)
    ) {
      f.lightMap.value = d.lightMap;
      const g = n._useLegacyLights === !0 ? Math.PI : 1;
      (f.lightMapIntensity.value = d.lightMapIntensity * g),
        t(d.lightMap, f.lightMapTransform);
    }
    d.aoMap &&
      ((f.aoMap.value = d.aoMap),
      (f.aoMapIntensity.value = d.aoMapIntensity),
      t(d.aoMap, f.aoMapTransform));
  }
  function o(f, d) {
    f.diffuse.value.copy(d.color),
      (f.opacity.value = d.opacity),
      d.map && ((f.map.value = d.map), t(d.map, f.mapTransform));
  }
  function a(f, d) {
    (f.dashSize.value = d.dashSize),
      (f.totalSize.value = d.dashSize + d.gapSize),
      (f.scale.value = d.scale);
  }
  function u(f, d, m, g) {
    f.diffuse.value.copy(d.color),
      (f.opacity.value = d.opacity),
      (f.size.value = d.size * m),
      (f.scale.value = g * 0.5),
      d.map && ((f.map.value = d.map), t(d.map, f.uvTransform)),
      d.alphaMap &&
        ((f.alphaMap.value = d.alphaMap), t(d.alphaMap, f.alphaMapTransform)),
      d.alphaTest > 0 && (f.alphaTest.value = d.alphaTest);
  }
  function h(f, d) {
    f.diffuse.value.copy(d.color),
      (f.opacity.value = d.opacity),
      (f.rotation.value = d.rotation),
      d.map && ((f.map.value = d.map), t(d.map, f.mapTransform)),
      d.alphaMap &&
        ((f.alphaMap.value = d.alphaMap), t(d.alphaMap, f.alphaMapTransform)),
      d.alphaTest > 0 && (f.alphaTest.value = d.alphaTest);
  }
  function p(f, d) {
    f.specular.value.copy(d.specular),
      (f.shininess.value = Math.max(d.shininess, 1e-4));
  }
  function v(f, d) {
    d.gradientMap && (f.gradientMap.value = d.gradientMap);
  }
  function y(f, d) {
    (f.metalness.value = d.metalness),
      d.metalnessMap &&
        ((f.metalnessMap.value = d.metalnessMap),
        t(d.metalnessMap, f.metalnessMapTransform)),
      (f.roughness.value = d.roughness),
      d.roughnessMap &&
        ((f.roughnessMap.value = d.roughnessMap),
        t(d.roughnessMap, f.roughnessMapTransform)),
      e.get(d).envMap && (f.envMapIntensity.value = d.envMapIntensity);
  }
  function S(f, d, m) {
    (f.ior.value = d.ior),
      d.sheen > 0 &&
        (f.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),
        (f.sheenRoughness.value = d.sheenRoughness),
        d.sheenColorMap &&
          ((f.sheenColorMap.value = d.sheenColorMap),
          t(d.sheenColorMap, f.sheenColorMapTransform)),
        d.sheenRoughnessMap &&
          ((f.sheenRoughnessMap.value = d.sheenRoughnessMap),
          t(d.sheenRoughnessMap, f.sheenRoughnessMapTransform))),
      d.clearcoat > 0 &&
        ((f.clearcoat.value = d.clearcoat),
        (f.clearcoatRoughness.value = d.clearcoatRoughness),
        d.clearcoatMap &&
          ((f.clearcoatMap.value = d.clearcoatMap),
          t(d.clearcoatMap, f.clearcoatMapTransform)),
        d.clearcoatRoughnessMap &&
          ((f.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap),
          t(d.clearcoatRoughnessMap, f.clearcoatRoughnessMapTransform)),
        d.clearcoatNormalMap &&
          ((f.clearcoatNormalMap.value = d.clearcoatNormalMap),
          t(d.clearcoatNormalMap, f.clearcoatNormalMapTransform),
          f.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),
          d.side === Ui && f.clearcoatNormalScale.value.negate())),
      d.iridescence > 0 &&
        ((f.iridescence.value = d.iridescence),
        (f.iridescenceIOR.value = d.iridescenceIOR),
        (f.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0]),
        (f.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1]),
        d.iridescenceMap &&
          ((f.iridescenceMap.value = d.iridescenceMap),
          t(d.iridescenceMap, f.iridescenceMapTransform)),
        d.iridescenceThicknessMap &&
          ((f.iridescenceThicknessMap.value = d.iridescenceThicknessMap),
          t(d.iridescenceThicknessMap, f.iridescenceThicknessMapTransform))),
      d.transmission > 0 &&
        ((f.transmission.value = d.transmission),
        (f.transmissionSamplerMap.value = m.texture),
        f.transmissionSamplerSize.value.set(m.width, m.height),
        d.transmissionMap &&
          ((f.transmissionMap.value = d.transmissionMap),
          t(d.transmissionMap, f.transmissionMapTransform)),
        (f.thickness.value = d.thickness),
        d.thicknessMap &&
          ((f.thicknessMap.value = d.thicknessMap),
          t(d.thicknessMap, f.thicknessMapTransform)),
        (f.attenuationDistance.value = d.attenuationDistance),
        f.attenuationColor.value.copy(d.attenuationColor)),
      d.anisotropy > 0 &&
        (f.anisotropyVector.value.set(
          d.anisotropy * Math.cos(d.anisotropyRotation),
          d.anisotropy * Math.sin(d.anisotropyRotation),
        ),
        d.anisotropyMap &&
          ((f.anisotropyMap.value = d.anisotropyMap),
          t(d.anisotropyMap, f.anisotropyMapTransform))),
      (f.specularIntensity.value = d.specularIntensity),
      f.specularColor.value.copy(d.specularColor),
      d.specularColorMap &&
        ((f.specularColorMap.value = d.specularColorMap),
        t(d.specularColorMap, f.specularColorMapTransform)),
      d.specularIntensityMap &&
        ((f.specularIntensityMap.value = d.specularIntensityMap),
        t(d.specularIntensityMap, f.specularIntensityMapTransform));
  }
  function x(f, d) {
    d.matcap && (f.matcap.value = d.matcap);
  }
  function _(f, d) {
    const m = e.get(d).light;
    f.referencePosition.value.setFromMatrixPosition(m.matrixWorld),
      (f.nearDistance.value = m.shadow.camera.near),
      (f.farDistance.value = m.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function a5(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function u(m, g) {
    const w = g.program;
    i.uniformBlockBinding(m, w);
  }
  function h(m, g) {
    let w = r[m.id];
    w === void 0 &&
      (x(m), (w = p(m)), (r[m.id] = w), m.addEventListener("dispose", f));
    const T = g.program;
    i.updateUBOMapping(m, T);
    const C = e.render.frame;
    s[m.id] !== C && (y(m), (s[m.id] = C));
  }
  function p(m) {
    const g = v();
    m.__bindingPointIndex = g;
    const w = n.createBuffer(),
      T = m.__size,
      C = m.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, w),
      n.bufferData(n.UNIFORM_BUFFER, T, C),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, g, w),
      w
    );
  }
  function v() {
    for (let m = 0; m < a; m++) if (o.indexOf(m) === -1) return o.push(m), m;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
      ),
      0
    );
  }
  function y(m) {
    const g = r[m.id],
      w = m.uniforms,
      T = m.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, g);
    for (let C = 0, A = w.length; C < A; C++) {
      const L = Array.isArray(w[C]) ? w[C] : [w[C]];
      for (let N = 0, P = L.length; N < P; N++) {
        const I = L[N];
        if (S(I, C, N, T) === !0) {
          const Q = I.__offset,
            ue = Array.isArray(I.value) ? I.value : [I.value];
          let F = 0;
          for (let X = 0; X < ue.length; X++) {
            const G = ue[X],
              ne = _(G);
            typeof G == "number" || typeof G == "boolean"
              ? ((I.__data[0] = G),
                n.bufferSubData(n.UNIFORM_BUFFER, Q + F, I.__data))
              : G.isMatrix3
                ? ((I.__data[0] = G.elements[0]),
                  (I.__data[1] = G.elements[1]),
                  (I.__data[2] = G.elements[2]),
                  (I.__data[3] = 0),
                  (I.__data[4] = G.elements[3]),
                  (I.__data[5] = G.elements[4]),
                  (I.__data[6] = G.elements[5]),
                  (I.__data[7] = 0),
                  (I.__data[8] = G.elements[6]),
                  (I.__data[9] = G.elements[7]),
                  (I.__data[10] = G.elements[8]),
                  (I.__data[11] = 0))
                : (G.toArray(I.__data, F),
                  (F += ne.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, Q, I.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function S(m, g, w, T) {
    const C = m.value,
      A = g + "_" + w;
    if (T[A] === void 0)
      return (
        typeof C == "number" || typeof C == "boolean"
          ? (T[A] = C)
          : (T[A] = C.clone()),
        !0
      );
    {
      const L = T[A];
      if (typeof C == "number" || typeof C == "boolean") {
        if (L !== C) return (T[A] = C), !0;
      } else if (L.equals(C) === !1) return L.copy(C), !0;
    }
    return !1;
  }
  function x(m) {
    const g = m.uniforms;
    let w = 0;
    const T = 16;
    for (let A = 0, L = g.length; A < L; A++) {
      const N = Array.isArray(g[A]) ? g[A] : [g[A]];
      for (let P = 0, I = N.length; P < I; P++) {
        const Q = N[P],
          ue = Array.isArray(Q.value) ? Q.value : [Q.value];
        for (let F = 0, X = ue.length; F < X; F++) {
          const G = ue[F],
            ne = _(G),
            k = w % T;
          k !== 0 && T - k < ne.boundary && (w += T - k),
            (Q.__data = new Float32Array(
              ne.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (Q.__offset = w),
            (w += ne.storage);
        }
      }
    }
    const C = w % T;
    return C > 0 && (w += T - C), (m.__size = w), (m.__cache = {}), this;
  }
  function _(m) {
    const g = { boundary: 0, storage: 0 };
    return (
      typeof m == "number" || typeof m == "boolean"
        ? ((g.boundary = 4), (g.storage = 4))
        : m.isVector2
          ? ((g.boundary = 8), (g.storage = 8))
          : m.isVector3 || m.isColor
            ? ((g.boundary = 16), (g.storage = 12))
            : m.isVector4
              ? ((g.boundary = 16), (g.storage = 16))
              : m.isMatrix3
                ? ((g.boundary = 48), (g.storage = 48))
                : m.isMatrix4
                  ? ((g.boundary = 64), (g.storage = 64))
                  : m.isTexture
                    ? console.warn(
                        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Unsupported uniform value type.",
                        m,
                      ),
      g
    );
  }
  function f(m) {
    const g = m.target;
    g.removeEventListener("dispose", f);
    const w = o.indexOf(g.__bindingPointIndex);
    o.splice(w, 1), n.deleteBuffer(r[g.id]), delete r[g.id], delete s[g.id];
  }
  function d() {
    for (const m in r) n.deleteBuffer(r[m]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: u, update: h, dispose: d };
}
class Vw {
  constructor(e = {}) {
    const {
      canvas: t = pR(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: h = !1,
      powerPreference: p = "default",
      failIfMajorPerformanceCaveat: v = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let y;
    i !== null ? (y = i.getContextAttributes().alpha) : (y = o);
    const S = new Uint32Array(4),
      x = new Int32Array(4);
    let _ = null,
      f = null;
    const d = [],
      m = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Wn),
      (this._useLegacyLights = !1),
      (this.toneMapping = Is),
      (this.toneMappingExposure = 1);
    const g = this;
    let w = !1,
      T = 0,
      C = 0,
      A = null,
      L = -1,
      N = null;
    const P = new rn(),
      I = new rn();
    let Q = null;
    const ue = new Qe(0);
    let F = 0,
      X = t.width,
      G = t.height,
      ne = 1,
      k = null,
      W = null;
    const H = new rn(0, 0, X, G),
      ee = new rn(0, 0, X, G);
    let ae = !1;
    const xe = new wf();
    let te = !1,
      de = !1,
      ye = null;
    const Ce = new _t(),
      Ze = new Me(),
      ze = new B(),
      tt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ge() {
      return A === null ? ne : 1;
    }
    let V = i;
    function be(O, q) {
      for (let $ = 0; $ < O.length; $++) {
        const Y = O[$],
          J = t.getContext(Y, q);
        if (J !== null) return J;
      }
      return null;
    }
    try {
      const O = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: u,
        preserveDrawingBuffer: h,
        powerPreference: p,
        failIfMajorPerformanceCaveat: v,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${gf}`),
        t.addEventListener("webglcontextlost", Zt, !1),
        t.addEventListener("webglcontextrestored", j, !1),
        t.addEventListener("webglcontextcreationerror", Oe, !1),
        V === null)
      ) {
        const q = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (g.isWebGL1Renderer === !0 && q.shift(), (V = be(q, O)), V === null)
        )
          throw be(q)
            ? new Error(
                "Error creating WebGL context with your selected attributes.",
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        V instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.",
        ),
        V.getShaderPrecisionFormat === void 0 &&
          (V.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (O) {
      throw (console.error("THREE.WebGLRenderer: " + O.message), O);
    }
    let ge,
      Le,
      Se,
      at,
      We,
      U,
      D,
      le,
      Re,
      Ee,
      Te,
      rt,
      Be,
      Ke,
      mt,
      wt,
      Ae,
      Ht,
      Ct,
      yt,
      dt,
      nt,
      Mt,
      kt;
    function Qt() {
      (ge = new y4(V)),
        (Le = new h4(V, ge, e)),
        ge.init(Le),
        (nt = new bR(V, ge, Le)),
        (Se = new JH(V, ge, Le)),
        (at = new S4(V)),
        (We = new HH()),
        (U = new e5(V, ge, Se, We, Le, nt, at)),
        (D = new p4(g)),
        (le = new v4(g)),
        (Re = new PF(V, Le)),
        (Mt = new c4(V, ge, Re, Le)),
        (Ee = new _4(V, Re, at, Mt)),
        (Te = new T4(V, Ee, Re, at)),
        (Ct = new E4(V, Le, U)),
        (wt = new f4(We)),
        (rt = new zH(g, D, le, ge, Le, Mt, wt)),
        (Be = new o5(g, We)),
        (Ke = new GH()),
        (mt = new YH(ge, Le)),
        (Ht = new u4(g, D, le, Se, Te, y, u)),
        (Ae = new ZH(g, Te, Le)),
        (kt = new a5(V, at, Le, Se)),
        (yt = new d4(V, ge, at, Le)),
        (dt = new x4(V, ge, at, Le)),
        (at.programs = rt.programs),
        (g.capabilities = Le),
        (g.extensions = ge),
        (g.properties = We),
        (g.renderLists = Ke),
        (g.shadowMap = Ae),
        (g.state = Se),
        (g.info = at);
    }
    Qt();
    const Lt = new s5(g, V);
    (this.xr = Lt),
      (this.getContext = function () {
        return V;
      }),
      (this.getContextAttributes = function () {
        return V.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const O = ge.get("WEBGL_lose_context");
        O && O.loseContext();
      }),
      (this.forceContextRestore = function () {
        const O = ge.get("WEBGL_lose_context");
        O && O.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return ne;
      }),
      (this.setPixelRatio = function (O) {
        O !== void 0 && ((ne = O), this.setSize(X, G, !1));
      }),
      (this.getSize = function (O) {
        return O.set(X, G);
      }),
      (this.setSize = function (O, q, $ = !0) {
        if (Lt.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          );
          return;
        }
        (X = O),
          (G = q),
          (t.width = Math.floor(O * ne)),
          (t.height = Math.floor(q * ne)),
          $ === !0 && ((t.style.width = O + "px"), (t.style.height = q + "px")),
          this.setViewport(0, 0, O, q);
      }),
      (this.getDrawingBufferSize = function (O) {
        return O.set(X * ne, G * ne).floor();
      }),
      (this.setDrawingBufferSize = function (O, q, $) {
        (X = O),
          (G = q),
          (ne = $),
          (t.width = Math.floor(O * $)),
          (t.height = Math.floor(q * $)),
          this.setViewport(0, 0, O, q);
      }),
      (this.getCurrentViewport = function (O) {
        return O.copy(P);
      }),
      (this.getViewport = function (O) {
        return O.copy(H);
      }),
      (this.setViewport = function (O, q, $, Y) {
        O.isVector4 ? H.set(O.x, O.y, O.z, O.w) : H.set(O, q, $, Y),
          Se.viewport(P.copy(H).multiplyScalar(ne).floor());
      }),
      (this.getScissor = function (O) {
        return O.copy(ee);
      }),
      (this.setScissor = function (O, q, $, Y) {
        O.isVector4 ? ee.set(O.x, O.y, O.z, O.w) : ee.set(O, q, $, Y),
          Se.scissor(I.copy(ee).multiplyScalar(ne).floor());
      }),
      (this.getScissorTest = function () {
        return ae;
      }),
      (this.setScissorTest = function (O) {
        Se.setScissorTest((ae = O));
      }),
      (this.setOpaqueSort = function (O) {
        k = O;
      }),
      (this.setTransparentSort = function (O) {
        W = O;
      }),
      (this.getClearColor = function (O) {
        return O.copy(Ht.getClearColor());
      }),
      (this.setClearColor = function () {
        Ht.setClearColor.apply(Ht, arguments);
      }),
      (this.getClearAlpha = function () {
        return Ht.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ht.setClearAlpha.apply(Ht, arguments);
      }),
      (this.clear = function (O = !0, q = !0, $ = !0) {
        let Y = 0;
        if (O) {
          let J = !1;
          if (A !== null) {
            const ve = A.texture.format;
            J = ve === Aw || ve === bw || ve === Cw;
          }
          if (J) {
            const ve = A.texture.type,
              _e =
                ve === Os ||
                ve === so ||
                ve === pv ||
                ve === ya ||
                ve === Ew ||
                ve === Tw,
              Ve = Ht.getClearColor(),
              Ue = Ht.getClearAlpha(),
              $e = Ve.r,
              je = Ve.g,
              Fe = Ve.b;
            _e
              ? ((S[0] = $e),
                (S[1] = je),
                (S[2] = Fe),
                (S[3] = Ue),
                V.clearBufferuiv(V.COLOR, 0, S))
              : ((x[0] = $e),
                (x[1] = je),
                (x[2] = Fe),
                (x[3] = Ue),
                V.clearBufferiv(V.COLOR, 0, x));
          } else Y |= V.COLOR_BUFFER_BIT;
        }
        q && (Y |= V.DEPTH_BUFFER_BIT),
          $ &&
            ((Y |= V.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          V.clear(Y);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Zt, !1),
          t.removeEventListener("webglcontextrestored", j, !1),
          t.removeEventListener("webglcontextcreationerror", Oe, !1),
          Ke.dispose(),
          mt.dispose(),
          We.dispose(),
          D.dispose(),
          le.dispose(),
          Te.dispose(),
          Mt.dispose(),
          kt.dispose(),
          rt.dispose(),
          Lt.dispose(),
          Lt.removeEventListener("sessionstart", $n),
          Lt.removeEventListener("sessionend", en),
          ye && (ye.dispose(), (ye = null)),
          zn.stop();
      });
    function Zt(O) {
      O.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (w = !0);
    }
    function j() {
      console.log("THREE.WebGLRenderer: Context Restored."), (w = !1);
      const O = at.autoReset,
        q = Ae.enabled,
        $ = Ae.autoUpdate,
        Y = Ae.needsUpdate,
        J = Ae.type;
      Qt(),
        (at.autoReset = O),
        (Ae.enabled = q),
        (Ae.autoUpdate = $),
        (Ae.needsUpdate = Y),
        (Ae.type = J);
    }
    function Oe(O) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        O.statusMessage,
      );
    }
    function De(O) {
      const q = O.target;
      q.removeEventListener("dispose", De), ot(q);
    }
    function ot(O) {
      ft(O), We.remove(O);
    }
    function ft(O) {
      const q = We.get(O).programs;
      q !== void 0 &&
        (q.forEach(function ($) {
          rt.releaseProgram($);
        }),
        O.isShaderMaterial && rt.releaseShaderCache(O));
    }
    this.renderBufferDirect = function (O, q, $, Y, J, ve) {
      q === null && (q = tt);
      const _e = J.isMesh && J.matrixWorld.determinant() < 0,
        Ve = fe(O, q, $, Y, J);
      Se.setMaterial(Y, _e);
      let Ue = $.index,
        $e = 1;
      if (Y.wireframe === !0) {
        if (((Ue = Ee.getWireframeAttribute($)), Ue === void 0)) return;
        $e = 2;
      }
      const je = $.drawRange,
        Fe = $.attributes.position;
      let St = je.start * $e,
        bt = (je.start + je.count) * $e;
      ve !== null &&
        ((St = Math.max(St, ve.start * $e)),
        (bt = Math.min(bt, (ve.start + ve.count) * $e))),
        Ue !== null
          ? ((St = Math.max(St, 0)), (bt = Math.min(bt, Ue.count)))
          : Fe != null &&
            ((St = Math.max(St, 0)), (bt = Math.min(bt, Fe.count)));
      const pt = bt - St;
      if (pt < 0 || pt === 1 / 0) return;
      Mt.setup(J, Y, Ve, $, Ue);
      let xt,
        Ne = yt;
      if (
        (Ue !== null && ((xt = Re.get(Ue)), (Ne = dt), Ne.setIndex(xt)),
        J.isMesh)
      )
        Y.wireframe === !0
          ? (Se.setLineWidth(Y.wireframeLinewidth * Ge()), Ne.setMode(V.LINES))
          : Ne.setMode(V.TRIANGLES);
      else if (J.isLine) {
        let Pe = Y.linewidth;
        Pe === void 0 && (Pe = 1),
          Se.setLineWidth(Pe * Ge()),
          J.isLineSegments
            ? Ne.setMode(V.LINES)
            : J.isLineLoop
              ? Ne.setMode(V.LINE_LOOP)
              : Ne.setMode(V.LINE_STRIP);
      } else
        J.isPoints
          ? Ne.setMode(V.POINTS)
          : J.isSprite && Ne.setMode(V.TRIANGLES);
      if (J.isBatchedMesh)
        Ne.renderMultiDraw(
          J._multiDrawStarts,
          J._multiDrawCounts,
          J._multiDrawCount,
        );
      else if (J.isInstancedMesh) Ne.renderInstances(St, pt, J.count);
      else if ($.isInstancedBufferGeometry) {
        const Pe = $._maxInstanceCount !== void 0 ? $._maxInstanceCount : 1 / 0,
          At = Math.min($.instanceCount, Pe);
        Ne.renderInstances(St, pt, At);
      } else Ne.render(St, pt);
    };
    function Vt(O, q, $) {
      O.transparent === !0 && O.side === bs && O.forceSinglePass === !1
        ? ((O.side = Ui),
          (O.needsUpdate = !0),
          Mo(O, q, $),
          (O.side = go),
          (O.needsUpdate = !0),
          Mo(O, q, $),
          (O.side = bs))
        : Mo(O, q, $);
    }
    (this.compile = function (O, q, $ = null) {
      $ === null && ($ = O),
        (f = mt.get($)),
        f.init(),
        m.push(f),
        $.traverseVisible(function (J) {
          J.isLight &&
            J.layers.test(q.layers) &&
            (f.pushLight(J), J.castShadow && f.pushShadow(J));
        }),
        O !== $ &&
          O.traverseVisible(function (J) {
            J.isLight &&
              J.layers.test(q.layers) &&
              (f.pushLight(J), J.castShadow && f.pushShadow(J));
          }),
        f.setupLights(g._useLegacyLights);
      const Y = new Set();
      return (
        O.traverse(function (J) {
          const ve = J.material;
          if (ve)
            if (Array.isArray(ve))
              for (let _e = 0; _e < ve.length; _e++) {
                const Ve = ve[_e];
                Vt(Ve, $, J), Y.add(Ve);
              }
            else Vt(ve, $, J), Y.add(ve);
        }),
        m.pop(),
        (f = null),
        Y
      );
    }),
      (this.compileAsync = function (O, q, $ = null) {
        const Y = this.compile(O, q, $);
        return new Promise((J) => {
          function ve() {
            if (
              (Y.forEach(function (_e) {
                We.get(_e).currentProgram.isReady() && Y.delete(_e);
              }),
              Y.size === 0)
            ) {
              J(O);
              return;
            }
            setTimeout(ve, 10);
          }
          ge.get("KHR_parallel_shader_compile") !== null
            ? ve()
            : setTimeout(ve, 10);
        });
      });
    let Xt = null;
    function mn(O) {
      Xt && Xt(O);
    }
    function $n() {
      zn.stop();
    }
    function en() {
      zn.start();
    }
    const zn = new SR();
    zn.setAnimationLoop(mn),
      typeof self < "u" && zn.setContext(self),
      (this.setAnimationLoop = function (O) {
        (Xt = O), Lt.setAnimationLoop(O), O === null ? zn.stop() : zn.start();
      }),
      Lt.addEventListener("sessionstart", $n),
      Lt.addEventListener("sessionend", en),
      (this.render = function (O, q) {
        if (q !== void 0 && q.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
          );
          return;
        }
        if (w === !0) return;
        O.matrixWorldAutoUpdate === !0 && O.updateMatrixWorld(),
          q.parent === null &&
            q.matrixWorldAutoUpdate === !0 &&
            q.updateMatrixWorld(),
          Lt.enabled === !0 &&
            Lt.isPresenting === !0 &&
            (Lt.cameraAutoUpdate === !0 && Lt.updateCamera(q),
            (q = Lt.getCamera())),
          O.isScene === !0 && O.onBeforeRender(g, O, q, A),
          (f = mt.get(O, m.length)),
          f.init(),
          m.push(f),
          Ce.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse),
          xe.setFromProjectionMatrix(Ce),
          (de = this.localClippingEnabled),
          (te = wt.init(this.clippingPlanes, de)),
          (_ = Ke.get(O, d.length)),
          _.init(),
          d.push(_),
          Ci(O, q, 0, g.sortObjects),
          _.finish(),
          g.sortObjects === !0 && _.sort(k, W),
          this.info.render.frame++,
          te === !0 && wt.beginShadows();
        const $ = f.state.shadowsArray;
        if (
          (Ae.render($, O, q),
          te === !0 && wt.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          (Lt.enabled === !1 ||
            Lt.isPresenting === !1 ||
            Lt.hasDepthSensing() === !1) &&
            Ht.render(_, O),
          f.setupLights(g._useLegacyLights),
          q.isArrayCamera)
        ) {
          const Y = q.cameras;
          for (let J = 0, ve = Y.length; J < ve; J++) {
            const _e = Y[J];
            So(_, O, _e, _e.viewport);
          }
        } else So(_, O, q);
        A !== null &&
          (U.updateMultisampleRenderTarget(A), U.updateRenderTargetMipmap(A)),
          O.isScene === !0 && O.onAfterRender(g, O, q),
          Mt.resetDefaultState(),
          (L = -1),
          (N = null),
          m.pop(),
          m.length > 0 ? (f = m[m.length - 1]) : (f = null),
          d.pop(),
          d.length > 0 ? (_ = d[d.length - 1]) : (_ = null);
      });
    function Ci(O, q, $, Y) {
      if (O.visible === !1) return;
      if (O.layers.test(q.layers)) {
        if (O.isGroup) $ = O.renderOrder;
        else if (O.isLOD) O.autoUpdate === !0 && O.update(q);
        else if (O.isLight) f.pushLight(O), O.castShadow && f.pushShadow(O);
        else if (O.isSprite) {
          if (!O.frustumCulled || xe.intersectsSprite(O)) {
            Y && ze.setFromMatrixPosition(O.matrixWorld).applyMatrix4(Ce);
            const _e = Te.update(O),
              Ve = O.material;
            Ve.visible && _.push(O, _e, Ve, $, ze.z, null);
          }
        } else if (
          (O.isMesh || O.isLine || O.isPoints) &&
          (!O.frustumCulled || xe.intersectsObject(O))
        ) {
          const _e = Te.update(O),
            Ve = O.material;
          if (
            (Y &&
              (O.boundingSphere !== void 0
                ? (O.boundingSphere === null && O.computeBoundingSphere(),
                  ze.copy(O.boundingSphere.center))
                : (_e.boundingSphere === null && _e.computeBoundingSphere(),
                  ze.copy(_e.boundingSphere.center)),
              ze.applyMatrix4(O.matrixWorld).applyMatrix4(Ce)),
            Array.isArray(Ve))
          ) {
            const Ue = _e.groups;
            for (let $e = 0, je = Ue.length; $e < je; $e++) {
              const Fe = Ue[$e],
                St = Ve[Fe.materialIndex];
              St && St.visible && _.push(O, _e, St, $, ze.z, Fe);
            }
          } else Ve.visible && _.push(O, _e, Ve, $, ze.z, null);
        }
      }
      const ve = O.children;
      for (let _e = 0, Ve = ve.length; _e < Ve; _e++) Ci(ve[_e], q, $, Y);
    }
    function So(O, q, $, Y) {
      const J = O.opaque,
        ve = O.transmissive,
        _e = O.transparent;
      f.setupLightsView($),
        te === !0 && wt.setGlobalState(g.clippingPlanes, $),
        ve.length > 0 && ds(J, ve, q, $),
        Y && Se.viewport(P.copy(Y)),
        J.length > 0 && wo(J, q, $),
        ve.length > 0 && wo(ve, q, $),
        _e.length > 0 && wo(_e, q, $),
        Se.buffers.depth.setTest(!0),
        Se.buffers.depth.setMask(!0),
        Se.buffers.color.setMask(!0),
        Se.setPolygonOffset(!1);
    }
    function ds(O, q, $, Y) {
      if (($.isScene === !0 ? $.overrideMaterial : null) !== null) return;
      const ve = Le.isWebGL2;
      ye === null &&
        (ye = new as(1, 1, {
          generateMipmaps: !0,
          type: ge.has("EXT_color_buffer_half_float") ? Uc : Os,
          minFilter: As,
          samples: ve ? 4 : 0,
        })),
        g.getDrawingBufferSize(Ze),
        ve ? ye.setSize(Ze.x, Ze.y) : ye.setSize(Bg(Ze.x), Bg(Ze.y));
      const _e = g.getRenderTarget();
      g.setRenderTarget(ye),
        g.getClearColor(ue),
        (F = g.getClearAlpha()),
        F < 1 && g.setClearColor(16777215, 0.5),
        g.clear();
      const Ve = g.toneMapping;
      (g.toneMapping = Is),
        wo(O, $, Y),
        U.updateMultisampleRenderTarget(ye),
        U.updateRenderTargetMipmap(ye);
      let Ue = !1;
      for (let $e = 0, je = q.length; $e < je; $e++) {
        const Fe = q[$e],
          St = Fe.object,
          bt = Fe.geometry,
          pt = Fe.material,
          xt = Fe.group;
        if (pt.side === bs && St.layers.test(Y.layers)) {
          const Ne = pt.side;
          (pt.side = Ui),
            (pt.needsUpdate = !0),
            hs(St, $, Y, bt, pt, xt),
            (pt.side = Ne),
            (pt.needsUpdate = !0),
            (Ue = !0);
        }
      }
      Ue === !0 &&
        (U.updateMultisampleRenderTarget(ye), U.updateRenderTargetMipmap(ye)),
        g.setRenderTarget(_e),
        g.setClearColor(ue, F),
        (g.toneMapping = Ve);
    }
    function wo(O, q, $) {
      const Y = q.isScene === !0 ? q.overrideMaterial : null;
      for (let J = 0, ve = O.length; J < ve; J++) {
        const _e = O[J],
          Ve = _e.object,
          Ue = _e.geometry,
          $e = Y === null ? _e.material : Y,
          je = _e.group;
        Ve.layers.test($.layers) && hs(Ve, q, $, Ue, $e, je);
      }
    }
    function hs(O, q, $, Y, J, ve) {
      O.onBeforeRender(g, q, $, Y, J, ve),
        O.modelViewMatrix.multiplyMatrices($.matrixWorldInverse, O.matrixWorld),
        O.normalMatrix.getNormalMatrix(O.modelViewMatrix),
        J.onBeforeRender(g, q, $, Y, O, ve),
        J.transparent === !0 && J.side === bs && J.forceSinglePass === !1
          ? ((J.side = Ui),
            (J.needsUpdate = !0),
            g.renderBufferDirect($, q, Y, J, O, ve),
            (J.side = go),
            (J.needsUpdate = !0),
            g.renderBufferDirect($, q, Y, J, O, ve),
            (J.side = bs))
          : g.renderBufferDirect($, q, Y, J, O, ve),
        O.onAfterRender(g, q, $, Y, J, ve);
    }
    function Mo(O, q, $) {
      q.isScene !== !0 && (q = tt);
      const Y = We.get(O),
        J = f.state.lights,
        ve = f.state.shadowsArray,
        _e = J.state.version,
        Ve = rt.getParameters(O, J.state, ve, q, $),
        Ue = rt.getProgramCacheKey(Ve);
      let $e = Y.programs;
      (Y.environment = O.isMeshStandardMaterial ? q.environment : null),
        (Y.fog = q.fog),
        (Y.envMap = (O.isMeshStandardMaterial ? le : D).get(
          O.envMap || Y.environment,
        )),
        $e === void 0 &&
          (O.addEventListener("dispose", De),
          ($e = new Map()),
          (Y.programs = $e));
      let je = $e.get(Ue);
      if (je !== void 0) {
        if (Y.currentProgram === je && Y.lightsStateVersion === _e)
          return K(O, Ve), je;
      } else
        (Ve.uniforms = rt.getUniforms(O)),
          O.onBuild($, Ve, g),
          O.onBeforeCompile(Ve, g),
          (je = rt.acquireProgram(Ve, Ue)),
          $e.set(Ue, je),
          (Y.uniforms = Ve.uniforms);
      const Fe = Y.uniforms;
      return (
        ((!O.isShaderMaterial && !O.isRawShaderMaterial) ||
          O.clipping === !0) &&
          (Fe.clippingPlanes = wt.uniform),
        K(O, Ve),
        (Y.needsLights = Xe(O)),
        (Y.lightsStateVersion = _e),
        Y.needsLights &&
          ((Fe.ambientLightColor.value = J.state.ambient),
          (Fe.lightProbe.value = J.state.probe),
          (Fe.directionalLights.value = J.state.directional),
          (Fe.directionalLightShadows.value = J.state.directionalShadow),
          (Fe.spotLights.value = J.state.spot),
          (Fe.spotLightShadows.value = J.state.spotShadow),
          (Fe.rectAreaLights.value = J.state.rectArea),
          (Fe.ltc_1.value = J.state.rectAreaLTC1),
          (Fe.ltc_2.value = J.state.rectAreaLTC2),
          (Fe.pointLights.value = J.state.point),
          (Fe.pointLightShadows.value = J.state.pointShadow),
          (Fe.hemisphereLights.value = J.state.hemi),
          (Fe.directionalShadowMap.value = J.state.directionalShadowMap),
          (Fe.directionalShadowMatrix.value = J.state.directionalShadowMatrix),
          (Fe.spotShadowMap.value = J.state.spotShadowMap),
          (Fe.spotLightMatrix.value = J.state.spotLightMatrix),
          (Fe.spotLightMap.value = J.state.spotLightMap),
          (Fe.pointShadowMap.value = J.state.pointShadowMap),
          (Fe.pointShadowMatrix.value = J.state.pointShadowMatrix)),
        (Y.currentProgram = je),
        (Y.uniformsList = null),
        je
      );
    }
    function Z(O) {
      if (O.uniformsList === null) {
        const q = O.currentProgram.getUniforms();
        O.uniformsList = sg.seqWithValue(q.seq, O.uniforms);
      }
      return O.uniformsList;
    }
    function K(O, q) {
      const $ = We.get(O);
      ($.outputColorSpace = q.outputColorSpace),
        ($.batching = q.batching),
        ($.instancing = q.instancing),
        ($.instancingColor = q.instancingColor),
        ($.skinning = q.skinning),
        ($.morphTargets = q.morphTargets),
        ($.morphNormals = q.morphNormals),
        ($.morphColors = q.morphColors),
        ($.morphTargetsCount = q.morphTargetsCount),
        ($.numClippingPlanes = q.numClippingPlanes),
        ($.numIntersection = q.numClipIntersection),
        ($.vertexAlphas = q.vertexAlphas),
        ($.vertexTangents = q.vertexTangents),
        ($.toneMapping = q.toneMapping);
    }
    function fe(O, q, $, Y, J) {
      q.isScene !== !0 && (q = tt), U.resetTextureUnits();
      const ve = q.fog,
        _e = Y.isMeshStandardMaterial ? q.environment : null,
        Ve =
          A === null
            ? g.outputColorSpace
            : A.isXRRenderTarget === !0
              ? A.texture.colorSpace
              : Ds,
        Ue = (Y.isMeshStandardMaterial ? le : D).get(Y.envMap || _e),
        $e =
          Y.vertexColors === !0 &&
          !!$.attributes.color &&
          $.attributes.color.itemSize === 4,
        je = !!$.attributes.tangent && (!!Y.normalMap || Y.anisotropy > 0),
        Fe = !!$.morphAttributes.position,
        St = !!$.morphAttributes.normal,
        bt = !!$.morphAttributes.color;
      let pt = Is;
      Y.toneMapped &&
        (A === null || A.isXRRenderTarget === !0) &&
        (pt = g.toneMapping);
      const xt =
          $.morphAttributes.position ||
          $.morphAttributes.normal ||
          $.morphAttributes.color,
        Ne = xt !== void 0 ? xt.length : 0,
        Pe = We.get(Y),
        At = f.state.lights;
      if (te === !0 && (de === !0 || O !== N)) {
        const Bt = O === N && Y.id === L;
        wt.setState(Y, O, Bt);
      }
      let et = !1;
      Y.version === Pe.__version
        ? ((Pe.needsLights && Pe.lightsStateVersion !== At.state.version) ||
            Pe.outputColorSpace !== Ve ||
            (J.isBatchedMesh && Pe.batching === !1) ||
            (!J.isBatchedMesh && Pe.batching === !0) ||
            (J.isInstancedMesh && Pe.instancing === !1) ||
            (!J.isInstancedMesh && Pe.instancing === !0) ||
            (J.isSkinnedMesh && Pe.skinning === !1) ||
            (!J.isSkinnedMesh && Pe.skinning === !0) ||
            (J.isInstancedMesh &&
              Pe.instancingColor === !0 &&
              J.instanceColor === null) ||
            (J.isInstancedMesh &&
              Pe.instancingColor === !1 &&
              J.instanceColor !== null) ||
            Pe.envMap !== Ue ||
            (Y.fog === !0 && Pe.fog !== ve) ||
            (Pe.numClippingPlanes !== void 0 &&
              (Pe.numClippingPlanes !== wt.numPlanes ||
                Pe.numIntersection !== wt.numIntersection)) ||
            Pe.vertexAlphas !== $e ||
            Pe.vertexTangents !== je ||
            Pe.morphTargets !== Fe ||
            Pe.morphNormals !== St ||
            Pe.morphColors !== bt ||
            Pe.toneMapping !== pt ||
            (Le.isWebGL2 === !0 && Pe.morphTargetsCount !== Ne)) &&
          (et = !0)
        : ((et = !0), (Pe.__version = Y.version));
      let gt = Pe.currentProgram;
      et === !0 && (gt = Mo(Y, q, J));
      let qt = !1,
        on = !1,
        tn = !1;
      const Gt = gt.getUniforms(),
        Nn = Pe.uniforms;
      if (
        (Se.useProgram(gt.program) && ((qt = !0), (on = !0), (tn = !0)),
        Y.id !== L && ((L = Y.id), (on = !0)),
        qt || N !== O)
      ) {
        Gt.setValue(V, "projectionMatrix", O.projectionMatrix),
          Gt.setValue(V, "viewMatrix", O.matrixWorldInverse);
        const Bt = Gt.map.cameraPosition;
        Bt !== void 0 &&
          Bt.setValue(V, ze.setFromMatrixPosition(O.matrixWorld)),
          Le.logarithmicDepthBuffer &&
            Gt.setValue(
              V,
              "logDepthBufFC",
              2 / (Math.log(O.far + 1) / Math.LN2),
            ),
          (Y.isMeshPhongMaterial ||
            Y.isMeshToonMaterial ||
            Y.isMeshLambertMaterial ||
            Y.isMeshBasicMaterial ||
            Y.isMeshStandardMaterial ||
            Y.isShaderMaterial) &&
            Gt.setValue(V, "isOrthographic", O.isOrthographicCamera === !0),
          N !== O && ((N = O), (on = !0), (tn = !0));
      }
      if (J.isSkinnedMesh) {
        Gt.setOptional(V, J, "bindMatrix"),
          Gt.setOptional(V, J, "bindMatrixInverse");
        const Bt = J.skeleton;
        Bt &&
          (Le.floatVertexTextures
            ? (Bt.boneTexture === null && Bt.computeBoneTexture(),
              Gt.setValue(V, "boneTexture", Bt.boneTexture, U))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
              ));
      }
      J.isBatchedMesh &&
        (Gt.setOptional(V, J, "batchingTexture"),
        Gt.setValue(V, "batchingTexture", J._matricesTexture, U));
      const ni = $.morphAttributes;
      if (
        ((ni.position !== void 0 ||
          ni.normal !== void 0 ||
          (ni.color !== void 0 && Le.isWebGL2 === !0)) &&
          Ct.update(J, $, gt),
        (on || Pe.receiveShadow !== J.receiveShadow) &&
          ((Pe.receiveShadow = J.receiveShadow),
          Gt.setValue(V, "receiveShadow", J.receiveShadow)),
        Y.isMeshGouraudMaterial &&
          Y.envMap !== null &&
          ((Nn.envMap.value = Ue),
          (Nn.flipEnvMap.value =
            Ue.isCubeTexture && Ue.isRenderTargetTexture === !1 ? -1 : 1)),
        on &&
          (Gt.setValue(V, "toneMappingExposure", g.toneMappingExposure),
          Pe.needsLights && we(Nn, tn),
          ve && Y.fog === !0 && Be.refreshFogUniforms(Nn, ve),
          Be.refreshMaterialUniforms(Nn, Y, ne, G, ye),
          sg.upload(V, Z(Pe), Nn, U)),
        Y.isShaderMaterial &&
          Y.uniformsNeedUpdate === !0 &&
          (sg.upload(V, Z(Pe), Nn, U), (Y.uniformsNeedUpdate = !1)),
        Y.isSpriteMaterial && Gt.setValue(V, "center", J.center),
        Gt.setValue(V, "modelViewMatrix", J.modelViewMatrix),
        Gt.setValue(V, "normalMatrix", J.normalMatrix),
        Gt.setValue(V, "modelMatrix", J.matrixWorld),
        Y.isShaderMaterial || Y.isRawShaderMaterial)
      ) {
        const Bt = Y.uniformsGroups;
        for (let bi = 0, Pn = Bt.length; bi < Pn; bi++)
          if (Le.isWebGL2) {
            const Us = Bt[bi];
            kt.update(Us, gt), kt.bind(Us, gt);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
            );
      }
      return gt;
    }
    function we(O, q) {
      (O.ambientLightColor.needsUpdate = q),
        (O.lightProbe.needsUpdate = q),
        (O.directionalLights.needsUpdate = q),
        (O.directionalLightShadows.needsUpdate = q),
        (O.pointLights.needsUpdate = q),
        (O.pointLightShadows.needsUpdate = q),
        (O.spotLights.needsUpdate = q),
        (O.spotLightShadows.needsUpdate = q),
        (O.rectAreaLights.needsUpdate = q),
        (O.hemisphereLights.needsUpdate = q);
    }
    function Xe(O) {
      return (
        O.isMeshLambertMaterial ||
        O.isMeshToonMaterial ||
        O.isMeshPhongMaterial ||
        O.isMeshStandardMaterial ||
        O.isShadowMaterial ||
        (O.isShaderMaterial && O.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return C;
      }),
      (this.getRenderTarget = function () {
        return A;
      }),
      (this.setRenderTargetTextures = function (O, q, $) {
        (We.get(O.texture).__webglTexture = q),
          (We.get(O.depthTexture).__webglTexture = $);
        const Y = We.get(O);
        (Y.__hasExternalTextures = !0),
          Y.__hasExternalTextures &&
            ((Y.__autoAllocateDepthBuffer = $ === void 0),
            Y.__autoAllocateDepthBuffer ||
              (ge.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
                ),
                (Y.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (O, q) {
        const $ = We.get(O);
        ($.__webglFramebuffer = q), ($.__useDefaultFramebuffer = q === void 0);
      }),
      (this.setRenderTarget = function (O, q = 0, $ = 0) {
        (A = O), (T = q), (C = $);
        let Y = !0,
          J = null,
          ve = !1,
          _e = !1;
        if (O) {
          const Ue = We.get(O);
          Ue.__useDefaultFramebuffer !== void 0
            ? (Se.bindFramebuffer(V.FRAMEBUFFER, null), (Y = !1))
            : Ue.__webglFramebuffer === void 0
              ? U.setupRenderTarget(O)
              : Ue.__hasExternalTextures &&
                U.rebindTextures(
                  O,
                  We.get(O.texture).__webglTexture,
                  We.get(O.depthTexture).__webglTexture,
                );
          const $e = O.texture;
          ($e.isData3DTexture ||
            $e.isDataArrayTexture ||
            $e.isCompressedArrayTexture) &&
            (_e = !0);
          const je = We.get(O).__webglFramebuffer;
          O.isWebGLCubeRenderTarget
            ? (Array.isArray(je[q]) ? (J = je[q][$]) : (J = je[q]), (ve = !0))
            : Le.isWebGL2 && O.samples > 0 && U.useMultisampledRTT(O) === !1
              ? (J = We.get(O).__webglMultisampledFramebuffer)
              : Array.isArray(je)
                ? (J = je[$])
                : (J = je),
            P.copy(O.viewport),
            I.copy(O.scissor),
            (Q = O.scissorTest);
        } else
          P.copy(H).multiplyScalar(ne).floor(),
            I.copy(ee).multiplyScalar(ne).floor(),
            (Q = ae);
        if (
          (Se.bindFramebuffer(V.FRAMEBUFFER, J) &&
            Le.drawBuffers &&
            Y &&
            Se.drawBuffers(O, J),
          Se.viewport(P),
          Se.scissor(I),
          Se.setScissorTest(Q),
          ve)
        ) {
          const Ue = We.get(O.texture);
          V.framebufferTexture2D(
            V.FRAMEBUFFER,
            V.COLOR_ATTACHMENT0,
            V.TEXTURE_CUBE_MAP_POSITIVE_X + q,
            Ue.__webglTexture,
            $,
          );
        } else if (_e) {
          const Ue = We.get(O.texture),
            $e = q || 0;
          V.framebufferTextureLayer(
            V.FRAMEBUFFER,
            V.COLOR_ATTACHMENT0,
            Ue.__webglTexture,
            $ || 0,
            $e,
          );
        }
        L = -1;
      }),
      (this.readRenderTargetPixels = function (O, q, $, Y, J, ve, _e) {
        if (!(O && O.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
          return;
        }
        let Ve = We.get(O).__webglFramebuffer;
        if ((O.isWebGLCubeRenderTarget && _e !== void 0 && (Ve = Ve[_e]), Ve)) {
          Se.bindFramebuffer(V.FRAMEBUFFER, Ve);
          try {
            const Ue = O.texture,
              $e = Ue.format,
              je = Ue.type;
            if (
              $e !== Ni &&
              nt.convert($e) !==
                V.getParameter(V.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
              );
              return;
            }
            const Fe =
              je === Uc &&
              (ge.has("EXT_color_buffer_half_float") ||
                (Le.isWebGL2 && ge.has("EXT_color_buffer_float")));
            if (
              je !== Os &&
              nt.convert(je) !==
                V.getParameter(V.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                je === Br &&
                (Le.isWebGL2 ||
                  ge.has("OES_texture_float") ||
                  ge.has("WEBGL_color_buffer_float"))
              ) &&
              !Fe
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
              return;
            }
            q >= 0 &&
              q <= O.width - Y &&
              $ >= 0 &&
              $ <= O.height - J &&
              V.readPixels(q, $, Y, J, nt.convert($e), nt.convert(je), ve);
          } finally {
            const Ue = A !== null ? We.get(A).__webglFramebuffer : null;
            Se.bindFramebuffer(V.FRAMEBUFFER, Ue);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (O, q, $ = 0) {
        const Y = Math.pow(2, -$),
          J = Math.floor(q.image.width * Y),
          ve = Math.floor(q.image.height * Y);
        U.setTexture2D(q, 0),
          V.copyTexSubImage2D(V.TEXTURE_2D, $, 0, 0, O.x, O.y, J, ve),
          Se.unbindTexture();
      }),
      (this.copyTextureToTexture = function (O, q, $, Y = 0) {
        const J = q.image.width,
          ve = q.image.height,
          _e = nt.convert($.format),
          Ve = nt.convert($.type);
        U.setTexture2D($, 0),
          V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, $.flipY),
          V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha),
          V.pixelStorei(V.UNPACK_ALIGNMENT, $.unpackAlignment),
          q.isDataTexture
            ? V.texSubImage2D(
                V.TEXTURE_2D,
                Y,
                O.x,
                O.y,
                J,
                ve,
                _e,
                Ve,
                q.image.data,
              )
            : q.isCompressedTexture
              ? V.compressedTexSubImage2D(
                  V.TEXTURE_2D,
                  Y,
                  O.x,
                  O.y,
                  q.mipmaps[0].width,
                  q.mipmaps[0].height,
                  _e,
                  q.mipmaps[0].data,
                )
              : V.texSubImage2D(V.TEXTURE_2D, Y, O.x, O.y, _e, Ve, q.image),
          Y === 0 && $.generateMipmaps && V.generateMipmap(V.TEXTURE_2D),
          Se.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (O, q, $, Y, J = 0) {
        if (g.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
          );
          return;
        }
        const ve = O.max.x - O.min.x + 1,
          _e = O.max.y - O.min.y + 1,
          Ve = O.max.z - O.min.z + 1,
          Ue = nt.convert(Y.format),
          $e = nt.convert(Y.type);
        let je;
        if (Y.isData3DTexture) U.setTexture3D(Y, 0), (je = V.TEXTURE_3D);
        else if (Y.isDataArrayTexture || Y.isCompressedArrayTexture)
          U.setTexture2DArray(Y, 0), (je = V.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
          );
          return;
        }
        V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, Y.flipY),
          V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
          V.pixelStorei(V.UNPACK_ALIGNMENT, Y.unpackAlignment);
        const Fe = V.getParameter(V.UNPACK_ROW_LENGTH),
          St = V.getParameter(V.UNPACK_IMAGE_HEIGHT),
          bt = V.getParameter(V.UNPACK_SKIP_PIXELS),
          pt = V.getParameter(V.UNPACK_SKIP_ROWS),
          xt = V.getParameter(V.UNPACK_SKIP_IMAGES),
          Ne = $.isCompressedTexture ? $.mipmaps[J] : $.image;
        V.pixelStorei(V.UNPACK_ROW_LENGTH, Ne.width),
          V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, Ne.height),
          V.pixelStorei(V.UNPACK_SKIP_PIXELS, O.min.x),
          V.pixelStorei(V.UNPACK_SKIP_ROWS, O.min.y),
          V.pixelStorei(V.UNPACK_SKIP_IMAGES, O.min.z),
          $.isDataTexture || $.isData3DTexture
            ? V.texSubImage3D(je, J, q.x, q.y, q.z, ve, _e, Ve, Ue, $e, Ne.data)
            : $.isCompressedArrayTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
                ),
                V.compressedTexSubImage3D(
                  je,
                  J,
                  q.x,
                  q.y,
                  q.z,
                  ve,
                  _e,
                  Ve,
                  Ue,
                  Ne.data,
                ))
              : V.texSubImage3D(je, J, q.x, q.y, q.z, ve, _e, Ve, Ue, $e, Ne),
          V.pixelStorei(V.UNPACK_ROW_LENGTH, Fe),
          V.pixelStorei(V.UNPACK_IMAGE_HEIGHT, St),
          V.pixelStorei(V.UNPACK_SKIP_PIXELS, bt),
          V.pixelStorei(V.UNPACK_SKIP_ROWS, pt),
          V.pixelStorei(V.UNPACK_SKIP_IMAGES, xt),
          J === 0 && Y.generateMipmaps && V.generateMipmap(je),
          Se.unbindTexture();
      }),
      (this.initTexture = function (O) {
        O.isCubeTexture
          ? U.setTextureCube(O, 0)
          : O.isData3DTexture
            ? U.setTexture3D(O, 0)
            : O.isDataArrayTexture || O.isCompressedArrayTexture
              ? U.setTexture2DArray(O, 0)
              : U.setTexture2D(O, 0),
          Se.unbindTexture();
      }),
      (this.resetState = function () {
        (T = 0), (C = 0), (A = null), Se.reset(), Mt.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  get coordinateSystem() {
    return Ps;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === gv ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        nn.workingColorSpace === yf ? "display-p3" : "srgb");
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
      ),
      this.outputColorSpace === Wn ? xa : Lw
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.",
    ),
      (this.outputColorSpace = e === xa ? Wn : Ds);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
    ),
      (this._useLegacyLights = e);
  }
}
class PR extends Vw {}
PR.prototype.isWebGL1Renderer = !0;
class _v {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Qe(e)),
      (this.density = t);
  }
  clone() {
    return new _v(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class xv {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Qe(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new xv(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class zg extends Kt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class Sv {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Fh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = gr());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      Ll(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.",
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gr()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gr()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Ri = new B();
class Vl {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Ri.fromBufferAttribute(this, t),
        Ri.applyMatrix4(e),
        this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ri.fromBufferAttribute(this, t),
        Ri.applyNormalMatrix(e),
        this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ri.fromBufferAttribute(this, t),
        Ri.transformDirection(e),
        this.setXYZ(t, Ri.x, Ri.y, Ri.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = Di(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Pt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Pt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Pt(t, this.array)), (i = Pt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Pt(t, this.array)),
        (i = Pt(i, this.array)),
        (r = Pt(r, this.array)),
        (s = Pt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Jt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Vl(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class Gw extends ci {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Ru;
const bd = new B(),
  Lu = new B(),
  Iu = new B(),
  Ou = new Me(),
  Ad = new Me(),
  RR = new _t(),
  om = new B(),
  Pd = new B(),
  am = new B(),
  eC = new Me(),
  j0 = new Me(),
  tC = new Me();
class LR extends Kt {
  constructor(e = new Gw()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Ru === void 0)
    ) {
      Ru = new Rt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new Sv(t, 5);
      Ru.setIndex([0, 1, 2, 0, 2, 3]),
        Ru.setAttribute("position", new Vl(i, 3, 0, !1)),
        Ru.setAttribute("uv", new Vl(i, 2, 3, !1));
    }
    (this.geometry = Ru), (this.material = e), (this.center = new Me(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      Lu.setFromMatrixScale(this.matrixWorld),
      RR.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Iu.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Lu.multiplyScalar(-Iu.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    lm(om.set(-0.5, -0.5, 0), Iu, o, Lu, r, s),
      lm(Pd.set(0.5, -0.5, 0), Iu, o, Lu, r, s),
      lm(am.set(0.5, 0.5, 0), Iu, o, Lu, r, s),
      eC.set(0, 0),
      j0.set(1, 0),
      tC.set(1, 1);
    let a = e.ray.intersectTriangle(om, Pd, am, !1, bd);
    if (
      a === null &&
      (lm(Pd.set(-0.5, 0.5, 0), Iu, o, Lu, r, s),
      j0.set(0, 1),
      (a = e.ray.intersectTriangle(om, am, Pd, !1, bd)),
      a === null)
    )
      return;
    const u = e.ray.origin.distanceTo(bd);
    u < e.near ||
      u > e.far ||
      t.push({
        distance: u,
        point: bd.clone(),
        uv: hr.getInterpolation(bd, om, Pd, am, eC, j0, tC, new Me()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function lm(n, e, t, i, r, s) {
  Ou.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Ad.x = s * Ou.x - r * Ou.y), (Ad.y = r * Ou.x + s * Ou.y))
      : Ad.copy(Ou),
    n.copy(e),
    (n.x += Ad.x),
    (n.y += Ad.y),
    n.applyMatrix4(RR);
}
const um = new B(),
  nC = new B();
class IR extends Kt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      um.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(um);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      um.setFromMatrixPosition(e.matrixWorld),
        nC.setFromMatrixPosition(this.matrixWorld);
      const i = um.distanceTo(nC) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const iC = new B(),
  rC = new rn(),
  sC = new rn(),
  l5 = new B(),
  oC = new _t(),
  cm = new B(),
  X0 = new Ei(),
  aC = new _t(),
  q0 = new Xc();
class OR extends Bn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = Lx),
      (this.bindMatrix = new _t()),
      (this.bindMatrixInverse = new _t()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Fi()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, cm), this.boundingBox.expandByPoint(cm);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ei()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, cm), this.boundingSphere.expandByPoint(cm);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      X0.copy(this.boundingSphere),
      X0.applyMatrix4(r),
      e.ray.intersectsSphere(X0) !== !1 &&
        (aC.copy(r).invert(),
        q0.copy(e.ray).applyMatrix4(aC),
        !(
          this.boundingBox !== null && q0.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, q0)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new rn(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === Lx
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === j2
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
            );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    rC.fromBufferAttribute(r.attributes.skinIndex, e),
      sC.fromBufferAttribute(r.attributes.skinWeight, e),
      iC.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = sC.getComponent(s);
      if (o !== 0) {
        const a = rC.getComponent(s);
        oC.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(l5.copy(iC).applyMatrix4(oC), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Ww extends Kt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Ol extends Mn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, u, h = In, p = In, v, y) {
    super(null, o, a, u, h, p, r, s, v, y),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const lC = new _t(),
  u5 = new _t();
class wv {
  constructor(e = [], t = []) {
    (this.uuid = gr()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new _t());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new _t();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : u5;
      lC.multiplyMatrices(a, t[s]), lC.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new wv(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Ol(t, e, e, Ni, Br);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new Ww())),
        this.bones.push(o),
        this.boneInverses.push(new _t().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class zc extends Jt {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Nu = new _t(),
  uC = new _t(),
  dm = [],
  cC = new Fi(),
  c5 = new _t(),
  Rd = new Bn(),
  Ld = new Ei();
class NR extends Bn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new zc(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, c5);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Fi()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Nu),
        cC.copy(e.boundingBox).applyMatrix4(Nu),
        this.boundingBox.union(cC);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ei()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Nu),
        Ld.copy(e.boundingSphere).applyMatrix4(Nu),
        this.boundingSphere.union(Ld);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Rd.geometry = this.geometry),
      (Rd.material = this.material),
      Rd.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Ld.copy(this.boundingSphere),
        Ld.applyMatrix4(i),
        e.ray.intersectsSphere(Ld) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Nu),
          uC.multiplyMatrices(i, Nu),
          (Rd.matrixWorld = uC),
          Rd.raycast(e, dm);
        for (let o = 0, a = dm.length; o < a; o++) {
          const u = dm[o];
          (u.instanceId = s), (u.object = this), t.push(u);
        }
        dm.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new zc(
        new Float32Array(this.instanceMatrix.count * 3),
        3,
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function d5(n, e) {
  return n.z - e.z;
}
function h5(n, e) {
  return e.z - n.z;
}
class f5 {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t) {
    const i = this.pool,
      r = this.list;
    this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
    const s = i[this.index];
    r.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Du = "batchId",
  Go = new _t(),
  dC = new _t(),
  p5 = new _t(),
  hC = new _t(),
  $0 = new wf(),
  hm = new Fi(),
  Za = new Ei(),
  Id = new B(),
  Y0 = new f5(),
  Si = new Bn(),
  fm = [];
function m5(n, e, t = 0) {
  const i = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const r = n.count;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < i; o++)
        e.setComponent(s + t, o, n.getComponent(s, o));
  } else e.array.set(n.array, t * i);
  e.needsUpdate = !0;
}
class DR extends Bn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, i = t * 2, r) {
    super(new Rt(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = i),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      i = new Ol(t, e, e, Ni, Br);
    this._matricesTexture = i;
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      i = this._maxVertexCount,
      r = this._maxGeometryCount,
      s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const u = e.getAttribute(a),
          { array: h, itemSize: p, normalized: v } = u,
          y = new h.constructor(i * p),
          S = new u.constructor(y, p, v);
        S.setUsage(u.usage), t.setAttribute(a, S);
      }
      if (e.getIndex() !== null) {
        const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new Jt(a, 1));
      }
      const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
      t.setAttribute(Du, new Jt(o, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(Du))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${Du}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".',
      );
    for (const i in t.attributes) {
      if (i === Du) continue;
      if (!e.hasAttribute(i))
        throw new Error(
          `BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`,
        );
      const r = e.getAttribute(i),
        s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value.",
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Fi());
    const e = this._geometryCount,
      t = this.boundingBox,
      i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 &&
        (this.getMatrixAt(r, Go),
        this.getBoundingBoxAt(r, hm).applyMatrix4(Go),
        t.union(hm));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ei());
    const e = this._geometryCount,
      t = this.boundingSphere,
      i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++)
      i[r] !== !1 &&
        (this.getMatrixAt(r, Go),
        this.getBoundingSphereAt(r, Za).applyMatrix4(Go),
        t.union(Za));
  }
  addGeometry(e, t = -1, i = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let s = null;
    const o = this._reservedRanges,
      a = this._drawRanges,
      u = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]),
      t === -1
        ? (r.vertexCount = e.getAttribute("position").count)
        : (r.vertexCount = t),
      s === null
        ? (r.vertexStart = 0)
        : (r.vertexStart = s.vertexStart + s.vertexCount);
    const h = e.getIndex(),
      p = h !== null;
    if (
      (p &&
        (i === -1 ? (r.indexCount = h.count) : (r.indexCount = i),
        s === null
          ? (r.indexStart = 0)
          : (r.indexStart = s.indexStart + s.indexCount)),
      (r.indexStart !== -1 &&
        r.indexStart + r.indexCount > this._maxIndexCount) ||
        r.vertexStart + r.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size.",
      );
    const v = this._visibility,
      y = this._active,
      S = this._matricesTexture,
      x = this._matricesTexture.image.data;
    v.push(!0), y.push(!0);
    const _ = this._geometryCount;
    this._geometryCount++,
      p5.toArray(x, _ * 16),
      (S.needsUpdate = !0),
      o.push(r),
      a.push({ start: p ? r.indexStart : r.vertexStart, count: -1 }),
      u.push({
        boxInitialized: !1,
        box: new Fi(),
        sphereInitialized: !1,
        sphere: new Ei(),
      });
    const f = this.geometry.getAttribute(Du);
    for (let d = 0; d < r.vertexCount; d++) f.setX(r.vertexStart + d, _);
    return (f.needsUpdate = !0), this.setGeometryAt(_, e), _;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry,
      r = i.getIndex() !== null,
      s = i.getIndex(),
      o = t.getIndex(),
      a = this._reservedRanges[e];
    if (
      (r && o.count > a.indexCount) ||
      t.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry.",
      );
    const u = a.vertexStart,
      h = a.vertexCount;
    for (const S in i.attributes) {
      if (S === Du) continue;
      const x = t.getAttribute(S),
        _ = i.getAttribute(S);
      m5(x, _, u);
      const f = x.itemSize;
      for (let d = x.count, m = h; d < m; d++) {
        const g = u + d;
        for (let w = 0; w < f; w++) _.setComponent(g, w, 0);
      }
      _.needsUpdate = !0;
    }
    if (r) {
      const S = a.indexStart;
      for (let x = 0; x < o.count; x++) s.setX(S + x, u + o.getX(x));
      for (let x = o.count, _ = a.indexCount; x < _; x++) s.setX(S + x, u);
      s.needsUpdate = !0;
    }
    const p = this._bounds[e];
    t.boundingBox !== null
      ? (p.box.copy(t.boundingBox), (p.boxInitialized = !0))
      : (p.boxInitialized = !1),
      t.boundingSphere !== null
        ? (p.sphere.copy(t.boundingSphere), (p.sphereInitialized = !0))
        : (p.sphereInitialized = !1);
    const v = this._drawRanges[e],
      y = t.getAttribute("position");
    return (v.count = r ? o.count : y.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1
      ? this
      : ((t[e] = !1), (this._visibilityChanged = !0), this);
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1) return null;
    const r = this._bounds[e],
      s = r.box,
      o = this.geometry;
    if (r.boxInitialized === !1) {
      s.makeEmpty();
      const a = o.index,
        u = o.attributes.position,
        h = this._drawRanges[e];
      for (let p = h.start, v = h.start + h.count; p < v; p++) {
        let y = p;
        a && (y = a.getX(y)), s.expandByPoint(Id.fromBufferAttribute(u, y));
      }
      r.boxInitialized = !0;
    }
    return t.copy(s), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1) return null;
    const r = this._bounds[e],
      s = r.sphere,
      o = this.geometry;
    if (r.sphereInitialized === !1) {
      s.makeEmpty(), this.getBoundingBoxAt(e, hm), hm.getCenter(s.center);
      const a = o.index,
        u = o.attributes.position,
        h = this._drawRanges[e];
      let p = 0;
      for (let v = h.start, y = h.start + h.count; v < y; v++) {
        let S = v;
        a && (S = a.getX(S)),
          Id.fromBufferAttribute(u, S),
          (p = Math.max(p, s.center.distanceToSquared(Id)));
      }
      (s.radius = Math.sqrt(p)), (r.sphereInitialized = !0);
    }
    return t.copy(s), t;
  }
  setMatrixAt(e, t) {
    const i = this._active,
      r = this._matricesTexture,
      s = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || i[e] === !1
      ? this
      : (t.toArray(s, e * 16), (r.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const i = this._active,
      r = this._matricesTexture.image.data,
      s = this._geometryCount;
    return e >= s || i[e] === !1 ? null : t.fromArray(r, e * 16);
  }
  setVisibleAt(e, t) {
    const i = this._visibility,
      r = this._active,
      s = this._geometryCount;
    return e >= s || r[e] === !1 || i[e] === t
      ? this
      : ((i[e] = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._visibility,
      i = this._active,
      r = this._geometryCount;
    return e >= r || i[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const i = this._visibility,
      r = this._active,
      s = this._drawRanges,
      o = this._geometryCount,
      a = this.matrixWorld,
      u = this.geometry;
    (Si.material = this.material),
      (Si.geometry.index = u.index),
      (Si.geometry.attributes = u.attributes),
      Si.geometry.boundingBox === null && (Si.geometry.boundingBox = new Fi()),
      Si.geometry.boundingSphere === null &&
        (Si.geometry.boundingSphere = new Ei());
    for (let h = 0; h < o; h++) {
      if (!i[h] || !r[h]) continue;
      const p = s[h];
      Si.geometry.setDrawRange(p.start, p.count),
        this.getMatrixAt(h, Si.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(h, Si.geometry.boundingBox),
        this.getBoundingSphereAt(h, Si.geometry.boundingSphere),
        Si.raycast(e, fm);
      for (let v = 0, y = fm.length; v < y; v++) {
        const S = fm[v];
        (S.object = this), (S.batchId = h), t.push(S);
      }
      fm.length = 0;
    }
    (Si.material = null),
      (Si.geometry.index = null),
      (Si.geometry.attributes = {}),
      Si.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, t, i, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = r.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      u = this._active,
      h = this._visibility,
      p = this._multiDrawStarts,
      v = this._multiDrawCounts,
      y = this._drawRanges,
      S = this.perObjectFrustumCulled;
    S &&
      (hC
        .multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)
        .multiply(this.matrixWorld),
      $0.setFromProjectionMatrix(hC, e.coordinateSystem));
    let x = 0;
    if (this.sortObjects) {
      dC.copy(this.matrixWorld).invert(),
        Id.setFromMatrixPosition(i.matrixWorld).applyMatrix4(dC);
      for (let d = 0, m = h.length; d < m; d++)
        if (h[d] && u[d]) {
          this.getMatrixAt(d, Go),
            this.getBoundingSphereAt(d, Za).applyMatrix4(Go);
          let g = !1;
          if ((S && (g = !$0.intersectsSphere(Za)), !g)) {
            const w = Id.distanceTo(Za.center);
            Y0.push(y[d], w);
          }
        }
      const _ = Y0.list,
        f = this.customSort;
      f === null ? _.sort(s.transparent ? h5 : d5) : f.call(this, _, i);
      for (let d = 0, m = _.length; d < m; d++) {
        const g = _[d];
        (p[x] = g.start * a), (v[x] = g.count), x++;
      }
      Y0.reset();
    } else
      for (let _ = 0, f = h.length; _ < f; _++)
        if (h[_] && u[_]) {
          let d = !1;
          if (
            (S &&
              (this.getMatrixAt(_, Go),
              this.getBoundingSphereAt(_, Za).applyMatrix4(Go),
              (d = !$0.intersectsSphere(Za))),
            !d)
          ) {
            const m = y[_];
            (p[x] = m.start * a), (v[x] = m.count), x++;
          }
        }
    (this._multiDrawCount = x), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class Hi extends ci {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const fC = new B(),
  pC = new B(),
  mC = new _t(),
  K0 = new Xc(),
  pm = new Ei();
class Ta extends Kt {
  constructor(e = new Rt(), t = new Hi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        fC.fromBufferAttribute(t, r - 1),
          pC.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += fC.distanceTo(pC));
      e.setAttribute("lineDistance", new lt(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      pm.copy(i.boundingSphere),
      pm.applyMatrix4(r),
      (pm.radius += s),
      e.ray.intersectsSphere(pm) === !1)
    )
      return;
    mC.copy(r).invert(), K0.copy(e.ray).applyMatrix4(mC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      h = new B(),
      p = new B(),
      v = new B(),
      y = new B(),
      S = this.isLineSegments ? 2 : 1,
      x = i.index,
      f = i.attributes.position;
    if (x !== null) {
      const d = Math.max(0, o.start),
        m = Math.min(x.count, o.start + o.count);
      for (let g = d, w = m - 1; g < w; g += S) {
        const T = x.getX(g),
          C = x.getX(g + 1);
        if (
          (h.fromBufferAttribute(f, T),
          p.fromBufferAttribute(f, C),
          K0.distanceSqToSegment(h, p, y, v) > u)
        )
          continue;
        y.applyMatrix4(this.matrixWorld);
        const L = e.ray.origin.distanceTo(y);
        L < e.near ||
          L > e.far ||
          t.push({
            distance: L,
            point: v.clone().applyMatrix4(this.matrixWorld),
            index: g,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const d = Math.max(0, o.start),
        m = Math.min(f.count, o.start + o.count);
      for (let g = d, w = m - 1; g < w; g += S) {
        if (
          (h.fromBufferAttribute(f, g),
          p.fromBufferAttribute(f, g + 1),
          K0.distanceSqToSegment(h, p, y, v) > u)
        )
          continue;
        y.applyMatrix4(this.matrixWorld);
        const C = e.ray.origin.distanceTo(y);
        C < e.near ||
          C > e.far ||
          t.push({
            distance: C,
            point: v.clone().applyMatrix4(this.matrixWorld),
            index: g,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const gC = new B(),
  vC = new B();
class ks extends Ta {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        gC.fromBufferAttribute(t, r),
          vC.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + gC.distanceTo(vC));
      e.setAttribute("lineDistance", new lt(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
}
class kR extends Ta {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Mv extends ci {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const yC = new _t(),
  uS = new Xc(),
  mm = new Ei(),
  gm = new B();
class UR extends Kt {
  constructor(e = new Rt(), t = new Mv()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      mm.copy(i.boundingSphere),
      mm.applyMatrix4(r),
      (mm.radius += s),
      e.ray.intersectsSphere(mm) === !1)
    )
      return;
    yC.copy(r).invert(), uS.copy(e.ray).applyMatrix4(yC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = a * a,
      h = i.index,
      v = i.attributes.position;
    if (h !== null) {
      const y = Math.max(0, o.start),
        S = Math.min(h.count, o.start + o.count);
      for (let x = y, _ = S; x < _; x++) {
        const f = h.getX(x);
        gm.fromBufferAttribute(v, f), _C(gm, f, u, r, e, t, this);
      }
    } else {
      const y = Math.max(0, o.start),
        S = Math.min(v.count, o.start + o.count);
      for (let x = y, _ = S; x < _; x++)
        gm.fromBufferAttribute(v, x), _C(gm, x, u, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function _C(n, e, t, i, r, s, o) {
  const a = uS.distanceSqToPoint(n);
  if (a < t) {
    const u = new B();
    uS.closestPointToPoint(n, u), u.applyMatrix4(i);
    const h = r.ray.origin.distanceTo(u);
    if (h < r.near || h > r.far) return;
    s.push({
      distance: h,
      distanceToRay: Math.sqrt(a),
      point: u,
      index: e,
      face: null,
      object: o,
    });
  }
}
class g5 extends Mn {
  constructor(e, t, i, r, s, o, a, u, h) {
    super(e, t, i, r, s, o, a, u, h),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : xn),
      (this.magFilter = s !== void 0 ? s : xn),
      (this.generateMipmaps = !1);
    const p = this;
    function v() {
      (p.needsUpdate = !0), e.requestVideoFrameCallback(v);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(v);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class v5 extends Mn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = In),
      (this.minFilter = In),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class Ev extends Mn {
  constructor(e, t, i, r, s, o, a, u, h, p, v, y) {
    super(null, o, a, u, h, p, r, s, v, y),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class y5 extends Ev {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = Mi);
  }
}
class _5 extends Ev {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, vo),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class x5 extends Mn {
  constructor(e, t, i, r, s, o, a, u, h) {
    super(e, t, i, r, s, o, a, u, h),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class us {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      u = s - 1,
      h;
    for (; a <= u; )
      if (((r = Math.floor(a + (u - a) / 2)), (h = i[r] - o), h < 0)) a = r + 1;
      else if (h > 0) u = r - 1;
      else {
        u = r;
        break;
      }
    if (((r = u), i[r] === o)) return r / (s - 1);
    const p = i[r],
      y = i[r + 1] - p,
      S = (o - p) / y;
    return (r + S) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r),
      a = this.getPoint(s),
      u = t || (o.isVector2 ? new Me() : new B());
    return u.copy(a).sub(o).normalize(), u;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new B(),
      r = [],
      s = [],
      o = [],
      a = new B(),
      u = new _t();
    for (let S = 0; S <= e; S++) {
      const x = S / e;
      r[S] = this.getTangentAt(x, new B());
    }
    (s[0] = new B()), (o[0] = new B());
    let h = Number.MAX_VALUE;
    const p = Math.abs(r[0].x),
      v = Math.abs(r[0].y),
      y = Math.abs(r[0].z);
    p <= h && ((h = p), i.set(1, 0, 0)),
      v <= h && ((h = v), i.set(0, 1, 0)),
      y <= h && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]);
    for (let S = 1; S <= e; S++) {
      if (
        ((s[S] = s[S - 1].clone()),
        (o[S] = o[S - 1].clone()),
        a.crossVectors(r[S - 1], r[S]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const x = Math.acos(An(r[S - 1].dot(r[S]), -1, 1));
        s[S].applyMatrix4(u.makeRotationAxis(a, x));
      }
      o[S].crossVectors(r[S], s[S]);
    }
    if (t === !0) {
      let S = Math.acos(An(s[0].dot(s[e]), -1, 1));
      (S /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (S = -S);
      for (let x = 1; x <= e; x++)
        s[x].applyMatrix4(u.makeRotationAxis(r[x], S * x)),
          o[x].crossVectors(r[x], s[x]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Tv extends us {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    u = 0,
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = u);
  }
  getPoint(e, t) {
    const i = t || new Me(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
    const a = this.aStartAngle + e * s;
    let u = this.aX + this.xRadius * Math.cos(a),
      h = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const p = Math.cos(this.aRotation),
        v = Math.sin(this.aRotation),
        y = u - this.aX,
        S = h - this.aY;
      (u = y * p - S * v + this.aX), (h = y * v + S * p + this.aY);
    }
    return i.set(u, h);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class FR extends Tv {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function jw() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, u) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - u),
      (i = 2 * s - 2 * o + a + u);
  }
  return {
    initCatmullRom: function (s, o, a, u, h) {
      r(o, a, h * (a - s), h * (u - o));
    },
    initNonuniformCatmullRom: function (s, o, a, u, h, p, v) {
      let y = (o - s) / h - (a - s) / (h + p) + (a - o) / p,
        S = (a - o) / p - (u - o) / (p + v) + (u - a) / v;
      (y *= p), (S *= p), r(o, a, y, S);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const vm = new B(),
  Q0 = new jw(),
  Z0 = new jw(),
  J0 = new jw();
class BR extends us {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r);
  }
  getPoint(e, t = new B()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      u = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : u === 0 && a === s - 1 && ((a = s - 2), (u = 1));
    let h, p;
    this.closed || a > 0
      ? (h = r[(a - 1) % s])
      : (vm.subVectors(r[0], r[1]).add(r[0]), (h = vm));
    const v = r[a % s],
      y = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (p = r[(a + 2) % s])
        : (vm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (p = vm)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const S = this.curveType === "chordal" ? 0.5 : 0.25;
      let x = Math.pow(h.distanceToSquared(v), S),
        _ = Math.pow(v.distanceToSquared(y), S),
        f = Math.pow(y.distanceToSquared(p), S);
      _ < 1e-4 && (_ = 1),
        x < 1e-4 && (x = _),
        f < 1e-4 && (f = _),
        Q0.initNonuniformCatmullRom(h.x, v.x, y.x, p.x, x, _, f),
        Z0.initNonuniformCatmullRom(h.y, v.y, y.y, p.y, x, _, f),
        J0.initNonuniformCatmullRom(h.z, v.z, y.z, p.z, x, _, f);
    } else
      this.curveType === "catmullrom" &&
        (Q0.initCatmullRom(h.x, v.x, y.x, p.x, this.tension),
        Z0.initCatmullRom(h.y, v.y, y.y, p.y, this.tension),
        J0.initCatmullRom(h.z, v.z, y.z, p.z, this.tension));
    return i.set(Q0.calc(u), Z0.calc(u), J0.calc(u)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new B().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function xC(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    u = n * a;
  return (
    (2 * t - 2 * i + s + o) * u + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function S5(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function w5(n, e) {
  return 2 * (1 - n) * n * e;
}
function M5(n, e) {
  return n * n * e;
}
function ih(n, e, t, i) {
  return S5(n, e) + w5(n, t) + M5(n, i);
}
function E5(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function T5(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function C5(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function b5(n, e) {
  return n * n * n * e;
}
function rh(n, e, t, i, r) {
  return E5(n, e) + T5(n, t) + C5(n, i) + b5(n, r);
}
class Xw extends us {
  constructor(e = new Me(), t = new Me(), i = new Me(), r = new Me()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new Me()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(rh(e, r.x, s.x, o.x, a.x), rh(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class zR extends us {
  constructor(e = new B(), t = new B(), i = new B(), r = new B()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new B()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        rh(e, r.x, s.x, o.x, a.x),
        rh(e, r.y, s.y, o.y, a.y),
        rh(e, r.z, s.z, o.z, a.z),
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class qw extends us {
  constructor(e = new Me(), t = new Me()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Me()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Me()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class HR extends us {
  constructor(e = new B(), t = new B()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new B()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new B()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class $w extends us {
  constructor(e = new Me(), t = new Me(), i = new Me()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new Me()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return i.set(ih(e, r.x, s.x, o.x), ih(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Yw extends us {
  constructor(e = new B(), t = new B(), i = new B()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new B()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(ih(e, r.x, s.x, o.x), ih(e, r.y, s.y, o.y), ih(e, r.z, s.z, o.z)), i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Kw extends us {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new Me()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      u = r[o === 0 ? o : o - 1],
      h = r[o],
      p = r[o > r.length - 2 ? r.length - 1 : o + 1],
      v = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(xC(a, u.x, h.x, p.x, v.x), xC(a, u.y, h.y, p.y, v.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new Me().fromArray(r));
    }
    return this;
  }
}
var Hg = Object.freeze({
  __proto__: null,
  ArcCurve: FR,
  CatmullRomCurve3: BR,
  CubicBezierCurve: Xw,
  CubicBezierCurve3: zR,
  EllipseCurve: Tv,
  LineCurve: qw,
  LineCurve3: HR,
  QuadraticBezierCurve: $w,
  QuadraticBezierCurve3: Yw,
  SplineCurve: Kw,
});
class VR extends us {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Hg[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          u = a.getLength(),
          h = u === 0 ? 0 : 1 - o / u;
        return a.getPointAt(h, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
            ? 1
            : o.isSplineCurve
              ? e * o.points.length
              : e,
        u = o.getPoints(a);
      for (let h = 0; h < u.length; h++) {
        const p = u[h];
        (i && i.equals(p)) || (t.push(p), (i = p));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new Hg[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Hh extends VR {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Me()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new qw(this.currentPoint.clone(), new Me(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new $w(this.currentPoint.clone(), new Me(e, t), new Me(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new Xw(
      this.currentPoint.clone(),
      new Me(e, t),
      new Me(i, r),
      new Me(s, o),
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new Kw(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(e + a, t + u, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, u) {
    const h = this.currentPoint.x,
      p = this.currentPoint.y;
    return this.absellipse(e + h, t + p, i, r, s, o, a, u), this;
  }
  absellipse(e, t, i, r, s, o, a, u) {
    const h = new Tv(e, t, i, r, s, o, a, u);
    if (this.curves.length > 0) {
      const v = h.getPoint(0);
      v.equals(this.currentPoint) || this.lineTo(v.x, v.y);
    }
    this.curves.push(h);
    const p = h.getPoint(1);
    return this.currentPoint.copy(p), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ef extends Rt {
  constructor(
    e = [new Me(0, -0.5), new Me(0.5, 0), new Me(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2,
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = An(r, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      u = [],
      h = [],
      p = 1 / t,
      v = new B(),
      y = new Me(),
      S = new B(),
      x = new B(),
      _ = new B();
    let f = 0,
      d = 0;
    for (let m = 0; m <= e.length - 1; m++)
      switch (m) {
        case 0:
          (f = e[m + 1].x - e[m].x),
            (d = e[m + 1].y - e[m].y),
            (S.x = d * 1),
            (S.y = -f),
            (S.z = d * 0),
            _.copy(S),
            S.normalize(),
            u.push(S.x, S.y, S.z);
          break;
        case e.length - 1:
          u.push(_.x, _.y, _.z);
          break;
        default:
          (f = e[m + 1].x - e[m].x),
            (d = e[m + 1].y - e[m].y),
            (S.x = d * 1),
            (S.y = -f),
            (S.z = d * 0),
            x.copy(S),
            (S.x += _.x),
            (S.y += _.y),
            (S.z += _.z),
            S.normalize(),
            u.push(S.x, S.y, S.z),
            _.copy(x);
      }
    for (let m = 0; m <= t; m++) {
      const g = i + m * p * r,
        w = Math.sin(g),
        T = Math.cos(g);
      for (let C = 0; C <= e.length - 1; C++) {
        (v.x = e[C].x * w),
          (v.y = e[C].y),
          (v.z = e[C].x * T),
          o.push(v.x, v.y, v.z),
          (y.x = m / t),
          (y.y = C / (e.length - 1)),
          a.push(y.x, y.y);
        const A = u[3 * C + 0] * w,
          L = u[3 * C + 1],
          N = u[3 * C + 0] * T;
        h.push(A, L, N);
      }
    }
    for (let m = 0; m < t; m++)
      for (let g = 0; g < e.length - 1; g++) {
        const w = g + m * e.length,
          T = w,
          C = w + e.length,
          A = w + e.length + 1,
          L = w + 1;
        s.push(T, C, L), s.push(A, L, C);
      }
    this.setIndex(s),
      this.setAttribute("position", new lt(o, 3)),
      this.setAttribute("uv", new lt(a, 2)),
      this.setAttribute("normal", new lt(h, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ef(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Cv extends Ef {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new Hh();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: i,
        radialSegments: r,
      });
  }
  static fromJSON(e) {
    return new Cv(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class bv extends Rt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      u = [],
      h = new B(),
      p = new Me();
    o.push(0, 0, 0), a.push(0, 0, 1), u.push(0.5, 0.5);
    for (let v = 0, y = 3; v <= t; v++, y += 3) {
      const S = i + (v / t) * r;
      (h.x = e * Math.cos(S)),
        (h.y = e * Math.sin(S)),
        o.push(h.x, h.y, h.z),
        a.push(0, 0, 1),
        (p.x = (o[y] / e + 1) / 2),
        (p.y = (o[y + 1] / e + 1) / 2),
        u.push(p.x, p.y);
    }
    for (let v = 1; v <= t; v++) s.push(v, v + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new lt(o, 3)),
      this.setAttribute("normal", new lt(a, 3)),
      this.setAttribute("uv", new lt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new bv(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Yc extends Rt {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    u = Math.PI * 2,
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: u,
      });
    const h = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const p = [],
      v = [],
      y = [],
      S = [];
    let x = 0;
    const _ = [],
      f = i / 2;
    let d = 0;
    m(),
      o === !1 && (e > 0 && g(!0), t > 0 && g(!1)),
      this.setIndex(p),
      this.setAttribute("position", new lt(v, 3)),
      this.setAttribute("normal", new lt(y, 3)),
      this.setAttribute("uv", new lt(S, 2));
    function m() {
      const w = new B(),
        T = new B();
      let C = 0;
      const A = (t - e) / i;
      for (let L = 0; L <= s; L++) {
        const N = [],
          P = L / s,
          I = P * (t - e) + e;
        for (let Q = 0; Q <= r; Q++) {
          const ue = Q / r,
            F = ue * u + a,
            X = Math.sin(F),
            G = Math.cos(F);
          (T.x = I * X),
            (T.y = -P * i + f),
            (T.z = I * G),
            v.push(T.x, T.y, T.z),
            w.set(X, A, G).normalize(),
            y.push(w.x, w.y, w.z),
            S.push(ue, 1 - P),
            N.push(x++);
        }
        _.push(N);
      }
      for (let L = 0; L < r; L++)
        for (let N = 0; N < s; N++) {
          const P = _[N][L],
            I = _[N + 1][L],
            Q = _[N + 1][L + 1],
            ue = _[N][L + 1];
          p.push(P, I, ue), p.push(I, Q, ue), (C += 6);
        }
      h.addGroup(d, C, 0), (d += C);
    }
    function g(w) {
      const T = x,
        C = new Me(),
        A = new B();
      let L = 0;
      const N = w === !0 ? e : t,
        P = w === !0 ? 1 : -1;
      for (let Q = 1; Q <= r; Q++)
        v.push(0, f * P, 0), y.push(0, P, 0), S.push(0.5, 0.5), x++;
      const I = x;
      for (let Q = 0; Q <= r; Q++) {
        const F = (Q / r) * u + a,
          X = Math.cos(F),
          G = Math.sin(F);
        (A.x = N * G),
          (A.y = f * P),
          (A.z = N * X),
          v.push(A.x, A.y, A.z),
          y.push(0, P, 0),
          (C.x = X * 0.5 + 0.5),
          (C.y = G * 0.5 * P + 0.5),
          S.push(C.x, C.y),
          x++;
      }
      for (let Q = 0; Q < r; Q++) {
        const ue = T + Q,
          F = I + Q;
        w === !0 ? p.push(F, F + 1, ue) : p.push(F + 1, F, ue), (L += 3);
      }
      h.addGroup(d, L, w === !0 ? 1 : 2), (d += L);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yc(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Av extends Yc {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Av(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Oa extends Rt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      h(i),
      p(),
      this.setAttribute("position", new lt(s, 3)),
      this.setAttribute("normal", new lt(s.slice(), 3)),
      this.setAttribute("uv", new lt(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(m) {
      const g = new B(),
        w = new B(),
        T = new B();
      for (let C = 0; C < t.length; C += 3)
        S(t[C + 0], g), S(t[C + 1], w), S(t[C + 2], T), u(g, w, T, m);
    }
    function u(m, g, w, T) {
      const C = T + 1,
        A = [];
      for (let L = 0; L <= C; L++) {
        A[L] = [];
        const N = m.clone().lerp(w, L / C),
          P = g.clone().lerp(w, L / C),
          I = C - L;
        for (let Q = 0; Q <= I; Q++)
          Q === 0 && L === C
            ? (A[L][Q] = N)
            : (A[L][Q] = N.clone().lerp(P, Q / I));
      }
      for (let L = 0; L < C; L++)
        for (let N = 0; N < 2 * (C - L) - 1; N++) {
          const P = Math.floor(N / 2);
          N % 2 === 0
            ? (y(A[L][P + 1]), y(A[L + 1][P]), y(A[L][P]))
            : (y(A[L][P + 1]), y(A[L + 1][P + 1]), y(A[L + 1][P]));
        }
    }
    function h(m) {
      const g = new B();
      for (let w = 0; w < s.length; w += 3)
        (g.x = s[w + 0]),
          (g.y = s[w + 1]),
          (g.z = s[w + 2]),
          g.normalize().multiplyScalar(m),
          (s[w + 0] = g.x),
          (s[w + 1] = g.y),
          (s[w + 2] = g.z);
    }
    function p() {
      const m = new B();
      for (let g = 0; g < s.length; g += 3) {
        (m.x = s[g + 0]), (m.y = s[g + 1]), (m.z = s[g + 2]);
        const w = f(m) / 2 / Math.PI + 0.5,
          T = d(m) / Math.PI + 0.5;
        o.push(w, 1 - T);
      }
      x(), v();
    }
    function v() {
      for (let m = 0; m < o.length; m += 6) {
        const g = o[m + 0],
          w = o[m + 2],
          T = o[m + 4],
          C = Math.max(g, w, T),
          A = Math.min(g, w, T);
        C > 0.9 &&
          A < 0.1 &&
          (g < 0.2 && (o[m + 0] += 1),
          w < 0.2 && (o[m + 2] += 1),
          T < 0.2 && (o[m + 4] += 1));
      }
    }
    function y(m) {
      s.push(m.x, m.y, m.z);
    }
    function S(m, g) {
      const w = m * 3;
      (g.x = e[w + 0]), (g.y = e[w + 1]), (g.z = e[w + 2]);
    }
    function x() {
      const m = new B(),
        g = new B(),
        w = new B(),
        T = new B(),
        C = new Me(),
        A = new Me(),
        L = new Me();
      for (let N = 0, P = 0; N < s.length; N += 9, P += 6) {
        m.set(s[N + 0], s[N + 1], s[N + 2]),
          g.set(s[N + 3], s[N + 4], s[N + 5]),
          w.set(s[N + 6], s[N + 7], s[N + 8]),
          C.set(o[P + 0], o[P + 1]),
          A.set(o[P + 2], o[P + 3]),
          L.set(o[P + 4], o[P + 5]),
          T.copy(m).add(g).add(w).divideScalar(3);
        const I = f(T);
        _(C, P + 0, m, I), _(A, P + 2, g, I), _(L, P + 4, w, I);
      }
    }
    function _(m, g, w, T) {
      T < 0 && m.x === 1 && (o[g] = m.x - 1),
        w.x === 0 && w.z === 0 && (o[g] = T / 2 / Math.PI + 0.5);
    }
    function f(m) {
      return Math.atan2(m.z, -m.x);
    }
    function d(m) {
      return Math.atan2(-m.y, Math.sqrt(m.x * m.x + m.z * m.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Oa(e.vertices, e.indices, e.radius, e.details);
  }
}
class Pv extends Oa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Pv(e.radius, e.detail);
  }
}
const ym = new B(),
  _m = new B(),
  e_ = new B(),
  xm = new hr();
class GR extends Rt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Rl * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        u = o ? o.count : a.count,
        h = [0, 0, 0],
        p = ["a", "b", "c"],
        v = new Array(3),
        y = {},
        S = [];
      for (let x = 0; x < u; x += 3) {
        o
          ? ((h[0] = o.getX(x)), (h[1] = o.getX(x + 1)), (h[2] = o.getX(x + 2)))
          : ((h[0] = x), (h[1] = x + 1), (h[2] = x + 2));
        const { a: _, b: f, c: d } = xm;
        if (
          (_.fromBufferAttribute(a, h[0]),
          f.fromBufferAttribute(a, h[1]),
          d.fromBufferAttribute(a, h[2]),
          xm.getNormal(e_),
          (v[0] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`),
          (v[1] = `${Math.round(f.x * r)},${Math.round(f.y * r)},${Math.round(f.z * r)}`),
          (v[2] = `${Math.round(d.x * r)},${Math.round(d.y * r)},${Math.round(d.z * r)}`),
          !(v[0] === v[1] || v[1] === v[2] || v[2] === v[0]))
        )
          for (let m = 0; m < 3; m++) {
            const g = (m + 1) % 3,
              w = v[m],
              T = v[g],
              C = xm[p[m]],
              A = xm[p[g]],
              L = `${w}_${T}`,
              N = `${T}_${w}`;
            N in y && y[N]
              ? (e_.dot(y[N].normal) <= s &&
                  (S.push(C.x, C.y, C.z), S.push(A.x, A.y, A.z)),
                (y[N] = null))
              : L in y ||
                (y[L] = { index0: h[m], index1: h[g], normal: e_.clone() });
          }
      }
      for (const x in y)
        if (y[x]) {
          const { index0: _, index1: f } = y[x];
          ym.fromBufferAttribute(a, _),
            _m.fromBufferAttribute(a, f),
            S.push(ym.x, ym.y, ym.z),
            S.push(_m.x, _m.y, _m.z);
        }
      this.setAttribute("position", new lt(S, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Nl extends Hh {
  constructor(e) {
    super(e), (this.uuid = gr()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new Hh().fromJSON(r));
    }
    return this;
  }
}
const A5 = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = WR(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, u, h, p, v, y, S;
    if ((i && (s = O5(n, e, s, t)), n.length > 80 * t)) {
      (a = h = n[0]), (u = p = n[1]);
      for (let x = t; x < r; x += t)
        (v = n[x]),
          (y = n[x + 1]),
          v < a && (a = v),
          y < u && (u = y),
          v > h && (h = v),
          y > p && (p = y);
      (S = Math.max(h - a, p - u)), (S = S !== 0 ? 32767 / S : 0);
    }
    return Vh(s, o, t, a, u, S, 0), o;
  },
};
function WR(n, e, t, i, r) {
  let s, o;
  if (r === W5(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = SC(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = SC(s, n[s], n[s + 1], o);
  return o && Rv(o, o.next) && (Wh(o), (o = o.next)), o;
}
function Gl(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (Rv(t, t.next) || Sn(t.prev, t, t.next) === 0))
    ) {
      if ((Wh(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function Vh(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && F5(n, i, r, s);
  let a = n,
    u,
    h;
  for (; n.prev !== n.next; ) {
    if (((u = n.prev), (h = n.next), s ? R5(n, i, r, s) : P5(n))) {
      e.push((u.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((h.i / t) | 0),
        Wh(n),
        (n = h.next),
        (a = h.next);
      continue;
    }
    if (((n = h), n === a)) {
      o
        ? o === 1
          ? ((n = L5(Gl(n), e, t)), Vh(n, e, t, i, r, s, 2))
          : o === 2 && I5(n, e, t, i, r, s)
        : Vh(Gl(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function P5(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (Sn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    u = t.y,
    h = i.y,
    p = r < s ? (r < o ? r : o) : s < o ? s : o,
    v = a < u ? (a < h ? a : h) : u < h ? u : h,
    y = r > s ? (r > o ? r : o) : s > o ? s : o,
    S = a > u ? (a > h ? a : h) : u > h ? u : h;
  let x = i.next;
  for (; x !== e; ) {
    if (
      x.x >= p &&
      x.x <= y &&
      x.y >= v &&
      x.y <= S &&
      ic(r, a, s, u, o, h, x.x, x.y) &&
      Sn(x.prev, x, x.next) >= 0
    )
      return !1;
    x = x.next;
  }
  return !0;
}
function R5(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (Sn(r, s, o) >= 0) return !1;
  const a = r.x,
    u = s.x,
    h = o.x,
    p = r.y,
    v = s.y,
    y = o.y,
    S = a < u ? (a < h ? a : h) : u < h ? u : h,
    x = p < v ? (p < y ? p : y) : v < y ? v : y,
    _ = a > u ? (a > h ? a : h) : u > h ? u : h,
    f = p > v ? (p > y ? p : y) : v > y ? v : y,
    d = cS(S, x, e, t, i),
    m = cS(_, f, e, t, i);
  let g = n.prevZ,
    w = n.nextZ;
  for (; g && g.z >= d && w && w.z <= m; ) {
    if (
      (g.x >= S &&
        g.x <= _ &&
        g.y >= x &&
        g.y <= f &&
        g !== r &&
        g !== o &&
        ic(a, p, u, v, h, y, g.x, g.y) &&
        Sn(g.prev, g, g.next) >= 0) ||
      ((g = g.prevZ),
      w.x >= S &&
        w.x <= _ &&
        w.y >= x &&
        w.y <= f &&
        w !== r &&
        w !== o &&
        ic(a, p, u, v, h, y, w.x, w.y) &&
        Sn(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; g && g.z >= d; ) {
    if (
      g.x >= S &&
      g.x <= _ &&
      g.y >= x &&
      g.y <= f &&
      g !== r &&
      g !== o &&
      ic(a, p, u, v, h, y, g.x, g.y) &&
      Sn(g.prev, g, g.next) >= 0
    )
      return !1;
    g = g.prevZ;
  }
  for (; w && w.z <= m; ) {
    if (
      w.x >= S &&
      w.x <= _ &&
      w.y >= x &&
      w.y <= f &&
      w !== r &&
      w !== o &&
      ic(a, p, u, v, h, y, w.x, w.y) &&
      Sn(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function L5(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    !Rv(r, s) &&
      jR(r, i, i.next, s) &&
      Gh(r, s) &&
      Gh(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      Wh(i),
      Wh(i.next),
      (i = n = s)),
      (i = i.next);
  } while (i !== n);
  return Gl(i);
}
function I5(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && H5(o, a)) {
        let u = XR(o, a);
        (o = Gl(o, o.next)),
          (u = Gl(u, u.next)),
          Vh(o, e, t, i, r, s, 0),
          Vh(u, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function O5(n, e, t, i) {
  const r = [];
  let s, o, a, u, h;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (u = s < o - 1 ? e[s + 1] * i : n.length),
      (h = WR(n, a, u, i, !1)),
      h === h.next && (h.steiner = !0),
      r.push(z5(h));
  for (r.sort(N5), s = 0; s < r.length; s++) t = D5(r[s], t);
  return t;
}
function N5(n, e) {
  return n.x - e.x;
}
function D5(n, e) {
  const t = k5(n, e);
  if (!t) return e;
  const i = XR(t, n);
  return Gl(i, i.next), Gl(t, t.next);
}
function k5(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const y = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        y <= s &&
        y > i &&
        ((i = y), (r = t.x < t.next.x ? t : t.next), y === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    u = r.x,
    h = r.y;
  let p = 1 / 0,
    v;
  t = r;
  do
    s >= t.x &&
      t.x >= u &&
      s !== t.x &&
      ic(o < h ? s : i, o, u, h, o < h ? i : s, o, t.x, t.y) &&
      ((v = Math.abs(o - t.y) / (s - t.x)),
      Gh(t, n) &&
        (v < p || (v === p && (t.x > r.x || (t.x === r.x && U5(r, t))))) &&
        ((r = t), (p = v))),
      (t = t.next);
  while (t !== a);
  return r;
}
function U5(n, e) {
  return Sn(n.prev, n, e.prev) < 0 && Sn(e.next, n, n.next) < 0;
}
function F5(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = cS(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== n);
  (r.prevZ.nextZ = null), (r.prevZ = null), B5(r);
}
function B5(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    u,
    h = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < h && (a++, (i = i.nextZ), !!i); e++);
      for (u = h; a > 0 || (u > 0 && i); )
        a !== 0 && (u === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), u--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r);
      t = i;
    }
    (s.nextZ = null), (h *= 2);
  } while (o > 1);
  return n;
}
function cS(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function z5(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function ic(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function H5(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !V5(n, e) &&
    ((Gh(n, e) &&
      Gh(e, n) &&
      G5(n, e) &&
      (Sn(n.prev, n, e.prev) || Sn(n, e.prev, e))) ||
      (Rv(n, e) && Sn(n.prev, n, n.next) > 0 && Sn(e.prev, e, e.next) > 0))
  );
}
function Sn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Rv(n, e) {
  return n.x === e.x && n.y === e.y;
}
function jR(n, e, t, i) {
  const r = wm(Sn(n, e, t)),
    s = wm(Sn(n, e, i)),
    o = wm(Sn(t, i, n)),
    a = wm(Sn(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && Sm(n, t, e)) ||
    (s === 0 && Sm(n, i, e)) ||
    (o === 0 && Sm(t, n, i)) ||
    (a === 0 && Sm(t, e, i))
  );
}
function Sm(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function wm(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function V5(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      jR(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Gh(n, e) {
  return Sn(n.prev, n, n.next) < 0
    ? Sn(n, e, n.next) >= 0 && Sn(n, n.prev, e) >= 0
    : Sn(n, e, n.prev) < 0 || Sn(n, n.next, e) < 0;
}
function G5(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next);
  while (t !== n);
  return i;
}
function XR(n, e) {
  const t = new dS(n.i, n.x, n.y),
    i = new dS(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function SC(n, e, t, i) {
  const r = new dS(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function Wh(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function dS(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function W5(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return r;
}
class Ns {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Ns.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    wC(e), MC(i, e);
    let o = e.length;
    t.forEach(wC);
    for (let u = 0; u < t.length; u++)
      r.push(o), (o += t[u].length), MC(i, t[u]);
    const a = A5.triangulate(i, r);
    for (let u = 0; u < a.length; u += 3) s.push(a.slice(u, u + 3));
    return s;
  }
}
function wC(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function MC(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Lv extends Rt {
  constructor(
    e = new Nl([
      new Me(0.5, 0.5),
      new Me(-0.5, 0.5),
      new Me(-0.5, -0.5),
      new Me(0.5, -0.5),
    ]),
    t = {},
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const i = this,
      r = [],
      s = [];
    for (let a = 0, u = e.length; a < u; a++) {
      const h = e[a];
      o(h);
    }
    this.setAttribute("position", new lt(r, 3)),
      this.setAttribute("uv", new lt(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const u = [],
        h = t.curveSegments !== void 0 ? t.curveSegments : 12,
        p = t.steps !== void 0 ? t.steps : 1,
        v = t.depth !== void 0 ? t.depth : 1;
      let y = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        S = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        x = t.bevelSize !== void 0 ? t.bevelSize : S - 0.1,
        _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        f = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const d = t.extrudePath,
        m = t.UVGenerator !== void 0 ? t.UVGenerator : j5;
      let g,
        w = !1,
        T,
        C,
        A,
        L;
      d &&
        ((g = d.getSpacedPoints(p)),
        (w = !0),
        (y = !1),
        (T = d.computeFrenetFrames(p, !1)),
        (C = new B()),
        (A = new B()),
        (L = new B())),
        y || ((f = 0), (S = 0), (x = 0), (_ = 0));
      const N = a.extractPoints(h);
      let P = N.shape;
      const I = N.holes;
      if (!Ns.isClockWise(P)) {
        P = P.reverse();
        for (let V = 0, be = I.length; V < be; V++) {
          const ge = I[V];
          Ns.isClockWise(ge) && (I[V] = ge.reverse());
        }
      }
      const ue = Ns.triangulateShape(P, I),
        F = P;
      for (let V = 0, be = I.length; V < be; V++) {
        const ge = I[V];
        P = P.concat(ge);
      }
      function X(V, be, ge) {
        return (
          be || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          V.clone().addScaledVector(be, ge)
        );
      }
      const G = P.length,
        ne = ue.length;
      function k(V, be, ge) {
        let Le, Se, at;
        const We = V.x - be.x,
          U = V.y - be.y,
          D = ge.x - V.x,
          le = ge.y - V.y,
          Re = We * We + U * U,
          Ee = We * le - U * D;
        if (Math.abs(Ee) > Number.EPSILON) {
          const Te = Math.sqrt(Re),
            rt = Math.sqrt(D * D + le * le),
            Be = be.x - U / Te,
            Ke = be.y + We / Te,
            mt = ge.x - le / rt,
            wt = ge.y + D / rt,
            Ae = ((mt - Be) * le - (wt - Ke) * D) / (We * le - U * D);
          (Le = Be + We * Ae - V.x), (Se = Ke + U * Ae - V.y);
          const Ht = Le * Le + Se * Se;
          if (Ht <= 2) return new Me(Le, Se);
          at = Math.sqrt(Ht / 2);
        } else {
          let Te = !1;
          We > Number.EPSILON
            ? D > Number.EPSILON && (Te = !0)
            : We < -Number.EPSILON
              ? D < -Number.EPSILON && (Te = !0)
              : Math.sign(U) === Math.sign(le) && (Te = !0),
            Te
              ? ((Le = -U), (Se = We), (at = Math.sqrt(Re)))
              : ((Le = We), (Se = U), (at = Math.sqrt(Re / 2)));
        }
        return new Me(Le / at, Se / at);
      }
      const W = [];
      for (
        let V = 0, be = F.length, ge = be - 1, Le = V + 1;
        V < be;
        V++, ge++, Le++
      )
        ge === be && (ge = 0),
          Le === be && (Le = 0),
          (W[V] = k(F[V], F[ge], F[Le]));
      const H = [];
      let ee,
        ae = W.concat();
      for (let V = 0, be = I.length; V < be; V++) {
        const ge = I[V];
        ee = [];
        for (
          let Le = 0, Se = ge.length, at = Se - 1, We = Le + 1;
          Le < Se;
          Le++, at++, We++
        )
          at === Se && (at = 0),
            We === Se && (We = 0),
            (ee[Le] = k(ge[Le], ge[at], ge[We]));
        H.push(ee), (ae = ae.concat(ee));
      }
      for (let V = 0; V < f; V++) {
        const be = V / f,
          ge = S * Math.cos((be * Math.PI) / 2),
          Le = x * Math.sin((be * Math.PI) / 2) + _;
        for (let Se = 0, at = F.length; Se < at; Se++) {
          const We = X(F[Se], W[Se], Le);
          Ce(We.x, We.y, -ge);
        }
        for (let Se = 0, at = I.length; Se < at; Se++) {
          const We = I[Se];
          ee = H[Se];
          for (let U = 0, D = We.length; U < D; U++) {
            const le = X(We[U], ee[U], Le);
            Ce(le.x, le.y, -ge);
          }
        }
      }
      const xe = x + _;
      for (let V = 0; V < G; V++) {
        const be = y ? X(P[V], ae[V], xe) : P[V];
        w
          ? (A.copy(T.normals[0]).multiplyScalar(be.x),
            C.copy(T.binormals[0]).multiplyScalar(be.y),
            L.copy(g[0]).add(A).add(C),
            Ce(L.x, L.y, L.z))
          : Ce(be.x, be.y, 0);
      }
      for (let V = 1; V <= p; V++)
        for (let be = 0; be < G; be++) {
          const ge = y ? X(P[be], ae[be], xe) : P[be];
          w
            ? (A.copy(T.normals[V]).multiplyScalar(ge.x),
              C.copy(T.binormals[V]).multiplyScalar(ge.y),
              L.copy(g[V]).add(A).add(C),
              Ce(L.x, L.y, L.z))
            : Ce(ge.x, ge.y, (v / p) * V);
        }
      for (let V = f - 1; V >= 0; V--) {
        const be = V / f,
          ge = S * Math.cos((be * Math.PI) / 2),
          Le = x * Math.sin((be * Math.PI) / 2) + _;
        for (let Se = 0, at = F.length; Se < at; Se++) {
          const We = X(F[Se], W[Se], Le);
          Ce(We.x, We.y, v + ge);
        }
        for (let Se = 0, at = I.length; Se < at; Se++) {
          const We = I[Se];
          ee = H[Se];
          for (let U = 0, D = We.length; U < D; U++) {
            const le = X(We[U], ee[U], Le);
            w
              ? Ce(le.x, le.y + g[p - 1].y, g[p - 1].x + ge)
              : Ce(le.x, le.y, v + ge);
          }
        }
      }
      te(), de();
      function te() {
        const V = r.length / 3;
        if (y) {
          let be = 0,
            ge = G * be;
          for (let Le = 0; Le < ne; Le++) {
            const Se = ue[Le];
            Ze(Se[2] + ge, Se[1] + ge, Se[0] + ge);
          }
          (be = p + f * 2), (ge = G * be);
          for (let Le = 0; Le < ne; Le++) {
            const Se = ue[Le];
            Ze(Se[0] + ge, Se[1] + ge, Se[2] + ge);
          }
        } else {
          for (let be = 0; be < ne; be++) {
            const ge = ue[be];
            Ze(ge[2], ge[1], ge[0]);
          }
          for (let be = 0; be < ne; be++) {
            const ge = ue[be];
            Ze(ge[0] + G * p, ge[1] + G * p, ge[2] + G * p);
          }
        }
        i.addGroup(V, r.length / 3 - V, 0);
      }
      function de() {
        const V = r.length / 3;
        let be = 0;
        ye(F, be), (be += F.length);
        for (let ge = 0, Le = I.length; ge < Le; ge++) {
          const Se = I[ge];
          ye(Se, be), (be += Se.length);
        }
        i.addGroup(V, r.length / 3 - V, 1);
      }
      function ye(V, be) {
        let ge = V.length;
        for (; --ge >= 0; ) {
          const Le = ge;
          let Se = ge - 1;
          Se < 0 && (Se = V.length - 1);
          for (let at = 0, We = p + f * 2; at < We; at++) {
            const U = G * at,
              D = G * (at + 1),
              le = be + Le + U,
              Re = be + Se + U,
              Ee = be + Se + D,
              Te = be + Le + D;
            ze(le, Re, Ee, Te);
          }
        }
      }
      function Ce(V, be, ge) {
        u.push(V), u.push(be), u.push(ge);
      }
      function Ze(V, be, ge) {
        tt(V), tt(be), tt(ge);
        const Le = r.length / 3,
          Se = m.generateTopUV(i, r, Le - 3, Le - 2, Le - 1);
        Ge(Se[0]), Ge(Se[1]), Ge(Se[2]);
      }
      function ze(V, be, ge, Le) {
        tt(V), tt(be), tt(Le), tt(be), tt(ge), tt(Le);
        const Se = r.length / 3,
          at = m.generateSideWallUV(i, r, Se - 6, Se - 3, Se - 2, Se - 1);
        Ge(at[0]), Ge(at[1]), Ge(at[3]), Ge(at[1]), Ge(at[2]), Ge(at[3]);
      }
      function tt(V) {
        r.push(u[V * 3 + 0]), r.push(u[V * 3 + 1]), r.push(u[V * 3 + 2]);
      }
      function Ge(V) {
        s.push(V.x), s.push(V.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return X5(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new Hg[r.type]().fromJSON(r)),
      new Lv(i, e.options)
    );
  }
}
const j5 = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      u = e[i * 3 + 1],
      h = e[r * 3],
      p = e[r * 3 + 1];
    return [new Me(s, o), new Me(a, u), new Me(h, p)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      u = e[t * 3 + 2],
      h = e[i * 3],
      p = e[i * 3 + 1],
      v = e[i * 3 + 2],
      y = e[r * 3],
      S = e[r * 3 + 1],
      x = e[r * 3 + 2],
      _ = e[s * 3],
      f = e[s * 3 + 1],
      d = e[s * 3 + 2];
    return Math.abs(a - p) < Math.abs(o - h)
      ? [new Me(o, 1 - u), new Me(h, 1 - v), new Me(y, 1 - x), new Me(_, 1 - d)]
      : [
          new Me(a, 1 - u),
          new Me(p, 1 - v),
          new Me(S, 1 - x),
          new Me(f, 1 - d),
        ];
  },
};
function X5(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Iv extends Oa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Iv(e.radius, e.detail);
  }
}
class Tf extends Oa {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Tf(e.radius, e.detail);
  }
}
class Ov extends Rt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r));
    const a = [],
      u = [],
      h = [],
      p = [];
    let v = e;
    const y = (t - e) / r,
      S = new B(),
      x = new Me();
    for (let _ = 0; _ <= r; _++) {
      for (let f = 0; f <= i; f++) {
        const d = s + (f / i) * o;
        (S.x = v * Math.cos(d)),
          (S.y = v * Math.sin(d)),
          u.push(S.x, S.y, S.z),
          h.push(0, 0, 1),
          (x.x = (S.x / t + 1) / 2),
          (x.y = (S.y / t + 1) / 2),
          p.push(x.x, x.y);
      }
      v += y;
    }
    for (let _ = 0; _ < r; _++) {
      const f = _ * (i + 1);
      for (let d = 0; d < i; d++) {
        const m = d + f,
          g = m,
          w = m + i + 1,
          T = m + i + 2,
          C = m + 1;
        a.push(g, w, C), a.push(w, T, C);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new lt(u, 3)),
      this.setAttribute("normal", new lt(h, 3)),
      this.setAttribute("uv", new lt(p, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ov(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Nv extends Rt {
  constructor(
    e = new Nl([new Me(0, 0.5), new Me(-0.5, -0.5), new Me(0.5, -0.5)]),
    t = 12,
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      u = 0;
    if (Array.isArray(e) === !1) h(e);
    else
      for (let p = 0; p < e.length; p++)
        h(e[p]), this.addGroup(a, u, p), (a += u), (u = 0);
    this.setIndex(i),
      this.setAttribute("position", new lt(r, 3)),
      this.setAttribute("normal", new lt(s, 3)),
      this.setAttribute("uv", new lt(o, 2));
    function h(p) {
      const v = r.length / 3,
        y = p.extractPoints(t);
      let S = y.shape;
      const x = y.holes;
      Ns.isClockWise(S) === !1 && (S = S.reverse());
      for (let f = 0, d = x.length; f < d; f++) {
        const m = x[f];
        Ns.isClockWise(m) === !0 && (x[f] = m.reverse());
      }
      const _ = Ns.triangulateShape(S, x);
      for (let f = 0, d = x.length; f < d; f++) {
        const m = x[f];
        S = S.concat(m);
      }
      for (let f = 0, d = S.length; f < d; f++) {
        const m = S[f];
        r.push(m.x, m.y, 0), s.push(0, 0, 1), o.push(m.x, m.y);
      }
      for (let f = 0, d = _.length; f < d; f++) {
        const m = _[f],
          g = m[0] + v,
          w = m[1] + v,
          T = m[2] + v;
        i.push(g, w, T), (u += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return q5(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new Nv(i, e.curveSegments);
  }
}
function q5(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Cf extends Rt {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI,
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const u = Math.min(o + a, Math.PI);
    let h = 0;
    const p = [],
      v = new B(),
      y = new B(),
      S = [],
      x = [],
      _ = [],
      f = [];
    for (let d = 0; d <= i; d++) {
      const m = [],
        g = d / i;
      let w = 0;
      d === 0 && o === 0
        ? (w = 0.5 / t)
        : d === i && u === Math.PI && (w = -0.5 / t);
      for (let T = 0; T <= t; T++) {
        const C = T / t;
        (v.x = -e * Math.cos(r + C * s) * Math.sin(o + g * a)),
          (v.y = e * Math.cos(o + g * a)),
          (v.z = e * Math.sin(r + C * s) * Math.sin(o + g * a)),
          x.push(v.x, v.y, v.z),
          y.copy(v).normalize(),
          _.push(y.x, y.y, y.z),
          f.push(C + w, 1 - g),
          m.push(h++);
      }
      p.push(m);
    }
    for (let d = 0; d < i; d++)
      for (let m = 0; m < t; m++) {
        const g = p[d][m + 1],
          w = p[d][m],
          T = p[d + 1][m],
          C = p[d + 1][m + 1];
        (d !== 0 || o > 0) && S.push(g, w, C),
          (d !== i - 1 || u < Math.PI) && S.push(w, T, C);
      }
    this.setIndex(S),
      this.setAttribute("position", new lt(x, 3)),
      this.setAttribute("normal", new lt(_, 3)),
      this.setAttribute("uv", new lt(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Cf(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Dv extends Oa {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Dv(e.radius, e.detail);
  }
}
class kv extends Rt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const o = [],
      a = [],
      u = [],
      h = [],
      p = new B(),
      v = new B(),
      y = new B();
    for (let S = 0; S <= i; S++)
      for (let x = 0; x <= r; x++) {
        const _ = (x / r) * s,
          f = (S / i) * Math.PI * 2;
        (v.x = (e + t * Math.cos(f)) * Math.cos(_)),
          (v.y = (e + t * Math.cos(f)) * Math.sin(_)),
          (v.z = t * Math.sin(f)),
          a.push(v.x, v.y, v.z),
          (p.x = e * Math.cos(_)),
          (p.y = e * Math.sin(_)),
          y.subVectors(v, p).normalize(),
          u.push(y.x, y.y, y.z),
          h.push(x / r),
          h.push(S / i);
      }
    for (let S = 1; S <= i; S++)
      for (let x = 1; x <= r; x++) {
        const _ = (r + 1) * S + x - 1,
          f = (r + 1) * (S - 1) + x - 1,
          d = (r + 1) * (S - 1) + x,
          m = (r + 1) * S + x;
        o.push(_, f, m), o.push(f, d, m);
      }
    this.setIndex(o),
      this.setAttribute("position", new lt(a, 3)),
      this.setAttribute("normal", new lt(u, 3)),
      this.setAttribute("uv", new lt(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new kv(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Uv extends Rt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const a = [],
      u = [],
      h = [],
      p = [],
      v = new B(),
      y = new B(),
      S = new B(),
      x = new B(),
      _ = new B(),
      f = new B(),
      d = new B();
    for (let g = 0; g <= i; ++g) {
      const w = (g / i) * s * Math.PI * 2;
      m(w, s, o, e, S),
        m(w + 0.01, s, o, e, x),
        f.subVectors(x, S),
        d.addVectors(x, S),
        _.crossVectors(f, d),
        d.crossVectors(_, f),
        _.normalize(),
        d.normalize();
      for (let T = 0; T <= r; ++T) {
        const C = (T / r) * Math.PI * 2,
          A = -t * Math.cos(C),
          L = t * Math.sin(C);
        (v.x = S.x + (A * d.x + L * _.x)),
          (v.y = S.y + (A * d.y + L * _.y)),
          (v.z = S.z + (A * d.z + L * _.z)),
          u.push(v.x, v.y, v.z),
          y.subVectors(v, S).normalize(),
          h.push(y.x, y.y, y.z),
          p.push(g / i),
          p.push(T / r);
      }
    }
    for (let g = 1; g <= i; g++)
      for (let w = 1; w <= r; w++) {
        const T = (r + 1) * (g - 1) + (w - 1),
          C = (r + 1) * g + (w - 1),
          A = (r + 1) * g + w,
          L = (r + 1) * (g - 1) + w;
        a.push(T, C, L), a.push(C, A, L);
      }
    this.setIndex(a),
      this.setAttribute("position", new lt(u, 3)),
      this.setAttribute("normal", new lt(h, 3)),
      this.setAttribute("uv", new lt(p, 2));
    function m(g, w, T, C, A) {
      const L = Math.cos(g),
        N = Math.sin(g),
        P = (T / w) * g,
        I = Math.cos(P);
      (A.x = C * (2 + I) * 0.5 * L),
        (A.y = C * (2 + I) * N * 0.5),
        (A.z = C * Math.sin(P) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Uv(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q,
    );
  }
}
class Fv extends Rt {
  constructor(
    e = new Yw(new B(-1, -1, 0), new B(-1, 1, 0), new B(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1,
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new B(),
      u = new B(),
      h = new Me();
    let p = new B();
    const v = [],
      y = [],
      S = [],
      x = [];
    _(),
      this.setIndex(x),
      this.setAttribute("position", new lt(v, 3)),
      this.setAttribute("normal", new lt(y, 3)),
      this.setAttribute("uv", new lt(S, 2));
    function _() {
      for (let g = 0; g < t; g++) f(g);
      f(s === !1 ? t : 0), m(), d();
    }
    function f(g) {
      p = e.getPointAt(g / t, p);
      const w = o.normals[g],
        T = o.binormals[g];
      for (let C = 0; C <= r; C++) {
        const A = (C / r) * Math.PI * 2,
          L = Math.sin(A),
          N = -Math.cos(A);
        (u.x = N * w.x + L * T.x),
          (u.y = N * w.y + L * T.y),
          (u.z = N * w.z + L * T.z),
          u.normalize(),
          y.push(u.x, u.y, u.z),
          (a.x = p.x + i * u.x),
          (a.y = p.y + i * u.y),
          (a.z = p.z + i * u.z),
          v.push(a.x, a.y, a.z);
      }
    }
    function d() {
      for (let g = 1; g <= t; g++)
        for (let w = 1; w <= r; w++) {
          const T = (r + 1) * (g - 1) + (w - 1),
            C = (r + 1) * g + (w - 1),
            A = (r + 1) * g + w,
            L = (r + 1) * (g - 1) + w;
          x.push(T, C, L), x.push(C, A, L);
        }
    }
    function m() {
      for (let g = 0; g <= t; g++)
        for (let w = 0; w <= r; w++)
          (h.x = g / t), (h.y = w / r), S.push(h.x, h.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new Fv(
      new Hg[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed,
    );
  }
}
class qR extends Rt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new B(),
        s = new B();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let u = e.groups;
        u.length === 0 &&
          (u = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let h = 0, p = u.length; h < p; ++h) {
          const v = u[h],
            y = v.start,
            S = v.count;
          for (let x = y, _ = y + S; x < _; x += 3)
            for (let f = 0; f < 3; f++) {
              const d = a.getX(x + f),
                m = a.getX(x + ((f + 1) % 3));
              r.fromBufferAttribute(o, d),
                s.fromBufferAttribute(o, m),
                EC(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, u = o.count / 3; a < u; a++)
          for (let h = 0; h < 3; h++) {
            const p = 3 * a + h,
              v = 3 * a + ((h + 1) % 3);
            r.fromBufferAttribute(o, p),
              s.fromBufferAttribute(o, v),
              EC(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new lt(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function EC(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var TC = Object.freeze({
  __proto__: null,
  BoxGeometry: ql,
  CapsuleGeometry: Cv,
  CircleGeometry: bv,
  ConeGeometry: Av,
  CylinderGeometry: Yc,
  DodecahedronGeometry: Pv,
  EdgesGeometry: GR,
  ExtrudeGeometry: Lv,
  IcosahedronGeometry: Iv,
  LatheGeometry: Ef,
  OctahedronGeometry: Tf,
  PlaneGeometry: qc,
  PolyhedronGeometry: Oa,
  RingGeometry: Ov,
  ShapeGeometry: Nv,
  SphereGeometry: Cf,
  TetrahedronGeometry: Dv,
  TorusGeometry: kv,
  TorusKnotGeometry: Uv,
  TubeGeometry: Fv,
  WireframeGeometry: qR,
});
class $R extends ci {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Qe(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class YR extends ls {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Qw extends ci {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Qe(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class KR extends Qw {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Me(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return An((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Qe(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Qe(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Qe(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class QR extends ci {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Qe(16777215)),
      (this.specular = new Qe(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = vf),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ZR extends ci {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class JR extends ci {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class Bv extends ci {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Qe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Qe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = vf),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class eL extends ci {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Qe(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = La),
      (this.normalScale = new Me(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class tL extends Hi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function vl(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(n)
      : Array.prototype.slice.call(n);
}
function nL(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function iL(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function hS(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let u = 0; u !== e; ++u) r[o++] = n[a + u];
  }
  return r;
}
function Zw(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
function $5(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let u = 0; u < s.tracks.length; ++u) {
    const h = s.tracks[u],
      p = h.getValueSize(),
      v = [],
      y = [];
    for (let S = 0; S < h.times.length; ++S) {
      const x = h.times[S] * r;
      if (!(x < t || x >= i)) {
        v.push(h.times[S]);
        for (let _ = 0; _ < p; ++_) y.push(h.values[S * p + _]);
      }
    }
    v.length !== 0 &&
      ((h.times = vl(v, h.times.constructor)),
      (h.values = vl(y, h.values.constructor)),
      o.push(h));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let u = 0; u < s.tracks.length; ++u)
    a > s.tracks[u].times[0] && (a = s.tracks[u].times[0]);
  for (let u = 0; u < s.tracks.length; ++u) s.tracks[u].shift(-1 * a);
  return s.resetDuration(), s;
}
function Y5(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      u = a.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const h = n.tracks.find(function (d) {
      return d.name === a.name && d.ValueTypeName === u;
    });
    if (h === void 0) continue;
    let p = 0;
    const v = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = v / 3);
    let y = 0;
    const S = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (y = S / 3);
    const x = a.times.length - 1;
    let _;
    if (s <= a.times[0]) {
      const d = p,
        m = v - p;
      _ = a.values.slice(d, m);
    } else if (s >= a.times[x]) {
      const d = x * v + p,
        m = d + v - p;
      _ = a.values.slice(d, m);
    } else {
      const d = a.createInterpolant(),
        m = p,
        g = v - p;
      d.evaluate(s), (_ = d.resultBuffer.slice(m, g));
    }
    u === "quaternion" &&
      new li().fromArray(_).normalize().conjugate().toArray(_);
    const f = h.times.length;
    for (let d = 0; d < f; ++d) {
      const m = d * S + y;
      if (u === "quaternion")
        li.multiplyQuaternionsFlat(h.values, m, _, 0, h.values, m);
      else {
        const g = S - y * 2;
        for (let w = 0; w < g; ++w) h.values[m + w] -= _[w];
      }
    }
  }
  return (n.blendMode = Rw), n;
}
const K5 = {
  convertArray: vl,
  isTypedArray: nL,
  getKeyframeOrder: iL,
  sortedArray: hS,
  flattenJSON: Zw,
  subclip: $5,
  makeClipAdditive: Y5,
};
class bf {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let u = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === u) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class rL extends bf {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: pl, endingEnd: pl });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      u = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case ml:
          (s = e), (a = 2 * t - i);
          break;
        case Nh:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case ml:
          (o = e), (u = 2 * i - t);
          break;
        case Nh:
          (o = 1), (u = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (u = t);
      }
    const h = (i - t) * 0.5,
      p = this.valueSize;
    (this._weightPrev = h / (t - a)),
      (this._weightNext = h / (u - i)),
      (this._offsetPrev = s * p),
      (this._offsetNext = o * p);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      h = u - a,
      p = this._offsetPrev,
      v = this._offsetNext,
      y = this._weightPrev,
      S = this._weightNext,
      x = (i - t) / (r - t),
      _ = x * x,
      f = _ * x,
      d = -y * f + 2 * y * _ - y * x,
      m = (1 + y) * f + (-1.5 - 2 * y) * _ + (-0.5 + y) * x + 1,
      g = (-1 - S) * f + (1.5 + S) * _ + 0.5 * x,
      w = S * f - S * _;
    for (let T = 0; T !== a; ++T)
      s[T] = d * o[p + T] + m * o[h + T] + g * o[u + T] + w * o[v + T];
    return s;
  }
}
class Jw extends bf {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = e * a,
      h = u - a,
      p = (i - t) / (r - t),
      v = 1 - p;
    for (let y = 0; y !== a; ++y) s[y] = o[h + y] * v + o[u + y] * p;
    return s;
  }
}
class sL extends bf {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class cs {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = vl(t, this.TimeBufferType)),
      (this.values = vl(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: vl(e.times, Array),
        values: vl(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new sL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Jw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new rL(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Ih:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Oh:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case rg:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Ih;
      case this.InterpolantFactoryMethodLinear:
        return Oh;
      case this.InterpolantFactoryMethodSmooth:
        return rg;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const u = i[a];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          u,
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, u, o),
          (e = !1);
        break;
      }
      o = u;
    }
    if (r !== void 0 && nL(r))
      for (let a = 0, u = r.length; a !== u; ++a) {
        const h = r[a];
        if (isNaN(h)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            h,
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === rg,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let u = !1;
      const h = e[a],
        p = e[a + 1];
      if (h !== p && (a !== 1 || h !== e[0]))
        if (r) u = !0;
        else {
          const v = a * i,
            y = v - i,
            S = v + i;
          for (let x = 0; x !== i; ++x) {
            const _ = t[v + x];
            if (_ !== t[y + x] || _ !== t[S + x]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (a !== o) {
          e[o] = e[a];
          const v = a * i,
            y = o * i;
          for (let S = 0; S !== i; ++S) t[y + S] = t[v + S];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, u = o * i, h = 0; h !== i; ++h) t[u + h] = t[a + h];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
cs.prototype.TimeBufferType = Float32Array;
cs.prototype.ValueBufferType = Float32Array;
cs.prototype.DefaultInterpolation = Oh;
class $l extends cs {}
$l.prototype.ValueTypeName = "bool";
$l.prototype.ValueBufferType = Array;
$l.prototype.DefaultInterpolation = Ih;
$l.prototype.InterpolantFactoryMethodLinear = void 0;
$l.prototype.InterpolantFactoryMethodSmooth = void 0;
class e1 extends cs {}
e1.prototype.ValueTypeName = "color";
class jh extends cs {}
jh.prototype.ValueTypeName = "number";
class oL extends bf {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      u = (i - t) / (r - t);
    let h = e * a;
    for (let p = h + a; h !== p; h += 4) li.slerpFlat(s, 0, o, h - a, o, h, u);
    return s;
  }
}
class Kc extends cs {
  InterpolantFactoryMethodLinear(e) {
    return new oL(this.times, this.values, this.getValueSize(), e);
  }
}
Kc.prototype.ValueTypeName = "quaternion";
Kc.prototype.DefaultInterpolation = Oh;
Kc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Yl extends cs {}
Yl.prototype.ValueTypeName = "string";
Yl.prototype.ValueBufferType = Array;
Yl.prototype.DefaultInterpolation = Ih;
Yl.prototype.InterpolantFactoryMethodLinear = void 0;
Yl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Xh extends cs {}
Xh.prototype.ValueTypeName = "vector";
class qh {
  constructor(e, t = -1, i, r = mv) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = gr()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(Z5(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(cs.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let u = [],
        h = [];
      u.push((a + s - 1) % s, a, (a + 1) % s), h.push(0, 1, 0);
      const p = iL(u);
      (u = hS(u, 1, p)),
        (h = hS(h, 1, p)),
        !r && u[0] === 0 && (u.push(s), h.push(h[0])),
        o.push(
          new jh(".morphTargetInfluences[" + t[a].name + "]", u, h).scale(
            1 / i,
          ),
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, u = e.length; a < u; a++) {
      const h = e[a],
        p = h.name.match(s);
      if (p && p.length > 1) {
        const v = p[1];
        let y = r[v];
        y || (r[v] = y = []), y.push(h);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (v, y, S, x, _) {
        if (S.length !== 0) {
          const f = [],
            d = [];
          Zw(S, f, d, x), f.length !== 0 && _.push(new v(y, f, d));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let u = e.length || -1;
    const h = e.hierarchy || [];
    for (let v = 0; v < h.length; v++) {
      const y = h[v].keys;
      if (!(!y || y.length === 0))
        if (y[0].morphTargets) {
          const S = {};
          let x;
          for (x = 0; x < y.length; x++)
            if (y[x].morphTargets)
              for (let _ = 0; _ < y[x].morphTargets.length; _++)
                S[y[x].morphTargets[_]] = -1;
          for (const _ in S) {
            const f = [],
              d = [];
            for (let m = 0; m !== y[x].morphTargets.length; ++m) {
              const g = y[x];
              f.push(g.time), d.push(g.morphTarget === _ ? 1 : 0);
            }
            r.push(new jh(".morphTargetInfluence[" + _ + "]", f, d));
          }
          u = S.length * o;
        } else {
          const S = ".bones[" + t[v].name + "]";
          i(Xh, S + ".position", y, "pos", r),
            i(Kc, S + ".quaternion", y, "rot", r),
            i(Xh, S + ".scale", y, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, u, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Q5(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return jh;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Xh;
    case "color":
      return e1;
    case "quaternion":
      return Kc;
    case "bool":
    case "boolean":
      return $l;
    case "string":
      return Yl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function Z5(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Q5(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    Zw(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const oo = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class t1 {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      u;
    const h = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (p) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(p, o, a), (s = !0);
      }),
      (this.itemEnd = function (p) {
        o++,
          r.onProgress !== void 0 && r.onProgress(p, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (p) {
        r.onError !== void 0 && r.onError(p);
      }),
      (this.resolveURL = function (p) {
        return u ? u(p) : p;
      }),
      (this.setURLModifier = function (p) {
        return (u = p), this;
      }),
      (this.addHandler = function (p, v) {
        return h.push(p, v), this;
      }),
      (this.removeHandler = function (p) {
        const v = h.indexOf(p);
        return v !== -1 && h.splice(v, 2), this;
      }),
      (this.getHandler = function (p) {
        for (let v = 0, y = h.length; v < y; v += 2) {
          const S = h[v],
            x = h[v + 1];
          if ((S.global && (S.lastIndex = 0), S.test(p))) return x;
        }
        return null;
      });
  }
}
const aL = new t1();
class Ji {
  constructor(e) {
    (this.manager = e !== void 0 ? e : aL),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
Ji.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Zs = {};
class J5 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class yo extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = oo.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Zs[e] !== void 0) {
      Zs[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (Zs[e] = []), Zs[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      u = this.responseType;
    fetch(o)
      .then((h) => {
        if (h.status === 200 || h.status === 0) {
          if (
            (h.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              h.body === void 0 ||
              h.body.getReader === void 0)
          )
            return h;
          const p = Zs[e],
            v = h.body.getReader(),
            y = h.headers.get("Content-Length") || h.headers.get("X-File-Size"),
            S = y ? parseInt(y) : 0,
            x = S !== 0;
          let _ = 0;
          const f = new ReadableStream({
            start(d) {
              m();
              function m() {
                v.read().then(({ done: g, value: w }) => {
                  if (g) d.close();
                  else {
                    _ += w.byteLength;
                    const T = new ProgressEvent("progress", {
                      lengthComputable: x,
                      loaded: _,
                      total: S,
                    });
                    for (let C = 0, A = p.length; C < A; C++) {
                      const L = p[C];
                      L.onProgress && L.onProgress(T);
                    }
                    d.enqueue(w), m();
                  }
                });
              }
            },
          });
          return new Response(f);
        } else
          throw new J5(
            `fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,
            h,
          );
      })
      .then((h) => {
        switch (u) {
          case "arraybuffer":
            return h.arrayBuffer();
          case "blob":
            return h.blob();
          case "document":
            return h.text().then((p) => new DOMParser().parseFromString(p, a));
          case "json":
            return h.json();
          default:
            if (a === void 0) return h.text();
            {
              const v = /charset="?([^;"\s]*)"?/i.exec(a),
                y = v && v[1] ? v[1].toLowerCase() : void 0,
                S = new TextDecoder(y);
              return h.arrayBuffer().then((x) => S.decode(x));
            }
        }
      })
      .then((h) => {
        oo.add(e, h);
        const p = Zs[e];
        delete Zs[e];
        for (let v = 0, y = p.length; v < y; v++) {
          const S = p[v];
          S.onLoad && S.onLoad(h);
        }
      })
      .catch((h) => {
        const p = Zs[e];
        if (p === void 0) throw (this.manager.itemError(e), h);
        delete Zs[e];
        for (let v = 0, y = p.length; v < y; v++) {
          const S = p[v];
          S.onError && S.onError(h);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class eV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new yo(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r,
      );
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = qh.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class tV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new Ev(),
      u = new yo(this.manager);
    u.setPath(this.path),
      u.setResponseType("arraybuffer"),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(s.withCredentials);
    let h = 0;
    function p(v) {
      u.load(
        e[v],
        function (y) {
          const S = s.parse(y, !0);
          (o[v] = {
            width: S.width,
            height: S.height,
            format: S.format,
            mipmaps: S.mipmaps,
          }),
            (h += 1),
            h === 6 &&
              (S.mipmapCount === 1 && (a.minFilter = xn),
              (a.image = o),
              (a.format = S.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        i,
        r,
      );
    }
    if (Array.isArray(e)) for (let v = 0, y = e.length; v < y; ++v) p(v);
    else
      u.load(
        e,
        function (v) {
          const y = s.parse(v, !0);
          if (y.isCubemap) {
            const S = y.mipmaps.length / y.mipmapCount;
            for (let x = 0; x < S; x++) {
              o[x] = { mipmaps: [] };
              for (let _ = 0; _ < y.mipmapCount; _++)
                o[x].mipmaps.push(y.mipmaps[x * y.mipmapCount + _]),
                  (o[x].format = y.format),
                  (o[x].width = y.width),
                  (o[x].height = y.height);
            }
            a.image = o;
          } else
            (a.image.width = y.width),
              (a.image.height = y.height),
              (a.mipmaps = y.mipmaps);
          y.mipmapCount === 1 && (a.minFilter = xn),
            (a.format = y.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        i,
        r,
      );
    return a;
  }
}
class $h extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = oo.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = zh("img");
    function u() {
      p(), oo.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function h(v) {
      p(), r && r(v), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function p() {
      a.removeEventListener("load", u, !1),
        a.removeEventListener("error", h, !1);
    }
    return (
      a.addEventListener("load", u, !1),
      a.addEventListener("error", h, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class nV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Sf();
    s.colorSpace = Wn;
    const o = new $h(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function u(h) {
      o.load(
        e[h],
        function (p) {
          (s.images[h] = p), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        r,
      );
    }
    for (let h = 0; h < e.length; ++h) u(h);
    return s;
  }
}
class iV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ol(),
      a = new yo(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (u) {
          let h;
          try {
            h = s.parse(u);
          } catch (p) {
            if (r !== void 0) r(p);
            else {
              console.error(p);
              return;
            }
          }
          h.image !== void 0
            ? (o.image = h.image)
            : h.data !== void 0 &&
              ((o.image.width = h.width),
              (o.image.height = h.height),
              (o.image.data = h.data)),
            (o.wrapS = h.wrapS !== void 0 ? h.wrapS : Mi),
            (o.wrapT = h.wrapT !== void 0 ? h.wrapT : Mi),
            (o.magFilter = h.magFilter !== void 0 ? h.magFilter : xn),
            (o.minFilter = h.minFilter !== void 0 ? h.minFilter : xn),
            (o.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1),
            h.colorSpace !== void 0
              ? (o.colorSpace = h.colorSpace)
              : h.encoding !== void 0 && (o.encoding = h.encoding),
            h.flipY !== void 0 && (o.flipY = h.flipY),
            h.format !== void 0 && (o.format = h.format),
            h.type !== void 0 && (o.type = h.type),
            h.mipmaps !== void 0 &&
              ((o.mipmaps = h.mipmaps), (o.minFilter = As)),
            h.mipmapCount === 1 && (o.minFilter = xn),
            h.generateMipmaps !== void 0 &&
              (o.generateMipmaps = h.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, h);
        },
        i,
        r,
      ),
      o
    );
  }
}
class zv extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Mn(),
      o = new $h(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r,
      ),
      s
    );
  }
}
class Na extends Kt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Qe(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class lL extends Na {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Kt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Qe(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const t_ = new _t(),
  CC = new B(),
  bC = new B();
class n1 {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Me(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new _t()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new wf()),
      (this._frameExtents = new Me(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new rn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    CC.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(CC),
      bC.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(bC),
      t.updateMatrixWorld(),
      t_.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(t_),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(t_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class rV extends n1 {
  constructor() {
    super(new ei(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = Fc * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class uL extends Na {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Kt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Kt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new rV());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const AC = new _t(),
  Od = new B(),
  n_ = new B();
class sV extends n1 {
  constructor() {
    super(new ei(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Me(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new rn(2, 1, 1, 1),
        new rn(0, 1, 1, 1),
        new rn(3, 1, 1, 1),
        new rn(1, 1, 1, 1),
        new rn(3, 0, 1, 1),
        new rn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new B(1, 0, 0),
        new B(-1, 0, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
        new B(0, 1, 0),
        new B(0, -1, 0),
      ]),
      (this._cubeUps = [
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Od.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Od),
      n_.copy(i.position),
      n_.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(n_),
      i.updateMatrixWorld(),
      r.makeTranslation(-Od.x, -Od.y, -Od.z),
      AC.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(AC);
  }
}
class cL extends Na {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new sV());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class oV extends n1 {
  constructor() {
    super(new Mf(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class dL extends Na {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Kt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Kt()),
      (this.shadow = new oV());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class hL extends Na {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class fL extends Na {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class pL {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new B());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r));
  }
}
class mL extends Na {
  constructor(e = new pL(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class Hv extends Ji {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, i, r) {
    const s = this,
      o = new yo(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r,
      );
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = Hv.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Qe().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Qe().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new Me().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new B().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new rn().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new Nt().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new _t().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new Me().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new Me().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: $R,
      SpriteMaterial: Gw,
      RawShaderMaterial: YR,
      ShaderMaterial: ls,
      PointsMaterial: Mv,
      MeshPhysicalMaterial: KR,
      MeshStandardMaterial: Qw,
      MeshPhongMaterial: QR,
      MeshToonMaterial: ZR,
      MeshNormalMaterial: JR,
      MeshLambertMaterial: Bv,
      MeshDepthMaterial: zw,
      MeshDistanceMaterial: Hw,
      MeshBasicMaterial: Ia,
      MeshMatcapMaterial: eL,
      LineDashedMaterial: tL,
      LineBasicMaterial: Hi,
      Material: ci,
    };
    return new t[e]();
  }
}
class fS {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class gL extends Rt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class vL extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new yo(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (u) {
            r ? r(u) : console.error(u), s.manager.itemError(e);
          }
        },
        i,
        r,
      );
  }
  parse(e) {
    const t = {},
      i = {};
    function r(S, x) {
      if (t[x] !== void 0) return t[x];
      const f = S.interleavedBuffers[x],
        d = s(S, f.buffer),
        m = Ju(f.type, d),
        g = new Sv(m, f.stride);
      return (g.uuid = f.uuid), (t[x] = g), g;
    }
    function s(S, x) {
      if (i[x] !== void 0) return i[x];
      const f = S.arrayBuffers[x],
        d = new Uint32Array(f).buffer;
      return (i[x] = d), d;
    }
    const o = e.isInstancedBufferGeometry ? new gL() : new Rt(),
      a = e.data.index;
    if (a !== void 0) {
      const S = Ju(a.type, a.array);
      o.setIndex(new Jt(S, 1));
    }
    const u = e.data.attributes;
    for (const S in u) {
      const x = u[S];
      let _;
      if (x.isInterleavedBufferAttribute) {
        const f = r(e.data, x.data);
        _ = new Vl(f, x.itemSize, x.offset, x.normalized);
      } else {
        const f = Ju(x.type, x.array),
          d = x.isInstancedBufferAttribute ? zc : Jt;
        _ = new d(f, x.itemSize, x.normalized);
      }
      x.name !== void 0 && (_.name = x.name),
        x.usage !== void 0 && _.setUsage(x.usage),
        o.setAttribute(S, _);
    }
    const h = e.data.morphAttributes;
    if (h)
      for (const S in h) {
        const x = h[S],
          _ = [];
        for (let f = 0, d = x.length; f < d; f++) {
          const m = x[f];
          let g;
          if (m.isInterleavedBufferAttribute) {
            const w = r(e.data, m.data);
            g = new Vl(w, m.itemSize, m.offset, m.normalized);
          } else {
            const w = Ju(m.type, m.array);
            g = new Jt(w, m.itemSize, m.normalized);
          }
          m.name !== void 0 && (g.name = m.name), _.push(g);
        }
        o.morphAttributes[S] = _;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (let S = 0, x = v.length; S !== x; ++S) {
        const _ = v[S];
        o.addGroup(_.start, _.count, _.materialIndex);
      }
    const y = e.data.boundingSphere;
    if (y !== void 0) {
      const S = new B();
      y.center !== void 0 && S.fromArray(y.center),
        (o.boundingSphere = new Ei(S, y.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class aV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? fS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new yo(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (u) {
          let h = null;
          try {
            h = JSON.parse(u);
          } catch (v) {
            r !== void 0 && r(v),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                v.message,
              );
            return;
          }
          const p = h.metadata;
          if (
            p === void 0 ||
            p.type === void 0 ||
            p.type.toLowerCase() === "geometry"
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(h, t);
        },
        i,
        r,
      );
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? fS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new yo(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      u = a.metadata;
    if (
      u === void 0 ||
      u.type === void 0 ||
      u.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(h);
      }),
      a = this.parseTextures(e.textures, o),
      u = this.parseMaterials(e.materials, a),
      h = this.parseObject(e.object, s, u, a, i),
      p = this.parseSkeletons(e.skeletons, h);
    if ((this.bindSkeletons(h, p), t !== void 0)) {
      let v = !1;
      for (const y in o)
        if (o[y].data instanceof HTMLImageElement) {
          v = !0;
          break;
        }
      v === !1 && t(h);
    }
    return h;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      u = this.parseObject(e.object, r, a, o, t),
      h = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, h), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new Nl().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new wv().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new vL();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const u = e[s];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(u);
            break;
          default:
            u.type in TC
              ? (a = TC[u.type].fromJSON(u, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${u.type}"`,
                );
        }
        (a.uuid = u.uuid),
          u.name !== void 0 && (a.name = u.name),
          u.userData !== void 0 && (a.userData = u.userData),
          (i[u.uuid] = a);
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new Hv();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o];
        i[u.uuid] === void 0 && (i[u.uuid] = s.parse(u)),
          (r[u.uuid] = i[u.uuid]);
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = qh.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(u) {
      return (
        i.manager.itemStart(u),
        s.load(
          u,
          function () {
            i.manager.itemEnd(u);
          },
          void 0,
          function () {
            i.manager.itemError(u), i.manager.itemEnd(u);
          },
        )
      );
    }
    function a(u) {
      if (typeof u == "string") {
        const h = u,
          p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : i.resourcePath + h;
        return o(p);
      } else
        return u.data
          ? { data: Ju(u.type, u.data), width: u.width, height: u.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new t1(t);
      (s = new $h(u)), s.setCrossOrigin(this.crossOrigin);
      for (let h = 0, p = e.length; h < p; h++) {
        const v = e[h],
          y = v.url;
        if (Array.isArray(y)) {
          const S = [];
          for (let x = 0, _ = y.length; x < _; x++) {
            const f = y[x],
              d = a(f);
            d !== null &&
              (d instanceof HTMLImageElement
                ? S.push(d)
                : S.push(new Ol(d.data, d.width, d.height)));
          }
          r[v.uuid] = new gl(S);
        } else {
          const S = a(v.url);
          r[v.uuid] = new gl(S);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(u);
      } else
        return o.data
          ? { data: Ju(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (r = new $h(this.manager)), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o],
          h = u.url;
        if (Array.isArray(h)) {
          const p = [];
          for (let v = 0, y = h.length; v < y; v++) {
            const S = h[v],
              x = await s(S);
            x !== null &&
              (x instanceof HTMLImageElement
                ? p.push(x)
                : p.push(new Ol(x.data, x.width, x.height)));
          }
          i[u.uuid] = new gl(p);
        } else {
          const p = await s(u.url);
          i[u.uuid] = new gl(p);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s,
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const u = t[a.image],
          h = u.data;
        let p;
        Array.isArray(h)
          ? ((p = new Sf()), h.length === 6 && (p.needsUpdate = !0))
          : (h && h.data ? (p = new Ol()) : (p = new Mn()),
            h && (p.needsUpdate = !0)),
          (p.source = u),
          (p.uuid = a.uuid),
          a.name !== void 0 && (p.name = a.name),
          a.mapping !== void 0 && (p.mapping = i(a.mapping, lV)),
          a.channel !== void 0 && (p.channel = a.channel),
          a.offset !== void 0 && p.offset.fromArray(a.offset),
          a.repeat !== void 0 && p.repeat.fromArray(a.repeat),
          a.center !== void 0 && p.center.fromArray(a.center),
          a.rotation !== void 0 && (p.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((p.wrapS = i(a.wrap[0], PC)), (p.wrapT = i(a.wrap[1], PC))),
          a.format !== void 0 && (p.format = a.format),
          a.internalFormat !== void 0 && (p.internalFormat = a.internalFormat),
          a.type !== void 0 && (p.type = a.type),
          a.colorSpace !== void 0 && (p.colorSpace = a.colorSpace),
          a.encoding !== void 0 && (p.encoding = a.encoding),
          a.minFilter !== void 0 && (p.minFilter = i(a.minFilter, RC)),
          a.magFilter !== void 0 && (p.magFilter = i(a.magFilter, RC)),
          a.anisotropy !== void 0 && (p.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (p.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (p.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (p.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (p.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (p.compareFunction = a.compareFunction),
          a.userData !== void 0 && (p.userData = a.userData),
          (r[a.uuid] = p);
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(y) {
      return (
        t[y] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", y),
        t[y]
      );
    }
    function u(y) {
      if (y !== void 0) {
        if (Array.isArray(y)) {
          const S = [];
          for (let x = 0, _ = y.length; x < _; x++) {
            const f = y[x];
            i[f] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", f),
              S.push(i[f]);
          }
          return S;
        }
        return (
          i[y] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", y),
          i[y]
        );
      }
    }
    function h(y) {
      return (
        r[y] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", y),
        r[y]
      );
    }
    let p, v;
    switch (e.type) {
      case "Scene":
        (o = new zg()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Qe(e.background))
              : (o.background = h(e.background))),
          e.environment !== void 0 && (o.environment = h(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new xv(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new _v(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new ei(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Mf(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new hL(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new dL(e.color, e.intensity);
        break;
      case "PointLight":
        o = new cL(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new fL(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new uL(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay,
        );
        break;
      case "HemisphereLight":
        o = new lL(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new mL().fromJSON(e);
        break;
      case "SkinnedMesh":
        (p = a(e.geometry)),
          (v = u(e.material)),
          (o = new OR(p, v)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (p = a(e.geometry)), (v = u(e.material)), (o = new Bn(p, v));
        break;
      case "InstancedMesh":
        (p = a(e.geometry)), (v = u(e.material));
        const y = e.count,
          S = e.instanceMatrix,
          x = e.instanceColor;
        (o = new NR(p, v, y)),
          (o.instanceMatrix = new zc(new Float32Array(S.array), 16)),
          x !== void 0 &&
            (o.instanceColor = new zc(new Float32Array(x.array), x.itemSize));
        break;
      case "BatchedMesh":
        (p = a(e.geometry)),
          (v = u(e.material)),
          (o = new DR(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            v,
          )),
          (o.geometry = p),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((_) => {
            const f = new Fi();
            f.min.fromArray(_.boxMin), f.max.fromArray(_.boxMax);
            const d = new Ei();
            return (
              (d.radius = _.sphereRadius),
              d.center.fromArray(_.sphereCenter),
              {
                boxInitialized: _.boxInitialized,
                box: f,
                sphereInitialized: _.sphereInitialized,
                sphere: d,
              }
            );
          })),
          (o._maxGeometryCount = e.maxGeometryCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = h(e.matricesTexture.uuid));
        break;
      case "LOD":
        o = new IR();
        break;
      case "Line":
        o = new Ta(a(e.geometry), u(e.material));
        break;
      case "LineLoop":
        o = new kR(a(e.geometry), u(e.material));
        break;
      case "LineSegments":
        o = new ks(a(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new UR(a(e.geometry), u(e.material));
        break;
      case "Sprite":
        o = new LR(u(e.material));
        break;
      case "Group":
        o = new nc();
        break;
      case "Bone":
        o = new Ww();
        break;
      default:
        o = new Kt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const y = e.children;
      for (let S = 0; S < y.length; S++)
        o.add(this.parseObject(y[S], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const y = e.animations;
      for (let S = 0; S < y.length; S++) {
        const x = y[S];
        o.animations.push(s[x]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const y = e.levels;
      for (let S = 0; S < y.length; S++) {
        const x = y[S],
          _ = o.getObjectByProperty("uuid", x.object);
        _ !== void 0 && o.addLevel(_, x.distance, x.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton,
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
}
const lV = {
    UVMapping: fv,
    CubeReflectionMapping: vo,
    CubeRefractionMapping: Ea,
    EquirectangularReflectionMapping: Ah,
    EquirectangularRefractionMapping: Ph,
    CubeUVReflectionMapping: jc,
  },
  PC = {
    RepeatWrapping: Rh,
    ClampToEdgeWrapping: Mi,
    MirroredRepeatWrapping: Lh,
  },
  RC = {
    NearestFilter: In,
    NearestMipmapNearestFilter: Ug,
    NearestMipmapLinearFilter: ul,
    LinearFilter: xn,
    LinearMipmapNearestFilter: th,
    LinearMipmapLinearFilter: As,
  };
class uV extends Ji {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = oo.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((h) => {
          t && t(h), s.manager.itemEnd(e);
        }).catch((h) => {
          r && r(h);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const u = fetch(e, a)
      .then(function (h) {
        return h.blob();
      })
      .then(function (h) {
        return createImageBitmap(
          h,
          Object.assign(s.options, { colorSpaceConversion: "none" }),
        );
      })
      .then(function (h) {
        return oo.add(e, h), t && t(h), s.manager.itemEnd(e), h;
      })
      .catch(function (h) {
        r && r(h), oo.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    oo.add(e, u), s.manager.itemStart(e);
  }
}
let Mm;
class i1 {
  static getContext() {
    return (
      Mm === void 0 &&
        (Mm = new (window.AudioContext || window.webkitAudioContext)()),
      Mm
    );
  }
  static setContext(e) {
    Mm = e;
  }
}
class cV extends Ji {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new yo(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (u) {
          try {
            const h = u.slice(0);
            i1.getContext()
              .decodeAudioData(h, function (v) {
                t(v);
              })
              .catch(a);
          } catch (h) {
            a(h);
          }
        },
        i,
        r,
      );
    function a(u) {
      r ? r(u) : console.error(u), s.manager.itemError(e);
    }
  }
}
const LC = new _t(),
  IC = new _t(),
  Ja = new _t();
class dV {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new ei()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new ei()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Ja.copy(e.projectionMatrix);
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(Rl * t.fov * 0.5)) / t.zoom;
      let a, u;
      (IC.elements[12] = -r),
        (LC.elements[12] = r),
        (a = -o * t.aspect + s),
        (u = o * t.aspect + s),
        (Ja.elements[0] = (2 * t.near) / (u - a)),
        (Ja.elements[8] = (u + a) / (u - a)),
        this.cameraL.projectionMatrix.copy(Ja),
        (a = -o * t.aspect - s),
        (u = o * t.aspect - s),
        (Ja.elements[0] = (2 * t.near) / (u - a)),
        (Ja.elements[8] = (u + a) / (u - a)),
        this.cameraR.projectionMatrix.copy(Ja);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(IC),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(LC);
  }
}
class r1 {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = OC()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = OC();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function OC() {
  return (typeof performance > "u" ? Date : performance).now();
}
const el = new B(),
  NC = new li(),
  hV = new B(),
  tl = new B();
class fV extends Kt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = i1.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new r1());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(el, NC, hV),
      tl.set(0, 0, -1).applyQuaternion(NC),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(el.x, r),
        t.positionY.linearRampToValueAtTime(el.y, r),
        t.positionZ.linearRampToValueAtTime(el.z, r),
        t.forwardX.linearRampToValueAtTime(tl.x, r),
        t.forwardY.linearRampToValueAtTime(tl.y, r),
        t.forwardZ.linearRampToValueAtTime(tl.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(el.x, el.y, el.z),
        t.setOrientation(tl.x, tl.y, tl.z, i.x, i.y, i.z);
  }
}
class yL extends Kt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01,
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const nl = new B(),
  DC = new li(),
  pV = new B(),
  il = new B();
class mV extends yL {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(nl, DC, pV), il.set(0, 0, 1).applyQuaternion(DC);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(nl.x, i),
        t.positionY.linearRampToValueAtTime(nl.y, i),
        t.positionZ.linearRampToValueAtTime(nl.z, i),
        t.orientationX.linearRampToValueAtTime(il.x, i),
        t.orientationY.linearRampToValueAtTime(il.y, i),
        t.orientationZ.linearRampToValueAtTime(il.z, i);
    } else t.setPosition(nl.x, nl.y, nl.z), t.setOrientation(il.x, il.y, il.z);
  }
}
class gV {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class _L {
  constructor(e, t, i) {
    (this.binding = e), (this.valueSize = i);
    let r, s, o;
    switch (t) {
      case "quaternion":
        (r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5));
        break;
      default:
        (r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5));
    }
    (this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const u = t * this._origIndex;
      this._mixBufferRegion(i, r, u, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let u = t, h = t + t; u !== h; ++u)
      if (i[u] !== i[u + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    li.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    li.multiplyQuaternionsFlat(e, o, e, t, e, i),
      li.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const u = t + a;
      e[u] = e[u] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const s1 = "\\[\\]\\.:\\/",
  vV = new RegExp("[" + s1 + "]", "g"),
  o1 = "[^" + s1 + "]",
  yV = "[^" + s1.replace("\\.", "") + "]",
  _V = /((?:WC+[\/:])*)/.source.replace("WC", o1),
  xV = /(WCOD+)?/.source.replace("WCOD", yV),
  SV = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", o1),
  wV = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", o1),
  MV = new RegExp("^" + _V + xV + SV + wV + "$"),
  EV = ["material", "materials", "bones", "map"];
class TV {
  constructor(e, t, i) {
    const r = i || Wt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Wt {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || Wt.parseTrackName(t)),
      (this.node = Wt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Wt.Composite(e, t, i)
      : new Wt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(vV, "");
  }
  static parseTrackName(e) {
    const t = MV.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      EV.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e,
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const u = i(a.children);
            if (u) return u;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Wt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          ".",
      );
      return;
    }
    if (i) {
      let h = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this,
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this,
            );
            return;
          }
          e = e.skeleton.bones;
          for (let p = 0; p < e.length; p++)
            if (e[p].name === h) {
              h = p;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this,
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this,
            );
            return;
          }
          e = e[i];
      }
      if (h !== void 0) {
        if (e[h] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e,
          );
          return;
        }
        e = e[h];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const h = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          h +
          "." +
          r +
          " but it wasn't found.",
        e,
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this,
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this,
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
          ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Wt.Composite = TV;
Wt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Wt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Wt.prototype.GetterByBindingType = [
  Wt.prototype._getValue_direct,
  Wt.prototype._getValue_array,
  Wt.prototype._getValue_arrayElement,
  Wt.prototype._getValue_toArray,
];
Wt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Wt.prototype._setValue_direct,
    Wt.prototype._setValue_direct_setNeedsUpdate,
    Wt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_array,
    Wt.prototype._setValue_array_setNeedsUpdate,
    Wt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_arrayElement,
    Wt.prototype._setValue_arrayElement_setNeedsUpdate,
    Wt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_fromArray,
    Wt.prototype._setValue_fromArray_setNeedsUpdate,
    Wt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class CV {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = gr()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      u = e.length,
      h = this.nCachedObjects_;
    for (let p = 0, v = arguments.length; p !== v; ++p) {
      const y = arguments[p],
        S = y.uuid;
      let x = t[S];
      if (x === void 0) {
        (x = u++), (t[S] = x), e.push(y);
        for (let _ = 0, f = o; _ !== f; ++_) s[_].push(new Wt(y, i[_], r[_]));
      } else if (x < h) {
        a = e[x];
        const _ = --h,
          f = e[_];
        (t[f.uuid] = x), (e[x] = f), (t[S] = _), (e[_] = y);
        for (let d = 0, m = o; d !== m; ++d) {
          const g = s[d],
            w = g[_];
          let T = g[x];
          (g[x] = w), T === void 0 && (T = new Wt(y, i[d], r[d])), (g[_] = T);
        }
      } else
        e[x] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
          );
    }
    this.nCachedObjects_ = h;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const u = arguments[o],
        h = u.uuid,
        p = t[h];
      if (p !== void 0 && p >= s) {
        const v = s++,
          y = e[v];
        (t[y.uuid] = p), (e[p] = y), (t[h] = v), (e[v] = u);
        for (let S = 0, x = r; S !== x; ++S) {
          const _ = i[S],
            f = _[v],
            d = _[p];
          (_[p] = f), (_[v] = d);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, u = arguments.length; a !== u; ++a) {
      const h = arguments[a],
        p = h.uuid,
        v = t[p];
      if (v !== void 0)
        if ((delete t[p], v < s)) {
          const y = --s,
            S = e[y],
            x = --o,
            _ = e[x];
          (t[S.uuid] = v), (e[v] = S), (t[_.uuid] = y), (e[y] = _), e.pop();
          for (let f = 0, d = r; f !== d; ++f) {
            const m = i[f],
              g = m[y],
              w = m[x];
            (m[v] = g), (m[y] = w), m.pop();
          }
        } else {
          const y = --o,
            S = e[y];
          y > 0 && (t[S.uuid] = v), (e[v] = S), e.pop();
          for (let x = 0, _ = r; x !== _; ++x) {
            const f = i[x];
            (f[v] = f[y]), f.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      u = this._objects,
      h = u.length,
      p = this.nCachedObjects_,
      v = new Array(h);
    (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(v);
    for (let y = p, S = u.length; y !== S; ++y) {
      const x = u[y];
      v[y] = new Wt(x, e, t);
    }
    return v;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        u = o[a],
        h = e[a];
      (t[h] = i),
        (o[i] = u),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop();
    }
  }
}
class xL {
  constructor(e, t, i = null, r = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      u = { endingStart: pl, endingEnd: pl };
    for (let h = 0; h !== o; ++h) {
      const p = s[h].createInterpolant(null);
      (a[h] = p), (p.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = tR),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const u = a.parameterPositions,
      h = a.sampleValues;
    return (u[0] = s), (u[1] = s + i), (h[0] = e / o), (h[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const u = (e - s) * i;
      u < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * u));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const u = this._interpolants,
        h = this._propertyBindings;
      switch (this.blendMode) {
        case Rw:
          for (let p = 0, v = u.length; p !== v; ++p)
            u[p].evaluate(o), h[p].accumulateAdditive(a);
          break;
        case mv:
        default:
          for (let p = 0, v = u.length; p !== v; ++p)
            u[p].evaluate(o), h[p].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === nR;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === eR) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        (r -= t * a), (s += Math.abs(a));
        const u = this.repetitions - s;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const h = e < 0;
            this._setEndings(h, !h, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = ml), (r.endingEnd = ml))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? ml : pl)
          : (r.endingStart = Nh),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? ml : pl) : (r.endingEnd = Nh));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      u = o.sampleValues;
    return (a[0] = s), (u[0] = t), (a[1] = s + e), (u[1] = i), this;
  }
}
const bV = new Float32Array(1);
class AV extends xo {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      u = i.uuid,
      h = this._bindingsByRootAndName;
    let p = h[u];
    p === void 0 && ((p = {}), (h[u] = p));
    for (let v = 0; v !== s; ++v) {
      const y = r[v],
        S = y.name;
      let x = p[S];
      if (x !== void 0) ++x.referenceCount, (o[v] = x);
      else {
        if (((x = o[v]), x !== void 0)) {
          x._cacheIndex === null &&
            (++x.referenceCount, this._addInactiveBinding(x, u, S));
          continue;
        }
        const _ = t && t._propertyBindings[v].binding.parsedPath;
        (x = new _L(Wt.create(i, S, _), y.ValueTypeName, y.getValueSize())),
          ++x.referenceCount,
          this._addInactiveBinding(x, u, S),
          (o[v] = x);
      }
      a[v].resultBuffer = x.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      u = a.knownActions,
      h = u[u.length - 1],
      p = e._byClipCacheIndex;
    (h._byClipCacheIndex = p),
      (u[p] = h),
      u.pop(),
      (e._byClipCacheIndex = null);
    const v = a.actionByRoot,
      y = (e._localRoot || this._root).uuid;
    delete v[y],
      u.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      u = t[t.length - 1],
      h = e._cacheIndex;
    (u._cacheIndex = h),
      (t[h] = u),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new Jw(new Float32Array(2), new Float32Array(2), 1, bV)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? qh.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      u = this._actionsByClip[a];
    let h = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = mv)),
      u !== void 0)
    ) {
      const v = u.actionByRoot[s];
      if (v !== void 0 && v.blendMode === i) return v;
      (h = u.knownActions[0]), o === null && (o = h._clip);
    }
    if (o === null) return null;
    const p = new xL(this, o, t, i);
    return this._bindAction(p, h), this._addInactiveAction(p, a, s), p;
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? qh.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let h = 0; h !== i; ++h) t[h]._update(r, e, s, o);
    const a = this._bindings,
      u = this._nActiveBindings;
    for (let h = 0; h !== u; ++h) a[h].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, u = o.length; a !== u; ++a) {
        const h = o[a];
        this._deactivateAction(h);
        const p = h._cacheIndex,
          v = t[t.length - 1];
        (h._cacheIndex = null),
          (h._byClipCacheIndex = null),
          (v._cacheIndex = p),
          (t[p] = v),
          t.pop(),
          this._removeInactiveBindingsForAction(h);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        u = a[t];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class a1 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new a1(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    );
  }
}
let PV = 0;
class RV extends xo {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: PV++ }),
      (this.name = ""),
      (this.usage = Fh),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class LV extends Sv {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class IV {
  constructor(e, t, i, r, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class SL {
  constructor(e, t, i = 0, r = 1 / 0) {
    (this.ray = new Xc(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Il()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return pS(e, this, i, t), i.sort(kC), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) pS(e[r], this, i, t);
    return i.sort(kC), i;
  }
}
function kC(n, e) {
  return n.distance - e.distance;
}
function pS(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++) pS(r[s], e, t, !0);
  }
}
class OV {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(An(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class NV {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const UC = new Me();
class DV {
  constructor(e = new Me(1 / 0, 1 / 0), t = new Me(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = UC.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, UC).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const FC = new B(),
  Em = new B();
class kV {
  constructor(e = new B(), t = new B()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    FC.subVectors(e, this.start), Em.subVectors(this.end, this.start);
    const i = Em.dot(Em);
    let s = Em.dot(FC) / i;
    return t && (s = An(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const BC = new B();
class UV extends Kt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const i = new Rt(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, u = 32; o < u; o++, a++) {
      const h = (o / u) * Math.PI * 2,
        p = (a / u) * Math.PI * 2;
      r.push(Math.cos(h), Math.sin(h), 1, Math.cos(p), Math.sin(p), 1);
    }
    i.setAttribute("position", new lt(r, 3));
    const s = new Hi({ fog: !1, toneMapped: !1 });
    (this.cone = new ks(i, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      BC.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(BC),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Wo = new B(),
  Tm = new _t(),
  i_ = new _t();
class FV extends ks {
  constructor(e) {
    const t = wL(e),
      i = new Rt(),
      r = [],
      s = [],
      o = new Qe(0, 0, 1),
      a = new Qe(0, 1, 0);
    for (let h = 0; h < t.length; h++) {
      const p = t[h];
      p.parent &&
        p.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new lt(r, 3)),
      i.setAttribute("color", new lt(s, 3));
    const u = new Hi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(i, u),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    i_.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Tm.multiplyMatrices(i_, a.matrixWorld),
        Wo.setFromMatrixPosition(Tm),
        r.setXYZ(o, Wo.x, Wo.y, Wo.z),
        Tm.multiplyMatrices(i_, a.parent.matrixWorld),
        Wo.setFromMatrixPosition(Tm),
        r.setXYZ(o + 1, Wo.x, Wo.y, Wo.z),
        (o += 2));
    }
    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function wL(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, wL(n.children[t]));
  return e;
}
class BV extends Bn {
  constructor(e, t, i) {
    const r = new Cf(t, 4, 2),
      s = new Ia({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const zV = new B(),
  zC = new Qe(),
  HC = new Qe();
class HV extends Kt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper");
    const r = new Tf(t);
    r.rotateY(Math.PI * 0.5),
      (this.material = new Ia({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Jt(o, 3)),
      this.add(new Bn(r, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      zC.copy(this.light.color), HC.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? zC : HC;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(zV.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class VV extends ks {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    (i = new Qe(i)), (r = new Qe(r));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      u = [],
      h = [];
    for (let y = 0, S = 0, x = -a; y <= t; y++, x += o) {
      u.push(-a, 0, x, a, 0, x), u.push(x, 0, -a, x, 0, a);
      const _ = y === s ? i : r;
      _.toArray(h, S),
        (S += 3),
        _.toArray(h, S),
        (S += 3),
        _.toArray(h, S),
        (S += 3),
        _.toArray(h, S),
        (S += 3);
    }
    const p = new Rt();
    p.setAttribute("position", new lt(u, 3)),
      p.setAttribute("color", new lt(h, 3));
    const v = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(p, v), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class GV extends ks {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    (s = new Qe(s)), (o = new Qe(o));
    const a = [],
      u = [];
    if (t > 1)
      for (let v = 0; v < t; v++) {
        const y = (v / t) * (Math.PI * 2),
          S = Math.sin(y) * e,
          x = Math.cos(y) * e;
        a.push(0, 0, 0), a.push(S, 0, x);
        const _ = v & 1 ? s : o;
        u.push(_.r, _.g, _.b), u.push(_.r, _.g, _.b);
      }
    for (let v = 0; v < i; v++) {
      const y = v & 1 ? s : o,
        S = e - (e / i) * v;
      for (let x = 0; x < r; x++) {
        let _ = (x / r) * (Math.PI * 2),
          f = Math.sin(_) * S,
          d = Math.cos(_) * S;
        a.push(f, 0, d),
          u.push(y.r, y.g, y.b),
          (_ = ((x + 1) / r) * (Math.PI * 2)),
          (f = Math.sin(_) * S),
          (d = Math.cos(_) * S),
          a.push(f, 0, d),
          u.push(y.r, y.g, y.b);
      }
    }
    const h = new Rt();
    h.setAttribute("position", new lt(a, 3)),
      h.setAttribute("color", new lt(u, 3));
    const p = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(h, p), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const VC = new B(),
  Cm = new B(),
  GC = new B();
class WV extends Kt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let r = new Rt();
    r.setAttribute(
      "position",
      new lt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
    );
    const s = new Hi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Ta(r, s)),
      this.add(this.lightPlane),
      (r = new Rt()),
      r.setAttribute("position", new lt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Ta(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      VC.setFromMatrixPosition(this.light.matrixWorld),
      Cm.setFromMatrixPosition(this.light.target.matrixWorld),
      GC.subVectors(Cm, VC),
      this.lightPlane.lookAt(Cm),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Cm),
      (this.targetLine.scale.z = GC.length());
  }
}
const bm = new B(),
  Cn = new xf();
class jV extends ks {
  constructor(e) {
    const t = new Rt(),
      i = new Hi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(x, _) {
      u(x), u(_);
    }
    function u(x) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[x] === void 0 && (o[x] = []),
        o[x].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new lt(r, 3)),
      t.setAttribute("color", new lt(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const h = new Qe(16755200),
      p = new Qe(16711680),
      v = new Qe(43775),
      y = new Qe(16777215),
      S = new Qe(3355443);
    this.setColors(h, p, v, y, S);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    Cn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Ln("c", t, e, Cn, 0, 0, -1),
      Ln("t", t, e, Cn, 0, 0, 1),
      Ln("n1", t, e, Cn, -i, -r, -1),
      Ln("n2", t, e, Cn, i, -r, -1),
      Ln("n3", t, e, Cn, -i, r, -1),
      Ln("n4", t, e, Cn, i, r, -1),
      Ln("f1", t, e, Cn, -i, -r, 1),
      Ln("f2", t, e, Cn, i, -r, 1),
      Ln("f3", t, e, Cn, -i, r, 1),
      Ln("f4", t, e, Cn, i, r, 1),
      Ln("u1", t, e, Cn, i * 0.7, r * 1.1, -1),
      Ln("u2", t, e, Cn, -i * 0.7, r * 1.1, -1),
      Ln("u3", t, e, Cn, 0, r * 2, -1),
      Ln("cf1", t, e, Cn, -i, 0, 1),
      Ln("cf2", t, e, Cn, i, 0, 1),
      Ln("cf3", t, e, Cn, 0, -r, 1),
      Ln("cf4", t, e, Cn, 0, r, 1),
      Ln("cn1", t, e, Cn, -i, 0, -1),
      Ln("cn2", t, e, Cn, i, 0, -1),
      Ln("cn3", t, e, Cn, 0, -r, -1),
      Ln("cn4", t, e, Cn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Ln(n, e, t, i, r, s, o) {
  bm.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const u = t.getAttribute("position");
    for (let h = 0, p = a.length; h < p; h++) u.setXYZ(a[h], bm.x, bm.y, bm.z);
  }
}
const Am = new Fi();
class XV extends ks {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new Rt();
    s.setIndex(new Jt(i, 1)),
      s.setAttribute("position", new Jt(r, 3)),
      super(s, new Hi({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Am.setFromObject(this.object),
      Am.isEmpty())
    )
      return;
    const t = Am.min,
      i = Am.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class qV extends ks {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new Rt();
    s.setIndex(new Jt(i, 1)),
      s.setAttribute("position", new lt(r, 3)),
      super(s, new Hi({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class $V extends Ta {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new Rt();
    o.setAttribute("position", new lt(s, 3)),
      o.computeBoundingSphere(),
      super(o, new Hi({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      u = new Rt();
    u.setAttribute("position", new lt(a, 3)),
      u.computeBoundingSphere(),
      this.add(
        new Bn(
          u,
          new Ia({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          }),
        ),
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const WC = new B();
let Pm, r_;
class YV extends Kt {
  constructor(
    e = new B(0, 0, 1),
    t = new B(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2,
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Pm === void 0 &&
        ((Pm = new Rt()),
        Pm.setAttribute("position", new lt([0, 0, 0, 0, 1, 0], 3)),
        (r_ = new Yc(0, 0.5, 1, 5, 1)),
        r_.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Ta(Pm, new Hi({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Bn(r_, new Ia({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      WC.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(WC, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class KV extends ks {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new Rt();
    r.setAttribute("position", new lt(t, 3)),
      r.setAttribute("color", new lt(i, 3));
    const s = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, t, i) {
    const r = new Qe(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class QV {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Qe()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Hh()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(d) {
      const m = [];
      for (let g = 0, w = d.length; g < w; g++) {
        const T = d[g],
          C = new Nl();
        (C.curves = T.curves), m.push(C);
      }
      return m;
    }
    function i(d, m) {
      const g = m.length;
      let w = !1;
      for (let T = g - 1, C = 0; C < g; T = C++) {
        let A = m[T],
          L = m[C],
          N = L.x - A.x,
          P = L.y - A.y;
        if (Math.abs(P) > Number.EPSILON) {
          if (
            (P < 0 && ((A = m[C]), (N = -N), (L = m[T]), (P = -P)),
            d.y < A.y || d.y > L.y)
          )
            continue;
          if (d.y === A.y) {
            if (d.x === A.x) return !0;
          } else {
            const I = P * (d.x - A.x) - N * (d.y - A.y);
            if (I === 0) return !0;
            if (I < 0) continue;
            w = !w;
          }
        } else {
          if (d.y !== A.y) continue;
          if ((L.x <= d.x && d.x <= A.x) || (A.x <= d.x && d.x <= L.x))
            return !0;
        }
      }
      return w;
    }
    const r = Ns.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, u;
    const h = [];
    if (s.length === 1)
      return (a = s[0]), (u = new Nl()), (u.curves = a.curves), h.push(u), h;
    let p = !r(s[0].getPoints());
    p = e ? !p : p;
    const v = [],
      y = [];
    let S = [],
      x = 0,
      _;
    (y[x] = void 0), (S[x] = []);
    for (let d = 0, m = s.length; d < m; d++)
      (a = s[d]),
        (_ = a.getPoints()),
        (o = r(_)),
        (o = e ? !o : o),
        o
          ? (!p && y[x] && x++,
            (y[x] = { s: new Nl(), p: _ }),
            (y[x].s.curves = a.curves),
            p && x++,
            (S[x] = []))
          : S[x].push({ h: a, p: _[0] });
    if (!y[0]) return t(s);
    if (y.length > 1) {
      let d = !1,
        m = 0;
      for (let g = 0, w = y.length; g < w; g++) v[g] = [];
      for (let g = 0, w = y.length; g < w; g++) {
        const T = S[g];
        for (let C = 0; C < T.length; C++) {
          const A = T[C];
          let L = !0;
          for (let N = 0; N < y.length; N++)
            i(A.p, y[N].p) &&
              (g !== N && m++, L ? ((L = !1), v[N].push(A)) : (d = !0));
          L && v[g].push(A);
        }
      }
      m > 0 && d === !1 && (S = v);
    }
    let f;
    for (let d = 0, m = y.length; d < m; d++) {
      (u = y[d].s), h.push(u), (f = S[d]);
      for (let g = 0, w = f.length; g < w; g++) u.holes.push(f[g].h);
    }
    return h;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: gf } }),
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = gf));
const ZV = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: ww,
      AddEquation: Jo,
      AddOperation: B2,
      AdditiveAnimationBlendMode: Rw,
      AdditiveBlending: Cx,
      AgXToneMapping: W2,
      AlphaFormat: $2,
      AlwaysCompare: hR,
      AlwaysDepth: I2,
      AlwaysStencilFunc: iS,
      AmbientLight: hL,
      AnimationAction: xL,
      AnimationClip: qh,
      AnimationLoader: eV,
      AnimationMixer: AV,
      AnimationObjectGroup: CV,
      AnimationUtils: K5,
      ArcCurve: FR,
      ArrayCamera: AR,
      ArrowHelper: YV,
      AttachedBindMode: Lx,
      Audio: yL,
      AudioAnalyser: gV,
      AudioContext: i1,
      AudioListener: fV,
      AudioLoader: cV,
      AxesHelper: KV,
      BackSide: Ui,
      BasicDepthPacking: iR,
      BasicShadowMap: p2,
      BatchedMesh: DR,
      Bone: Ww,
      BooleanKeyframeTrack: $l,
      Box2: DV,
      Box3: Fi,
      Box3Helper: qV,
      BoxGeometry: ql,
      BoxHelper: XV,
      BufferAttribute: Jt,
      BufferGeometry: Rt,
      BufferGeometryLoader: vL,
      ByteType: X2,
      Cache: oo,
      Camera: xf,
      CameraHelper: jV,
      CanvasTexture: x5,
      CapsuleGeometry: Cv,
      CatmullRomCurve3: BR,
      CineonToneMapping: V2,
      CircleGeometry: bv,
      ClampToEdgeWrapping: Mi,
      Clock: r1,
      Color: Qe,
      ColorKeyframeTrack: e1,
      ColorManagement: nn,
      CompressedArrayTexture: y5,
      CompressedCubeTexture: _5,
      CompressedTexture: Ev,
      CompressedTextureLoader: tV,
      ConeGeometry: Av,
      ConstantAlphaFactor: P2,
      ConstantColorFactor: b2,
      CubeCamera: _R,
      CubeReflectionMapping: vo,
      CubeRefractionMapping: Ea,
      CubeTexture: Sf,
      CubeTextureLoader: nV,
      CubeUVReflectionMapping: jc,
      CubicBezierCurve: Xw,
      CubicBezierCurve3: zR,
      CubicInterpolant: rL,
      CullFaceBack: Tx,
      CullFaceFront: f2,
      CullFaceFrontBack: oU,
      CullFaceNone: h2,
      Curve: us,
      CurvePath: VR,
      CustomBlending: m2,
      CustomToneMapping: G2,
      CylinderGeometry: Yc,
      Cylindrical: NV,
      Data3DTexture: Dw,
      DataArrayTexture: vv,
      DataTexture: Ol,
      DataTextureLoader: iV,
      DataUtils: pF,
      DecrementStencilOp: vU,
      DecrementWrapStencilOp: _U,
      DefaultLoadingManager: aL,
      DepthFormat: _a,
      DepthStencilFormat: Hl,
      DepthTexture: Bw,
      DetachedBindMode: j2,
      DirectionalLight: dL,
      DirectionalLightHelper: WV,
      DiscreteInterpolant: sL,
      DisplayP3ColorSpace: gv,
      DodecahedronGeometry: Pv,
      DoubleSide: bs,
      DstAlphaFactor: w2,
      DstColorFactor: E2,
      DynamicCopyUsage: OU,
      DynamicDrawUsage: rS,
      DynamicReadUsage: RU,
      EdgesGeometry: GR,
      EllipseCurve: Tv,
      EqualCompare: lR,
      EqualDepth: N2,
      EqualStencilFunc: MU,
      EquirectangularReflectionMapping: Ah,
      EquirectangularRefractionMapping: Ph,
      Euler: _f,
      EventDispatcher: xo,
      ExtrudeGeometry: Lv,
      FileLoader: yo,
      Float16BufferAttribute: xF,
      Float32BufferAttribute: lt,
      Float64BufferAttribute: SF,
      FloatType: Br,
      Fog: xv,
      FogExp2: _v,
      FramebufferTexture: v5,
      FrontSide: go,
      Frustum: wf,
      GLBufferAttribute: IV,
      GLSL1: DU,
      GLSL3: sS,
      GreaterCompare: uR,
      GreaterDepth: k2,
      GreaterEqualCompare: dR,
      GreaterEqualDepth: D2,
      GreaterEqualStencilFunc: bU,
      GreaterStencilFunc: TU,
      GridHelper: VV,
      Group: nc,
      HalfFloatType: Uc,
      HemisphereLight: lL,
      HemisphereLightHelper: HV,
      IcosahedronGeometry: Iv,
      ImageBitmapLoader: uV,
      ImageLoader: $h,
      ImageUtils: Nw,
      IncrementStencilOp: gU,
      IncrementWrapStencilOp: yU,
      InstancedBufferAttribute: zc,
      InstancedBufferGeometry: gL,
      InstancedInterleavedBuffer: LV,
      InstancedMesh: NR,
      Int16BufferAttribute: yF,
      Int32BufferAttribute: _F,
      Int8BufferAttribute: mF,
      IntType: Mw,
      InterleavedBuffer: Sv,
      InterleavedBufferAttribute: Vl,
      Interpolant: bf,
      InterpolateDiscrete: Ih,
      InterpolateLinear: Oh,
      InterpolateSmooth: rg,
      InvertStencilOp: xU,
      KeepStencilOp: ol,
      KeyframeTrack: cs,
      LOD: IR,
      LatheGeometry: Ef,
      Layers: Il,
      LessCompare: aR,
      LessDepth: O2,
      LessEqualCompare: Iw,
      LessEqualDepth: bh,
      LessEqualStencilFunc: EU,
      LessStencilFunc: wU,
      Light: Na,
      LightProbe: mL,
      Line: Ta,
      Line3: kV,
      LineBasicMaterial: Hi,
      LineCurve: qw,
      LineCurve3: HR,
      LineDashedMaterial: tL,
      LineLoop: kR,
      LineSegments: ks,
      LinearDisplayP3ColorSpace: yf,
      LinearEncoding: Lw,
      LinearFilter: xn,
      LinearInterpolant: Jw,
      LinearMipMapLinearFilter: cU,
      LinearMipMapNearestFilter: uU,
      LinearMipmapLinearFilter: As,
      LinearMipmapNearestFilter: th,
      LinearSRGBColorSpace: Ds,
      LinearToneMapping: z2,
      LinearTransfer: Dh,
      Loader: Ji,
      LoaderUtils: fS,
      LoadingManager: t1,
      LoopOnce: eR,
      LoopPingPong: nR,
      LoopRepeat: tR,
      LuminanceAlphaFormat: K2,
      LuminanceFormat: Y2,
      MOUSE: rU,
      Material: ci,
      MaterialLoader: Hv,
      MathUtils: KU,
      Matrix3: Nt,
      Matrix4: _t,
      MaxEquation: Rx,
      Mesh: Bn,
      MeshBasicMaterial: Ia,
      MeshDepthMaterial: zw,
      MeshDistanceMaterial: Hw,
      MeshLambertMaterial: Bv,
      MeshMatcapMaterial: eL,
      MeshNormalMaterial: JR,
      MeshPhongMaterial: QR,
      MeshPhysicalMaterial: KR,
      MeshStandardMaterial: Qw,
      MeshToonMaterial: ZR,
      MinEquation: Px,
      MirroredRepeatWrapping: Lh,
      MixOperation: F2,
      MultiplyBlending: Ax,
      MultiplyOperation: vf,
      NearestFilter: In,
      NearestMipMapLinearFilter: lU,
      NearestMipMapNearestFilter: aU,
      NearestMipmapLinearFilter: ul,
      NearestMipmapNearestFilter: Ug,
      NeverCompare: oR,
      NeverDepth: L2,
      NeverStencilFunc: SU,
      NoBlending: uo,
      NoColorSpace: dr,
      NoToneMapping: Is,
      NormalAnimationBlendMode: mv,
      NormalBlending: Pl,
      NotEqualCompare: cR,
      NotEqualDepth: U2,
      NotEqualStencilFunc: CU,
      NumberKeyframeTrack: jh,
      Object3D: Kt,
      ObjectLoader: aV,
      ObjectSpaceNormalMap: sR,
      OctahedronGeometry: Tf,
      OneFactor: _2,
      OneMinusConstantAlphaFactor: R2,
      OneMinusConstantColorFactor: A2,
      OneMinusDstAlphaFactor: M2,
      OneMinusDstColorFactor: T2,
      OneMinusSrcAlphaFactor: kg,
      OneMinusSrcColorFactor: S2,
      OrthographicCamera: Mf,
      P3Primaries: Uh,
      PCFShadowMap: hv,
      PCFSoftShadowMap: eh,
      PMREMGenerator: aS,
      Path: Hh,
      PerspectiveCamera: ei,
      Plane: Yo,
      PlaneGeometry: qc,
      PlaneHelper: $V,
      PointLight: cL,
      PointLightHelper: BV,
      Points: UR,
      PointsMaterial: Mv,
      PolarGridHelper: GV,
      PolyhedronGeometry: Oa,
      PositionalAudio: mV,
      PropertyBinding: Wt,
      PropertyMixer: _L,
      QuadraticBezierCurve: $w,
      QuadraticBezierCurve3: Yw,
      Quaternion: li,
      QuaternionKeyframeTrack: Kc,
      QuaternionLinearInterpolant: oL,
      RED_GREEN_RGTC2_Format: tS,
      RED_RGTC1_Format: J2,
      REVISION: gf,
      RGBADepthPacking: rR,
      RGBAFormat: Ni,
      RGBAIntegerFormat: Aw,
      RGBA_ASTC_10x10_Format: Yx,
      RGBA_ASTC_10x5_Format: Xx,
      RGBA_ASTC_10x6_Format: qx,
      RGBA_ASTC_10x8_Format: $x,
      RGBA_ASTC_12x10_Format: Kx,
      RGBA_ASTC_12x12_Format: Qx,
      RGBA_ASTC_4x4_Format: Fx,
      RGBA_ASTC_5x4_Format: Bx,
      RGBA_ASTC_5x5_Format: zx,
      RGBA_ASTC_6x5_Format: Hx,
      RGBA_ASTC_6x6_Format: Vx,
      RGBA_ASTC_8x5_Format: Gx,
      RGBA_ASTC_8x6_Format: Wx,
      RGBA_ASTC_8x8_Format: jx,
      RGBA_BPTC_Format: ig,
      RGBA_ETC2_EAC_Format: Ux,
      RGBA_PVRTC_2BPPV1_Format: Dx,
      RGBA_PVRTC_4BPPV1_Format: Nx,
      RGBA_S3TC_DXT1_Format: eg,
      RGBA_S3TC_DXT3_Format: tg,
      RGBA_S3TC_DXT5_Format: ng,
      RGB_BPTC_SIGNED_Format: Zx,
      RGB_BPTC_UNSIGNED_Format: Jx,
      RGB_ETC1_Format: Pw,
      RGB_ETC2_Format: kx,
      RGB_PVRTC_2BPPV1_Format: Ox,
      RGB_PVRTC_4BPPV1_Format: Ix,
      RGB_S3TC_DXT1_Format: Jm,
      RGFormat: Z2,
      RGIntegerFormat: bw,
      RawShaderMaterial: YR,
      Ray: Xc,
      Raycaster: SL,
      Rec709Primaries: kh,
      RectAreaLight: fL,
      RedFormat: Q2,
      RedIntegerFormat: Cw,
      ReinhardToneMapping: H2,
      RenderTarget: mR,
      RepeatWrapping: Rh,
      ReplaceStencilOp: mU,
      ReverseSubtractEquation: v2,
      RingGeometry: Ov,
      SIGNED_RED_GREEN_RGTC2_Format: nS,
      SIGNED_RED_RGTC1_Format: eS,
      SRGBColorSpace: Wn,
      SRGBTransfer: un,
      Scene: zg,
      ShaderChunk: It,
      ShaderLib: is,
      ShaderMaterial: ls,
      ShadowMaterial: $R,
      Shape: Nl,
      ShapeGeometry: Nv,
      ShapePath: QV,
      ShapeUtils: Ns,
      ShortType: q2,
      Skeleton: wv,
      SkeletonHelper: FV,
      SkinnedMesh: OR,
      Source: gl,
      Sphere: Ei,
      SphereGeometry: Cf,
      Spherical: OV,
      SphericalHarmonics3: pL,
      SplineCurve: Kw,
      SpotLight: uL,
      SpotLightHelper: UV,
      Sprite: LR,
      SpriteMaterial: Gw,
      SrcAlphaFactor: Dg,
      SrcAlphaSaturateFactor: C2,
      SrcColorFactor: x2,
      StaticCopyUsage: IU,
      StaticDrawUsage: Fh,
      StaticReadUsage: PU,
      StereoCamera: dV,
      StreamCopyUsage: NU,
      StreamDrawUsage: AU,
      StreamReadUsage: LU,
      StringKeyframeTrack: Yl,
      SubtractEquation: g2,
      SubtractiveBlending: bx,
      TOUCH: sU,
      TangentSpaceNormalMap: La,
      TetrahedronGeometry: Dv,
      Texture: Mn,
      TextureLoader: zv,
      TorusGeometry: kv,
      TorusKnotGeometry: Uv,
      Triangle: hr,
      TriangleFanDrawMode: fU,
      TriangleStripDrawMode: hU,
      TrianglesDrawMode: dU,
      TubeGeometry: Fv,
      UVMapping: fv,
      Uint16BufferAttribute: kw,
      Uint32BufferAttribute: Uw,
      Uint8BufferAttribute: gF,
      Uint8ClampedBufferAttribute: vF,
      Uniform: a1,
      UniformsGroup: RV,
      UniformsLib: He,
      UniformsUtils: yR,
      UnsignedByteType: Os,
      UnsignedInt248Type: ya,
      UnsignedIntType: so,
      UnsignedShort4444Type: Ew,
      UnsignedShort5551Type: Tw,
      UnsignedShortType: pv,
      VSMShadowMap: Jr,
      Vector2: Me,
      Vector3: B,
      Vector4: rn,
      VectorKeyframeTrack: Xh,
      VideoTexture: g5,
      WebGL1Renderer: PR,
      WebGL3DRenderTarget: nF,
      WebGLArrayRenderTarget: tF,
      WebGLCoordinateSystem: Ps,
      WebGLCubeRenderTarget: xR,
      WebGLMultipleRenderTargets: iF,
      WebGLRenderTarget: as,
      WebGLRenderer: Vw,
      WebGLUtils: bR,
      WebGPUCoordinateSystem: Bh,
      WireframeGeometry: qR,
      WrapAroundEnding: Nh,
      ZeroCurvatureEnding: pl,
      ZeroFactor: y2,
      ZeroSlopeEnding: ml,
      ZeroStencilOp: pU,
      _SRGBAFormat: Fg,
      createCanvasElement: pR,
      sRGBEncoding: xa,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
var ML = { exports: {} },
  Kl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Kl.ConcurrentRoot = 1;
Kl.ContinuousEventPriority = 4;
Kl.DefaultEventPriority = 16;
Kl.DiscreteEventPriority = 1;
Kl.IdleEventPriority = 536870912;
Kl.LegacyRoot = 0;
ML.exports = Kl;
var rc = ML.exports;
function JV(n) {
  let e;
  const t = new Set(),
    i = (h, p) => {
      const v = typeof h == "function" ? h(e) : h;
      if (v !== e) {
        const y = e;
        (e = p ? v : Object.assign({}, e, v)), t.forEach((S) => S(e, y));
      }
    },
    r = () => e,
    s = (h, p = r, v = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware",
      );
      let y = p(e);
      function S() {
        const x = p(e);
        if (!v(y, x)) {
          const _ = y;
          h((y = x), _);
        }
      }
      return t.add(S), () => t.delete(S);
    },
    u = {
      setState: i,
      getState: r,
      subscribe: (h, p, v) =>
        p || v ? s(h, p, v) : (t.add(h), () => t.delete(h)),
      destroy: () => t.clear(),
    };
  return (e = n(i, r, u)), u;
}
const e6 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  jC = e6 ? se.useEffect : se.useLayoutEffect;
function t6(n) {
  const e = typeof n == "function" ? JV(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = se.useReducer((f) => f + 1, 0),
        o = e.getState(),
        a = se.useRef(o),
        u = se.useRef(i),
        h = se.useRef(r),
        p = se.useRef(!1),
        v = se.useRef();
      v.current === void 0 && (v.current = i(o));
      let y,
        S = !1;
      (a.current !== o || u.current !== i || h.current !== r || p.current) &&
        ((y = i(o)), (S = !r(v.current, y))),
        jC(() => {
          S && (v.current = y),
            (a.current = o),
            (u.current = i),
            (h.current = r),
            (p.current = !1);
        });
      const x = se.useRef(o);
      jC(() => {
        const f = () => {
            try {
              const m = e.getState(),
                g = u.current(m);
              h.current(v.current, g) ||
                ((a.current = m), (v.current = g), s());
            } catch {
              (p.current = !0), s();
            }
          },
          d = e.subscribe(f);
        return e.getState() !== x.current && f(), d;
      }, []);
      const _ = S ? y : v.current;
      return se.useDebugValue(_), _;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4",
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
var EL = { exports: {} },
  TL = { exports: {} },
  CL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(k, W) {
    var H = k.length;
    k.push(W);
    e: for (; 0 < H; ) {
      var ee = (H - 1) >>> 1,
        ae = k[ee];
      if (0 < r(ae, W)) (k[ee] = W), (k[H] = ae), (H = ee);
      else break e;
    }
  }
  function t(k) {
    return k.length === 0 ? null : k[0];
  }
  function i(k) {
    if (k.length === 0) return null;
    var W = k[0],
      H = k.pop();
    if (H !== W) {
      k[0] = H;
      e: for (var ee = 0, ae = k.length, xe = ae >>> 1; ee < xe; ) {
        var te = 2 * (ee + 1) - 1,
          de = k[te],
          ye = te + 1,
          Ce = k[ye];
        if (0 > r(de, H))
          ye < ae && 0 > r(Ce, de)
            ? ((k[ee] = Ce), (k[ye] = H), (ee = ye))
            : ((k[ee] = de), (k[te] = H), (ee = te));
        else if (ye < ae && 0 > r(Ce, H)) (k[ee] = Ce), (k[ye] = H), (ee = ye);
        else break e;
      }
    }
    return W;
  }
  function r(k, W) {
    var H = k.sortIndex - W.sortIndex;
    return H !== 0 ? H : k.id - W.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var u = [],
    h = [],
    p = 1,
    v = null,
    y = 3,
    S = !1,
    x = !1,
    _ = !1,
    f = typeof setTimeout == "function" ? setTimeout : null,
    d = typeof clearTimeout == "function" ? clearTimeout : null,
    m = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function g(k) {
    for (var W = t(h); W !== null; ) {
      if (W.callback === null) i(h);
      else if (W.startTime <= k)
        i(h), (W.sortIndex = W.expirationTime), e(u, W);
      else break;
      W = t(h);
    }
  }
  function w(k) {
    if (((_ = !1), g(k), !x))
      if (t(u) !== null) (x = !0), G(T);
      else {
        var W = t(h);
        W !== null && ne(w, W.startTime - k);
      }
  }
  function T(k, W) {
    (x = !1), _ && ((_ = !1), d(L), (L = -1)), (S = !0);
    var H = y;
    try {
      for (
        g(W), v = t(u);
        v !== null && (!(v.expirationTime > W) || (k && !I()));

      ) {
        var ee = v.callback;
        if (typeof ee == "function") {
          (v.callback = null), (y = v.priorityLevel);
          var ae = ee(v.expirationTime <= W);
          (W = n.unstable_now()),
            typeof ae == "function" ? (v.callback = ae) : v === t(u) && i(u),
            g(W);
        } else i(u);
        v = t(u);
      }
      if (v !== null) var xe = !0;
      else {
        var te = t(h);
        te !== null && ne(w, te.startTime - W), (xe = !1);
      }
      return xe;
    } finally {
      (v = null), (y = H), (S = !1);
    }
  }
  var C = !1,
    A = null,
    L = -1,
    N = 5,
    P = -1;
  function I() {
    return !(n.unstable_now() - P < N);
  }
  function Q() {
    if (A !== null) {
      var k = n.unstable_now();
      P = k;
      var W = !0;
      try {
        W = A(!0, k);
      } finally {
        W ? ue() : ((C = !1), (A = null));
      }
    } else C = !1;
  }
  var ue;
  if (typeof m == "function")
    ue = function () {
      m(Q);
    };
  else if (typeof MessageChannel < "u") {
    var F = new MessageChannel(),
      X = F.port2;
    (F.port1.onmessage = Q),
      (ue = function () {
        X.postMessage(null);
      });
  } else
    ue = function () {
      f(Q, 0);
    };
  function G(k) {
    (A = k), C || ((C = !0), ue());
  }
  function ne(k, W) {
    L = f(function () {
      k(n.unstable_now());
    }, W);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (k) {
      k.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      x || S || ((x = !0), G(T));
    }),
    (n.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
          )
        : (N = 0 < k ? Math.floor(1e3 / k) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return y;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(u);
    }),
    (n.unstable_next = function (k) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var W = 3;
          break;
        default:
          W = y;
      }
      var H = y;
      y = W;
      try {
        return k();
      } finally {
        y = H;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (k, W) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          k = 3;
      }
      var H = y;
      y = k;
      try {
        return W();
      } finally {
        y = H;
      }
    }),
    (n.unstable_scheduleCallback = function (k, W, H) {
      var ee = n.unstable_now();
      switch (
        (typeof H == "object" && H !== null
          ? ((H = H.delay), (H = typeof H == "number" && 0 < H ? ee + H : ee))
          : (H = ee),
        k)
      ) {
        case 1:
          var ae = -1;
          break;
        case 2:
          ae = 250;
          break;
        case 5:
          ae = 1073741823;
          break;
        case 4:
          ae = 1e4;
          break;
        default:
          ae = 5e3;
      }
      return (
        (ae = H + ae),
        (k = {
          id: p++,
          callback: W,
          priorityLevel: k,
          startTime: H,
          expirationTime: ae,
          sortIndex: -1,
        }),
        H > ee
          ? ((k.sortIndex = H),
            e(h, k),
            t(u) === null &&
              k === t(h) &&
              (_ ? (d(L), (L = -1)) : (_ = !0), ne(w, H - ee)))
          : ((k.sortIndex = ae), e(u, k), x || S || ((x = !0), G(T))),
        k
      );
    }),
    (n.unstable_shouldYield = I),
    (n.unstable_wrapCallback = function (k) {
      var W = y;
      return function () {
        var H = y;
        y = W;
        try {
          return k.apply(this, arguments);
        } finally {
          y = H;
        }
      };
    });
})(CL);
TL.exports = CL;
var mS = TL.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var n6 = function (e) {
  var t = {},
    i = se,
    r = mS,
    s = Object.assign;
  function o(l) {
    for (
      var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + l,
        M = 1;
      M < arguments.length;
      M++
    )
      c += "&args[]=" + encodeURIComponent(arguments[M]);
    return (
      "Minified React error #" +
      l +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    u = Symbol.for("react.element"),
    h = Symbol.for("react.portal"),
    p = Symbol.for("react.fragment"),
    v = Symbol.for("react.strict_mode"),
    y = Symbol.for("react.profiler"),
    S = Symbol.for("react.provider"),
    x = Symbol.for("react.context"),
    _ = Symbol.for("react.forward_ref"),
    f = Symbol.for("react.suspense"),
    d = Symbol.for("react.suspense_list"),
    m = Symbol.for("react.memo"),
    g = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    T = Symbol.iterator;
  function C(l) {
    return l === null || typeof l != "object"
      ? null
      : ((l = (T && l[T]) || l["@@iterator"]),
        typeof l == "function" ? l : null);
  }
  function A(l) {
    if (l == null) return null;
    if (typeof l == "function") return l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case p:
        return "Fragment";
      case h:
        return "Portal";
      case y:
        return "Profiler";
      case v:
        return "StrictMode";
      case f:
        return "Suspense";
      case d:
        return "SuspenseList";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case x:
          return (l.displayName || "Context") + ".Consumer";
        case S:
          return (l._context.displayName || "Context") + ".Provider";
        case _:
          var c = l.render;
          return (
            (l = l.displayName),
            l ||
              ((l = c.displayName || c.name || ""),
              (l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")),
            l
          );
        case m:
          return (
            (c = l.displayName || null), c !== null ? c : A(l.type) || "Memo"
          );
        case g:
          (c = l._payload), (l = l._init);
          try {
            return A(l(c));
          } catch {}
      }
    return null;
  }
  function L(l) {
    var c = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (l = c.render),
          (l = l.displayName || l.name || ""),
          c.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return A(c);
      case 8:
        return c === v ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function N(l) {
    var c = l,
      M = l;
    if (l.alternate) for (; c.return; ) c = c.return;
    else {
      l = c;
      do (c = l), c.flags & 4098 && (M = c.return), (l = c.return);
      while (l);
    }
    return c.tag === 3 ? M : null;
  }
  function P(l) {
    if (N(l) !== l) throw Error(o(188));
  }
  function I(l) {
    var c = l.alternate;
    if (!c) {
      if (((c = N(l)), c === null)) throw Error(o(188));
      return c !== l ? null : l;
    }
    for (var M = l, E = c; ; ) {
      var b = M.return;
      if (b === null) break;
      var R = b.alternate;
      if (R === null) {
        if (((E = b.return), E !== null)) {
          M = E;
          continue;
        }
        break;
      }
      if (b.child === R.child) {
        for (R = b.child; R; ) {
          if (R === M) return P(b), l;
          if (R === E) return P(b), c;
          R = R.sibling;
        }
        throw Error(o(188));
      }
      if (M.return !== E.return) (M = b), (E = R);
      else {
        for (var z = !1, ie = b.child; ie; ) {
          if (ie === M) {
            (z = !0), (M = b), (E = R);
            break;
          }
          if (ie === E) {
            (z = !0), (E = b), (M = R);
            break;
          }
          ie = ie.sibling;
        }
        if (!z) {
          for (ie = R.child; ie; ) {
            if (ie === M) {
              (z = !0), (M = R), (E = b);
              break;
            }
            if (ie === E) {
              (z = !0), (E = R), (M = b);
              break;
            }
            ie = ie.sibling;
          }
          if (!z) throw Error(o(189));
        }
      }
      if (M.alternate !== E) throw Error(o(190));
    }
    if (M.tag !== 3) throw Error(o(188));
    return M.stateNode.current === M ? l : c;
  }
  function Q(l) {
    return (l = I(l)), l !== null ? ue(l) : null;
  }
  function ue(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      var c = ue(l);
      if (c !== null) return c;
      l = l.sibling;
    }
    return null;
  }
  function F(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      if (l.tag !== 4) {
        var c = F(l);
        if (c !== null) return c;
      }
      l = l.sibling;
    }
    return null;
  }
  var X = Array.isArray,
    G = e.getPublicInstance,
    ne = e.getRootHostContext,
    k = e.getChildHostContext,
    W = e.prepareForCommit,
    H = e.resetAfterCommit,
    ee = e.createInstance,
    ae = e.appendInitialChild,
    xe = e.finalizeInitialChildren,
    te = e.prepareUpdate,
    de = e.shouldSetTextContent,
    ye = e.createTextInstance,
    Ce = e.scheduleTimeout,
    Ze = e.cancelTimeout,
    ze = e.noTimeout,
    tt = e.isPrimaryRenderer,
    Ge = e.supportsMutation,
    V = e.supportsPersistence,
    be = e.supportsHydration,
    ge = e.getInstanceFromNode,
    Le = e.preparePortalMount,
    Se = e.getCurrentEventPriority,
    at = e.detachDeletedInstance,
    We = e.supportsMicrotasks,
    U = e.scheduleMicrotask,
    D = e.supportsTestSelectors,
    le = e.findFiberRoot,
    Re = e.getBoundingRect,
    Ee = e.getTextContent,
    Te = e.isHiddenSubtree,
    rt = e.matchAccessibilityRole,
    Be = e.setFocusIfFocusable,
    Ke = e.setupIntersectionObserver,
    mt = e.appendChild,
    wt = e.appendChildToContainer,
    Ae = e.commitTextUpdate,
    Ht = e.commitMount,
    Ct = e.commitUpdate,
    yt = e.insertBefore,
    dt = e.insertInContainerBefore,
    nt = e.removeChild,
    Mt = e.removeChildFromContainer,
    kt = e.resetTextContent,
    Qt = e.hideInstance,
    Lt = e.hideTextInstance,
    Zt = e.unhideInstance,
    j = e.unhideTextInstance,
    Oe = e.clearContainer,
    De = e.cloneInstance,
    ot = e.createContainerChildSet,
    ft = e.appendChildToContainerChildSet,
    Vt = e.finalizeContainerChildren,
    Xt = e.replaceContainerChildren,
    mn = e.cloneHiddenInstance,
    $n = e.cloneHiddenTextInstance,
    en = e.canHydrateInstance,
    zn = e.canHydrateTextInstance,
    Ci = e.canHydrateSuspenseInstance,
    So = e.isSuspenseInstancePending,
    ds = e.isSuspenseInstanceFallback,
    wo = e.registerSuspenseInstanceRetry,
    hs = e.getNextHydratableSibling,
    Mo = e.getFirstHydratableChild,
    Z = e.getFirstHydratableChildWithinContainer,
    K = e.getFirstHydratableChildWithinSuspenseInstance,
    fe = e.hydrateInstance,
    we = e.hydrateTextInstance,
    Xe = e.hydrateSuspenseInstance,
    O = e.getNextHydratableInstanceAfterSuspenseInstance,
    q = e.commitHydratedContainer,
    $ = e.commitHydratedSuspenseInstance,
    Y = e.clearSuspenseBoundary,
    J = e.clearSuspenseBoundaryFromContainer,
    ve = e.shouldDeleteUnhydratedTailInstances,
    _e = e.didNotMatchHydratedContainerTextInstance,
    Ve = e.didNotMatchHydratedTextInstance,
    Ue;
  function $e(l) {
    if (Ue === void 0)
      try {
        throw Error();
      } catch (M) {
        var c = M.stack.trim().match(/\n( *(at )?)/);
        Ue = (c && c[1]) || "";
      }
    return (
      `
` +
      Ue +
      l
    );
  }
  var je = !1;
  function Fe(l, c) {
    if (!l || je) return "";
    je = !0;
    var M = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c)
        if (
          ((c = function () {
            throw Error();
          }),
          Object.defineProperty(c.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(c, []);
          } catch (ke) {
            var E = ke;
          }
          Reflect.construct(l, [], c);
        } else {
          try {
            c.call();
          } catch (ke) {
            E = ke;
          }
          l.call(c.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ke) {
          E = ke;
        }
        l();
      }
    } catch (ke) {
      if (ke && E && typeof ke.stack == "string") {
        for (
          var b = ke.stack.split(`
`),
            R = E.stack.split(`
`),
            z = b.length - 1,
            ie = R.length - 1;
          1 <= z && 0 <= ie && b[z] !== R[ie];

        )
          ie--;
        for (; 1 <= z && 0 <= ie; z--, ie--)
          if (b[z] !== R[ie]) {
            if (z !== 1 || ie !== 1)
              do
                if ((z--, ie--, 0 > ie || b[z] !== R[ie])) {
                  var me =
                    `
` + b[z].replace(" at new ", " at ");
                  return (
                    l.displayName &&
                      me.includes("<anonymous>") &&
                      (me = me.replace("<anonymous>", l.displayName)),
                    me
                  );
                }
              while (1 <= z && 0 <= ie);
            break;
          }
      }
    } finally {
      (je = !1), (Error.prepareStackTrace = M);
    }
    return (l = l ? l.displayName || l.name : "") ? $e(l) : "";
  }
  var St = Object.prototype.hasOwnProperty,
    bt = [],
    pt = -1;
  function xt(l) {
    return { current: l };
  }
  function Ne(l) {
    0 > pt || ((l.current = bt[pt]), (bt[pt] = null), pt--);
  }
  function Pe(l, c) {
    pt++, (bt[pt] = l.current), (l.current = c);
  }
  var At = {},
    et = xt(At),
    gt = xt(!1),
    qt = At;
  function on(l, c) {
    var M = l.type.contextTypes;
    if (!M) return At;
    var E = l.stateNode;
    if (E && E.__reactInternalMemoizedUnmaskedChildContext === c)
      return E.__reactInternalMemoizedMaskedChildContext;
    var b = {},
      R;
    for (R in M) b[R] = c[R];
    return (
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = c),
        (l.__reactInternalMemoizedMaskedChildContext = b)),
      b
    );
  }
  function tn(l) {
    return (l = l.childContextTypes), l != null;
  }
  function Gt() {
    Ne(gt), Ne(et);
  }
  function Nn(l, c, M) {
    if (et.current !== At) throw Error(o(168));
    Pe(et, c), Pe(gt, M);
  }
  function ni(l, c, M) {
    var E = l.stateNode;
    if (((c = c.childContextTypes), typeof E.getChildContext != "function"))
      return M;
    E = E.getChildContext();
    for (var b in E) if (!(b in c)) throw Error(o(108, L(l) || "Unknown", b));
    return s({}, M, E);
  }
  function Bt(l) {
    return (
      (l =
        ((l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext) ||
        At),
      (qt = et.current),
      Pe(et, l),
      Pe(gt, gt.current),
      !0
    );
  }
  function bi(l, c, M) {
    var E = l.stateNode;
    if (!E) throw Error(o(169));
    M
      ? ((l = ni(l, c, qt)),
        (E.__reactInternalMemoizedMergedChildContext = l),
        Ne(gt),
        Ne(et),
        Pe(et, l))
      : Ne(gt),
      Pe(gt, M);
  }
  var Pn = Math.clz32 ? Math.clz32 : er,
    Us = Math.log,
    Eo = Math.LN2;
  function er(l) {
    return (l >>>= 0), l === 0 ? 32 : (31 - ((Us(l) / Eo) | 0)) | 0;
  }
  var di = 64,
    Wr = 4194304;
  function Vi(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function hi(l, c) {
    var M = l.pendingLanes;
    if (M === 0) return 0;
    var E = 0,
      b = l.suspendedLanes,
      R = l.pingedLanes,
      z = M & 268435455;
    if (z !== 0) {
      var ie = z & ~b;
      ie !== 0 ? (E = Vi(ie)) : ((R &= z), R !== 0 && (E = Vi(R)));
    } else (z = M & ~b), z !== 0 ? (E = Vi(z)) : R !== 0 && (E = Vi(R));
    if (E === 0) return 0;
    if (
      c !== 0 &&
      c !== E &&
      !(c & b) &&
      ((b = E & -E), (R = c & -c), b >= R || (b === 16 && (R & 4194240) !== 0))
    )
      return c;
    if ((E & 4 && (E |= M & 16), (c = l.entangledLanes), c !== 0))
      for (l = l.entanglements, c &= E; 0 < c; )
        (M = 31 - Pn(c)), (b = 1 << M), (E |= l[M]), (c &= ~b);
    return E;
  }
  function Ql(l, c) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Zl(l, c) {
    for (
      var M = l.suspendedLanes,
        E = l.pingedLanes,
        b = l.expirationTimes,
        R = l.pendingLanes;
      0 < R;

    ) {
      var z = 31 - Pn(R),
        ie = 1 << z,
        me = b[z];
      me === -1
        ? (!(ie & M) || ie & E) && (b[z] = Ql(ie, c))
        : me <= c && (l.expiredLanes |= ie),
        (R &= ~ie);
    }
  }
  function fs(l) {
    return (
      (l = l.pendingLanes & -1073741825),
      l !== 0 ? l : l & 1073741824 ? 1073741824 : 0
    );
  }
  function Da(l) {
    for (var c = [], M = 0; 31 > M; M++) c.push(l);
    return c;
  }
  function Fs(l, c, M) {
    (l.pendingLanes |= c),
      c !== 536870912 && ((l.suspendedLanes = 0), (l.pingedLanes = 0)),
      (l = l.eventTimes),
      (c = 31 - Pn(c)),
      (l[c] = M);
  }
  function To(l, c) {
    var M = l.pendingLanes & ~c;
    (l.pendingLanes = c),
      (l.suspendedLanes = 0),
      (l.pingedLanes = 0),
      (l.expiredLanes &= c),
      (l.mutableReadLanes &= c),
      (l.entangledLanes &= c),
      (c = l.entanglements);
    var E = l.eventTimes;
    for (l = l.expirationTimes; 0 < M; ) {
      var b = 31 - Pn(M),
        R = 1 << b;
      (c[b] = 0), (E[b] = -1), (l[b] = -1), (M &= ~R);
    }
  }
  function ka(l, c) {
    var M = (l.entangledLanes |= c);
    for (l = l.entanglements; M; ) {
      var E = 31 - Pn(M),
        b = 1 << E;
      (b & c) | (l[E] & c) && (l[E] |= c), (M &= ~b);
    }
  }
  var Ut = 0;
  function Ua(l) {
    return (
      (l &= -l), 1 < l ? (4 < l ? (l & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var ps = r.unstable_scheduleCallback,
    Bs = r.unstable_cancelCallback,
    Sr = r.unstable_shouldYield,
    zs = r.unstable_requestPaint,
    ln = r.unstable_now,
    Co = r.unstable_ImmediatePriority,
    Rf = r.unstable_UserBlockingPriority,
    Jl = r.unstable_NormalPriority,
    Qc = r.unstable_IdlePriority,
    Fa = null,
    tr = null;
  function Lf(l) {
    if (tr && typeof tr.onCommitFiberRoot == "function")
      try {
        tr.onCommitFiberRoot(Fa, l, void 0, (l.current.flags & 128) === 128);
      } catch {}
  }
  function If(l, c) {
    return (l === c && (l !== 0 || 1 / l === 1 / c)) || (l !== l && c !== c);
  }
  var wr = typeof Object.is == "function" ? Object.is : If,
    jr = null,
    bo = !1,
    eu = !1;
  function f1(l) {
    jr === null ? (jr = [l]) : jr.push(l);
  }
  function QL(l) {
    (bo = !0), f1(l);
  }
  function ms() {
    if (!eu && jr !== null) {
      eu = !0;
      var l = 0,
        c = Ut;
      try {
        var M = jr;
        for (Ut = 1; l < M.length; l++) {
          var E = M[l];
          do E = E(!0);
          while (E !== null);
        }
        (jr = null), (bo = !1);
      } catch (b) {
        throw (jr !== null && (jr = jr.slice(l + 1)), ps(Co, ms), b);
      } finally {
        (Ut = c), (eu = !1);
      }
    }
    return null;
  }
  var ZL = a.ReactCurrentBatchConfig;
  function Of(l, c) {
    if (wr(l, c)) return !0;
    if (
      typeof l != "object" ||
      l === null ||
      typeof c != "object" ||
      c === null
    )
      return !1;
    var M = Object.keys(l),
      E = Object.keys(c);
    if (M.length !== E.length) return !1;
    for (E = 0; E < M.length; E++) {
      var b = M[E];
      if (!St.call(c, b) || !wr(l[b], c[b])) return !1;
    }
    return !0;
  }
  function JL(l) {
    switch (l.tag) {
      case 5:
        return $e(l.type);
      case 16:
        return $e("Lazy");
      case 13:
        return $e("Suspense");
      case 19:
        return $e("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (l = Fe(l.type, !1)), l;
      case 11:
        return (l = Fe(l.type.render, !1)), l;
      case 1:
        return (l = Fe(l.type, !0)), l;
      default:
        return "";
    }
  }
  function Xr(l, c) {
    if (l && l.defaultProps) {
      (c = s({}, c)), (l = l.defaultProps);
      for (var M in l) c[M] === void 0 && (c[M] = l[M]);
      return c;
    }
    return c;
  }
  var Nf = xt(null),
    Df = null,
    tu = null,
    Vv = null;
  function Gv() {
    Vv = tu = Df = null;
  }
  function p1(l, c, M) {
    tt
      ? (Pe(Nf, c._currentValue), (c._currentValue = M))
      : (Pe(Nf, c._currentValue2), (c._currentValue2 = M));
  }
  function Wv(l) {
    var c = Nf.current;
    Ne(Nf), tt ? (l._currentValue = c) : (l._currentValue2 = c);
  }
  function jv(l, c, M) {
    for (; l !== null; ) {
      var E = l.alternate;
      if (
        ((l.childLanes & c) !== c
          ? ((l.childLanes |= c), E !== null && (E.childLanes |= c))
          : E !== null && (E.childLanes & c) !== c && (E.childLanes |= c),
        l === M)
      )
        break;
      l = l.return;
    }
  }
  function nu(l, c) {
    (Df = l),
      (Vv = tu = null),
      (l = l.dependencies),
      l !== null &&
        l.firstContext !== null &&
        (l.lanes & c && (rr = !0), (l.firstContext = null));
  }
  function Mr(l) {
    var c = tt ? l._currentValue : l._currentValue2;
    if (Vv !== l)
      if (((l = { context: l, memoizedValue: c, next: null }), tu === null)) {
        if (Df === null) throw Error(o(308));
        (tu = l), (Df.dependencies = { lanes: 0, firstContext: l });
      } else tu = tu.next = l;
    return c;
  }
  var gs = null,
    Ao = !1;
  function Xv(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function m1(l, c) {
    (l = l.updateQueue),
      c.updateQueue === l &&
        (c.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          effects: l.effects,
        });
  }
  function Hs(l, c) {
    return {
      eventTime: l,
      lane: c,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Po(l, c) {
    var M = l.updateQueue;
    M !== null &&
      ((M = M.shared),
      Dn !== null && l.mode & 1 && !(Dt & 2)
        ? ((l = M.interleaved),
          l === null
            ? ((c.next = c), gs === null ? (gs = [M]) : gs.push(M))
            : ((c.next = l.next), (l.next = c)),
          (M.interleaved = c))
        : ((l = M.pending),
          l === null ? (c.next = c) : ((c.next = l.next), (l.next = c)),
          (M.pending = c)));
  }
  function kf(l, c, M) {
    if (
      ((c = c.updateQueue), c !== null && ((c = c.shared), (M & 4194240) !== 0))
    ) {
      var E = c.lanes;
      (E &= l.pendingLanes), (M |= E), (c.lanes = M), ka(l, M);
    }
  }
  function g1(l, c) {
    var M = l.updateQueue,
      E = l.alternate;
    if (E !== null && ((E = E.updateQueue), M === E)) {
      var b = null,
        R = null;
      if (((M = M.firstBaseUpdate), M !== null)) {
        do {
          var z = {
            eventTime: M.eventTime,
            lane: M.lane,
            tag: M.tag,
            payload: M.payload,
            callback: M.callback,
            next: null,
          };
          R === null ? (b = R = z) : (R = R.next = z), (M = M.next);
        } while (M !== null);
        R === null ? (b = R = c) : (R = R.next = c);
      } else b = R = c;
      (M = {
        baseState: E.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: R,
        shared: E.shared,
        effects: E.effects,
      }),
        (l.updateQueue = M);
      return;
    }
    (l = M.lastBaseUpdate),
      l === null ? (M.firstBaseUpdate = c) : (l.next = c),
      (M.lastBaseUpdate = c);
  }
  function Uf(l, c, M, E) {
    var b = l.updateQueue;
    Ao = !1;
    var R = b.firstBaseUpdate,
      z = b.lastBaseUpdate,
      ie = b.shared.pending;
    if (ie !== null) {
      b.shared.pending = null;
      var me = ie,
        ke = me.next;
      (me.next = null), z === null ? (R = ke) : (z.next = ke), (z = me);
      var st = l.alternate;
      st !== null &&
        ((st = st.updateQueue),
        (ie = st.lastBaseUpdate),
        ie !== z &&
          (ie === null ? (st.firstBaseUpdate = ke) : (ie.next = ke),
          (st.lastBaseUpdate = me)));
    }
    if (R !== null) {
      var Et = b.baseState;
      (z = 0), (st = ke = me = null), (ie = R);
      do {
        var vt = ie.lane,
          an = ie.eventTime;
        if ((E & vt) === vt) {
          st !== null &&
            (st = st.next =
              {
                eventTime: an,
                lane: 0,
                tag: ie.tag,
                payload: ie.payload,
                callback: ie.callback,
                next: null,
              });
          e: {
            var ht = l,
              gi = ie;
            switch (((vt = c), (an = M), gi.tag)) {
              case 1:
                if (((ht = gi.payload), typeof ht == "function")) {
                  Et = ht.call(an, Et, vt);
                  break e;
                }
                Et = ht;
                break e;
              case 3:
                ht.flags = (ht.flags & -65537) | 128;
              case 0:
                if (
                  ((ht = gi.payload),
                  (vt = typeof ht == "function" ? ht.call(an, Et, vt) : ht),
                  vt == null)
                )
                  break e;
                Et = s({}, Et, vt);
                break e;
              case 2:
                Ao = !0;
            }
          }
          ie.callback !== null &&
            ie.lane !== 0 &&
            ((l.flags |= 64),
            (vt = b.effects),
            vt === null ? (b.effects = [ie]) : vt.push(ie));
        } else
          (an = {
            eventTime: an,
            lane: vt,
            tag: ie.tag,
            payload: ie.payload,
            callback: ie.callback,
            next: null,
          }),
            st === null ? ((ke = st = an), (me = Et)) : (st = st.next = an),
            (z |= vt);
        if (((ie = ie.next), ie === null)) {
          if (((ie = b.shared.pending), ie === null)) break;
          (vt = ie),
            (ie = vt.next),
            (vt.next = null),
            (b.lastBaseUpdate = vt),
            (b.shared.pending = null);
        }
      } while (1);
      if (
        (st === null && (me = Et),
        (b.baseState = me),
        (b.firstBaseUpdate = ke),
        (b.lastBaseUpdate = st),
        (c = b.shared.interleaved),
        c !== null)
      ) {
        b = c;
        do (z |= b.lane), (b = b.next);
        while (b !== c);
      } else R === null && (b.shared.lanes = 0);
      (du |= z), (l.lanes = z), (l.memoizedState = Et);
    }
  }
  function v1(l, c, M) {
    if (((l = c.effects), (c.effects = null), l !== null))
      for (c = 0; c < l.length; c++) {
        var E = l[c],
          b = E.callback;
        if (b !== null) {
          if (((E.callback = null), (E = M), typeof b != "function"))
            throw Error(o(191, b));
          b.call(E);
        }
      }
  }
  var y1 = new i.Component().refs;
  function qv(l, c, M, E) {
    (c = l.memoizedState),
      (M = M(E, c)),
      (M = M == null ? c : s({}, c, M)),
      (l.memoizedState = M),
      l.lanes === 0 && (l.updateQueue.baseState = M);
  }
  var Ff = {
    isMounted: function (l) {
      return (l = l._reactInternals) ? N(l) === l : !1;
    },
    enqueueSetState: function (l, c, M) {
      l = l._reactInternals;
      var E = Pi(),
        b = Io(l),
        R = Hs(E, b);
      (R.payload = c),
        M != null && (R.callback = M),
        Po(l, R),
        (c = Ar(l, b, E)),
        c !== null && kf(c, l, b);
    },
    enqueueReplaceState: function (l, c, M) {
      l = l._reactInternals;
      var E = Pi(),
        b = Io(l),
        R = Hs(E, b);
      (R.tag = 1),
        (R.payload = c),
        M != null && (R.callback = M),
        Po(l, R),
        (c = Ar(l, b, E)),
        c !== null && kf(c, l, b);
    },
    enqueueForceUpdate: function (l, c) {
      l = l._reactInternals;
      var M = Pi(),
        E = Io(l),
        b = Hs(M, E);
      (b.tag = 2),
        c != null && (b.callback = c),
        Po(l, b),
        (c = Ar(l, E, M)),
        c !== null && kf(c, l, E);
    },
  };
  function _1(l, c, M, E, b, R, z) {
    return (
      (l = l.stateNode),
      typeof l.shouldComponentUpdate == "function"
        ? l.shouldComponentUpdate(E, R, z)
        : c.prototype && c.prototype.isPureReactComponent
          ? !Of(M, E) || !Of(b, R)
          : !0
    );
  }
  function x1(l, c, M) {
    var E = !1,
      b = At,
      R = c.contextType;
    return (
      typeof R == "object" && R !== null
        ? (R = Mr(R))
        : ((b = tn(c) ? qt : et.current),
          (E = c.contextTypes),
          (R = (E = E != null) ? on(l, b) : At)),
      (c = new c(M, R)),
      (l.memoizedState =
        c.state !== null && c.state !== void 0 ? c.state : null),
      (c.updater = Ff),
      (l.stateNode = c),
      (c._reactInternals = l),
      E &&
        ((l = l.stateNode),
        (l.__reactInternalMemoizedUnmaskedChildContext = b),
        (l.__reactInternalMemoizedMaskedChildContext = R)),
      c
    );
  }
  function S1(l, c, M, E) {
    (l = c.state),
      typeof c.componentWillReceiveProps == "function" &&
        c.componentWillReceiveProps(M, E),
      typeof c.UNSAFE_componentWillReceiveProps == "function" &&
        c.UNSAFE_componentWillReceiveProps(M, E),
      c.state !== l && Ff.enqueueReplaceState(c, c.state, null);
  }
  function $v(l, c, M, E) {
    var b = l.stateNode;
    (b.props = M), (b.state = l.memoizedState), (b.refs = y1), Xv(l);
    var R = c.contextType;
    typeof R == "object" && R !== null
      ? (b.context = Mr(R))
      : ((R = tn(c) ? qt : et.current), (b.context = on(l, R))),
      (b.state = l.memoizedState),
      (R = c.getDerivedStateFromProps),
      typeof R == "function" && (qv(l, c, R, M), (b.state = l.memoizedState)),
      typeof c.getDerivedStateFromProps == "function" ||
        typeof b.getSnapshotBeforeUpdate == "function" ||
        (typeof b.UNSAFE_componentWillMount != "function" &&
          typeof b.componentWillMount != "function") ||
        ((c = b.state),
        typeof b.componentWillMount == "function" && b.componentWillMount(),
        typeof b.UNSAFE_componentWillMount == "function" &&
          b.UNSAFE_componentWillMount(),
        c !== b.state && Ff.enqueueReplaceState(b, b.state, null),
        Uf(l, M, b, E),
        (b.state = l.memoizedState)),
      typeof b.componentDidMount == "function" && (l.flags |= 4194308);
  }
  var iu = [],
    ru = 0,
    Bf = null,
    zf = 0,
    Er = [],
    Tr = 0,
    Ba = null,
    Vs = 1,
    Gs = "";
  function za(l, c) {
    (iu[ru++] = zf), (iu[ru++] = Bf), (Bf = l), (zf = c);
  }
  function w1(l, c, M) {
    (Er[Tr++] = Vs), (Er[Tr++] = Gs), (Er[Tr++] = Ba), (Ba = l);
    var E = Vs;
    l = Gs;
    var b = 32 - Pn(E) - 1;
    (E &= ~(1 << b)), (M += 1);
    var R = 32 - Pn(c) + b;
    if (30 < R) {
      var z = b - (b % 5);
      (R = (E & ((1 << z) - 1)).toString(32)),
        (E >>= z),
        (b -= z),
        (Vs = (1 << (32 - Pn(c) + b)) | (M << b) | E),
        (Gs = R + l);
    } else (Vs = (1 << R) | (M << b) | E), (Gs = l);
  }
  function Yv(l) {
    l.return !== null && (za(l, 1), w1(l, 1, 0));
  }
  function Kv(l) {
    for (; l === Bf; )
      (Bf = iu[--ru]), (iu[ru] = null), (zf = iu[--ru]), (iu[ru] = null);
    for (; l === Ba; )
      (Ba = Er[--Tr]),
        (Er[Tr] = null),
        (Gs = Er[--Tr]),
        (Er[Tr] = null),
        (Vs = Er[--Tr]),
        (Er[Tr] = null);
  }
  var nr = null,
    ir = null,
    gn = !1,
    Zc = !1,
    qr = null;
  function M1(l, c) {
    var M = Pr(5, null, null, 0);
    (M.elementType = "DELETED"),
      (M.stateNode = c),
      (M.return = l),
      (c = l.deletions),
      c === null ? ((l.deletions = [M]), (l.flags |= 16)) : c.push(M);
  }
  function E1(l, c) {
    switch (l.tag) {
      case 5:
        return (
          (c = en(c, l.type, l.pendingProps)),
          c !== null ? ((l.stateNode = c), (nr = l), (ir = Mo(c)), !0) : !1
        );
      case 6:
        return (
          (c = zn(c, l.pendingProps)),
          c !== null ? ((l.stateNode = c), (nr = l), (ir = null), !0) : !1
        );
      case 13:
        if (((c = Ci(c)), c !== null)) {
          var M = Ba !== null ? { id: Vs, overflow: Gs } : null;
          return (
            (l.memoizedState = {
              dehydrated: c,
              treeContext: M,
              retryLane: 1073741824,
            }),
            (M = Pr(18, null, null, 0)),
            (M.stateNode = c),
            (M.return = l),
            (l.child = M),
            (nr = l),
            (ir = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function Qv(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function Zv(l) {
    if (gn) {
      var c = ir;
      if (c) {
        var M = c;
        if (!E1(l, c)) {
          if (Qv(l)) throw Error(o(418));
          c = hs(M);
          var E = nr;
          c && E1(l, c)
            ? M1(E, M)
            : ((l.flags = (l.flags & -4097) | 2), (gn = !1), (nr = l));
        }
      } else {
        if (Qv(l)) throw Error(o(418));
        (l.flags = (l.flags & -4097) | 2), (gn = !1), (nr = l);
      }
    }
  }
  function T1(l) {
    for (
      l = l.return;
      l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;

    )
      l = l.return;
    nr = l;
  }
  function Jc(l) {
    if (!be || l !== nr) return !1;
    if (!gn) return T1(l), (gn = !0), !1;
    if (
      l.tag !== 3 &&
      (l.tag !== 5 || (ve(l.type) && !de(l.type, l.memoizedProps)))
    ) {
      var c = ir;
      if (c) {
        if (Qv(l)) {
          for (l = ir; l; ) l = hs(l);
          throw Error(o(418));
        }
        for (; c; ) M1(l, c), (c = hs(c));
      }
    }
    if ((T1(l), l.tag === 13)) {
      if (!be) throw Error(o(316));
      if (((l = l.memoizedState), (l = l !== null ? l.dehydrated : null), !l))
        throw Error(o(317));
      ir = O(l);
    } else ir = nr ? hs(l.stateNode) : null;
    return !0;
  }
  function su() {
    be && ((ir = nr = null), (Zc = gn = !1));
  }
  function Jv(l) {
    qr === null ? (qr = [l]) : qr.push(l);
  }
  function ed(l, c, M) {
    if (
      ((l = M.ref),
      l !== null && typeof l != "function" && typeof l != "object")
    ) {
      if (M._owner) {
        if (((M = M._owner), M)) {
          if (M.tag !== 1) throw Error(o(309));
          var E = M.stateNode;
        }
        if (!E) throw Error(o(147, l));
        var b = E,
          R = "" + l;
        return c !== null &&
          c.ref !== null &&
          typeof c.ref == "function" &&
          c.ref._stringRef === R
          ? c.ref
          : ((c = function (z) {
              var ie = b.refs;
              ie === y1 && (ie = b.refs = {}),
                z === null ? delete ie[R] : (ie[R] = z);
            }),
            (c._stringRef = R),
            c);
      }
      if (typeof l != "string") throw Error(o(284));
      if (!M._owner) throw Error(o(290, l));
    }
    return l;
  }
  function Hf(l, c) {
    throw (
      ((l = Object.prototype.toString.call(c)),
      Error(
        o(
          31,
          l === "[object Object]"
            ? "object with keys {" + Object.keys(c).join(", ") + "}"
            : l,
        ),
      ))
    );
  }
  function C1(l) {
    var c = l._init;
    return c(l._payload);
  }
  function b1(l) {
    function c(he, oe) {
      if (l) {
        var pe = he.deletions;
        pe === null ? ((he.deletions = [oe]), (he.flags |= 16)) : pe.push(oe);
      }
    }
    function M(he, oe) {
      if (!l) return null;
      for (; oe !== null; ) c(he, oe), (oe = oe.sibling);
      return null;
    }
    function E(he, oe) {
      for (he = new Map(); oe !== null; )
        oe.key !== null ? he.set(oe.key, oe) : he.set(oe.index, oe),
          (oe = oe.sibling);
      return he;
    }
    function b(he, oe) {
      return (he = No(he, oe)), (he.index = 0), (he.sibling = null), he;
    }
    function R(he, oe, pe) {
      return (
        (he.index = pe),
        l
          ? ((pe = he.alternate),
            pe !== null
              ? ((pe = pe.index), pe < oe ? ((he.flags |= 2), oe) : pe)
              : ((he.flags |= 2), oe))
          : ((he.flags |= 1048576), oe)
      );
    }
    function z(he) {
      return l && he.alternate === null && (he.flags |= 2), he;
    }
    function ie(he, oe, pe, Ye) {
      return oe === null || oe.tag !== 6
        ? ((oe = ky(pe, he.mode, Ye)), (oe.return = he), oe)
        : ((oe = b(oe, pe)), (oe.return = he), oe);
    }
    function me(he, oe, pe, Ye) {
      var ut = pe.type;
      return ut === p
        ? st(he, oe, pe.props.children, Ye, pe.key)
        : oe !== null &&
            (oe.elementType === ut ||
              (typeof ut == "object" &&
                ut !== null &&
                ut.$$typeof === g &&
                C1(ut) === oe.type))
          ? ((Ye = b(oe, pe.props)),
            (Ye.ref = ed(he, oe, pe)),
            (Ye.return = he),
            Ye)
          : ((Ye = yp(pe.type, pe.key, pe.props, null, he.mode, Ye)),
            (Ye.ref = ed(he, oe, pe)),
            (Ye.return = he),
            Ye);
    }
    function ke(he, oe, pe, Ye) {
      return oe === null ||
        oe.tag !== 4 ||
        oe.stateNode.containerInfo !== pe.containerInfo ||
        oe.stateNode.implementation !== pe.implementation
        ? ((oe = Uy(pe, he.mode, Ye)), (oe.return = he), oe)
        : ((oe = b(oe, pe.children || [])), (oe.return = he), oe);
    }
    function st(he, oe, pe, Ye, ut) {
      return oe === null || oe.tag !== 7
        ? ((oe = qa(pe, he.mode, Ye, ut)), (oe.return = he), oe)
        : ((oe = b(oe, pe)), (oe.return = he), oe);
    }
    function Et(he, oe, pe) {
      if ((typeof oe == "string" && oe !== "") || typeof oe == "number")
        return (oe = ky("" + oe, he.mode, pe)), (oe.return = he), oe;
      if (typeof oe == "object" && oe !== null) {
        switch (oe.$$typeof) {
          case u:
            return (
              (pe = yp(oe.type, oe.key, oe.props, null, he.mode, pe)),
              (pe.ref = ed(he, null, oe)),
              (pe.return = he),
              pe
            );
          case h:
            return (oe = Uy(oe, he.mode, pe)), (oe.return = he), oe;
          case g:
            var Ye = oe._init;
            return Et(he, Ye(oe._payload), pe);
        }
        if (X(oe) || C(oe))
          return (oe = qa(oe, he.mode, pe, null)), (oe.return = he), oe;
        Hf(he, oe);
      }
      return null;
    }
    function vt(he, oe, pe, Ye) {
      var ut = oe !== null ? oe.key : null;
      if ((typeof pe == "string" && pe !== "") || typeof pe == "number")
        return ut !== null ? null : ie(he, oe, "" + pe, Ye);
      if (typeof pe == "object" && pe !== null) {
        switch (pe.$$typeof) {
          case u:
            return pe.key === ut ? me(he, oe, pe, Ye) : null;
          case h:
            return pe.key === ut ? ke(he, oe, pe, Ye) : null;
          case g:
            return (ut = pe._init), vt(he, oe, ut(pe._payload), Ye);
        }
        if (X(pe) || C(pe))
          return ut !== null ? null : st(he, oe, pe, Ye, null);
        Hf(he, pe);
      }
      return null;
    }
    function an(he, oe, pe, Ye, ut) {
      if ((typeof Ye == "string" && Ye !== "") || typeof Ye == "number")
        return (he = he.get(pe) || null), ie(oe, he, "" + Ye, ut);
      if (typeof Ye == "object" && Ye !== null) {
        switch (Ye.$$typeof) {
          case u:
            return (
              (he = he.get(Ye.key === null ? pe : Ye.key) || null),
              me(oe, he, Ye, ut)
            );
          case h:
            return (
              (he = he.get(Ye.key === null ? pe : Ye.key) || null),
              ke(oe, he, Ye, ut)
            );
          case g:
            var Ot = Ye._init;
            return an(he, oe, pe, Ot(Ye._payload), ut);
        }
        if (X(Ye) || C(Ye))
          return (he = he.get(pe) || null), st(oe, he, Ye, ut, null);
        Hf(oe, Ye);
      }
      return null;
    }
    function ht(he, oe, pe, Ye) {
      for (
        var ut = null, Ot = null, Tt = oe, $t = (oe = 0), Kn = null;
        Tt !== null && $t < pe.length;
        $t++
      ) {
        Tt.index > $t ? ((Kn = Tt), (Tt = null)) : (Kn = Tt.sibling);
        var Yt = vt(he, Tt, pe[$t], Ye);
        if (Yt === null) {
          Tt === null && (Tt = Kn);
          break;
        }
        l && Tt && Yt.alternate === null && c(he, Tt),
          (oe = R(Yt, oe, $t)),
          Ot === null ? (ut = Yt) : (Ot.sibling = Yt),
          (Ot = Yt),
          (Tt = Kn);
      }
      if ($t === pe.length) return M(he, Tt), gn && za(he, $t), ut;
      if (Tt === null) {
        for (; $t < pe.length; $t++)
          (Tt = Et(he, pe[$t], Ye)),
            Tt !== null &&
              ((oe = R(Tt, oe, $t)),
              Ot === null ? (ut = Tt) : (Ot.sibling = Tt),
              (Ot = Tt));
        return gn && za(he, $t), ut;
      }
      for (Tt = E(he, Tt); $t < pe.length; $t++)
        (Kn = an(Tt, he, $t, pe[$t], Ye)),
          Kn !== null &&
            (l &&
              Kn.alternate !== null &&
              Tt.delete(Kn.key === null ? $t : Kn.key),
            (oe = R(Kn, oe, $t)),
            Ot === null ? (ut = Kn) : (Ot.sibling = Kn),
            (Ot = Kn));
      return (
        l &&
          Tt.forEach(function (Do) {
            return c(he, Do);
          }),
        gn && za(he, $t),
        ut
      );
    }
    function gi(he, oe, pe, Ye) {
      var ut = C(pe);
      if (typeof ut != "function") throw Error(o(150));
      if (((pe = ut.call(pe)), pe == null)) throw Error(o(151));
      for (
        var Ot = (ut = null), Tt = oe, $t = (oe = 0), Kn = null, Yt = pe.next();
        Tt !== null && !Yt.done;
        $t++, Yt = pe.next()
      ) {
        Tt.index > $t ? ((Kn = Tt), (Tt = null)) : (Kn = Tt.sibling);
        var Do = vt(he, Tt, Yt.value, Ye);
        if (Do === null) {
          Tt === null && (Tt = Kn);
          break;
        }
        l && Tt && Do.alternate === null && c(he, Tt),
          (oe = R(Do, oe, $t)),
          Ot === null ? (ut = Do) : (Ot.sibling = Do),
          (Ot = Do),
          (Tt = Kn);
      }
      if (Yt.done) return M(he, Tt), gn && za(he, $t), ut;
      if (Tt === null) {
        for (; !Yt.done; $t++, Yt = pe.next())
          (Yt = Et(he, Yt.value, Ye)),
            Yt !== null &&
              ((oe = R(Yt, oe, $t)),
              Ot === null ? (ut = Yt) : (Ot.sibling = Yt),
              (Ot = Yt));
        return gn && za(he, $t), ut;
      }
      for (Tt = E(he, Tt); !Yt.done; $t++, Yt = pe.next())
        (Yt = an(Tt, he, $t, Yt.value, Ye)),
          Yt !== null &&
            (l &&
              Yt.alternate !== null &&
              Tt.delete(Yt.key === null ? $t : Yt.key),
            (oe = R(Yt, oe, $t)),
            Ot === null ? (ut = Yt) : (Ot.sibling = Yt),
            (Ot = Yt));
      return (
        l &&
          Tt.forEach(function (PI) {
            return c(he, PI);
          }),
        gn && za(he, $t),
        ut
      );
    }
    function Rr(he, oe, pe, Ye) {
      if (
        (typeof pe == "object" &&
          pe !== null &&
          pe.type === p &&
          pe.key === null &&
          (pe = pe.props.children),
        typeof pe == "object" && pe !== null)
      ) {
        switch (pe.$$typeof) {
          case u:
            e: {
              for (var ut = pe.key, Ot = oe; Ot !== null; ) {
                if (Ot.key === ut) {
                  if (((ut = pe.type), ut === p)) {
                    if (Ot.tag === 7) {
                      M(he, Ot.sibling),
                        (oe = b(Ot, pe.props.children)),
                        (oe.return = he),
                        (he = oe);
                      break e;
                    }
                  } else if (
                    Ot.elementType === ut ||
                    (typeof ut == "object" &&
                      ut !== null &&
                      ut.$$typeof === g &&
                      C1(ut) === Ot.type)
                  ) {
                    M(he, Ot.sibling),
                      (oe = b(Ot, pe.props)),
                      (oe.ref = ed(he, Ot, pe)),
                      (oe.return = he),
                      (he = oe);
                    break e;
                  }
                  M(he, Ot);
                  break;
                } else c(he, Ot);
                Ot = Ot.sibling;
              }
              pe.type === p
                ? ((oe = qa(pe.props.children, he.mode, Ye, pe.key)),
                  (oe.return = he),
                  (he = oe))
                : ((Ye = yp(pe.type, pe.key, pe.props, null, he.mode, Ye)),
                  (Ye.ref = ed(he, oe, pe)),
                  (Ye.return = he),
                  (he = Ye));
            }
            return z(he);
          case h:
            e: {
              for (Ot = pe.key; oe !== null; ) {
                if (oe.key === Ot)
                  if (
                    oe.tag === 4 &&
                    oe.stateNode.containerInfo === pe.containerInfo &&
                    oe.stateNode.implementation === pe.implementation
                  ) {
                    M(he, oe.sibling),
                      (oe = b(oe, pe.children || [])),
                      (oe.return = he),
                      (he = oe);
                    break e;
                  } else {
                    M(he, oe);
                    break;
                  }
                else c(he, oe);
                oe = oe.sibling;
              }
              (oe = Uy(pe, he.mode, Ye)), (oe.return = he), (he = oe);
            }
            return z(he);
          case g:
            return (Ot = pe._init), Rr(he, oe, Ot(pe._payload), Ye);
        }
        if (X(pe)) return ht(he, oe, pe, Ye);
        if (C(pe)) return gi(he, oe, pe, Ye);
        Hf(he, pe);
      }
      return (typeof pe == "string" && pe !== "") || typeof pe == "number"
        ? ((pe = "" + pe),
          oe !== null && oe.tag === 6
            ? (M(he, oe.sibling), (oe = b(oe, pe)), (oe.return = he), (he = oe))
            : (M(he, oe),
              (oe = ky(pe, he.mode, Ye)),
              (oe.return = he),
              (he = oe)),
          z(he))
        : M(he, oe);
    }
    return Rr;
  }
  var ou = b1(!0),
    A1 = b1(!1),
    td = {},
    Cr = xt(td),
    nd = xt(td),
    au = xt(td);
  function vs(l) {
    if (l === td) throw Error(o(174));
    return l;
  }
  function ey(l, c) {
    Pe(au, c), Pe(nd, l), Pe(Cr, td), (l = ne(c)), Ne(Cr), Pe(Cr, l);
  }
  function lu() {
    Ne(Cr), Ne(nd), Ne(au);
  }
  function P1(l) {
    var c = vs(au.current),
      M = vs(Cr.current);
    (c = k(M, l.type, c)), M !== c && (Pe(nd, l), Pe(Cr, c));
  }
  function ty(l) {
    nd.current === l && (Ne(Cr), Ne(nd));
  }
  var yn = xt(0);
  function Vf(l) {
    for (var c = l; c !== null; ) {
      if (c.tag === 13) {
        var M = c.memoizedState;
        if (M !== null && ((M = M.dehydrated), M === null || So(M) || ds(M)))
          return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128) return c;
      } else if (c.child !== null) {
        (c.child.return = c), (c = c.child);
        continue;
      }
      if (c === l) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === l) return null;
        c = c.return;
      }
      (c.sibling.return = c.return), (c = c.sibling);
    }
    return null;
  }
  var ny = [];
  function iy() {
    for (var l = 0; l < ny.length; l++) {
      var c = ny[l];
      tt
        ? (c._workInProgressVersionPrimary = null)
        : (c._workInProgressVersionSecondary = null);
    }
    ny.length = 0;
  }
  var Gf = a.ReactCurrentDispatcher,
    br = a.ReactCurrentBatchConfig,
    uu = 0,
    Tn = null,
    fi = null,
    Yn = null,
    Wf = !1,
    id = !1,
    rd = 0,
    eI = 0;
  function pi() {
    throw Error(o(321));
  }
  function ry(l, c) {
    if (c === null) return !1;
    for (var M = 0; M < c.length && M < l.length; M++)
      if (!wr(l[M], c[M])) return !1;
    return !0;
  }
  function sy(l, c, M, E, b, R) {
    if (
      ((uu = R),
      (Tn = c),
      (c.memoizedState = null),
      (c.updateQueue = null),
      (c.lanes = 0),
      (Gf.current = l === null || l.memoizedState === null ? rI : sI),
      (l = M(E, b)),
      id)
    ) {
      R = 0;
      do {
        if (((id = !1), (rd = 0), 25 <= R)) throw Error(o(301));
        (R += 1),
          (Yn = fi = null),
          (c.updateQueue = null),
          (Gf.current = oI),
          (l = M(E, b));
      } while (id);
    }
    if (
      ((Gf.current = Yf),
      (c = fi !== null && fi.next !== null),
      (uu = 0),
      (Yn = fi = Tn = null),
      (Wf = !1),
      c)
    )
      throw Error(o(300));
    return l;
  }
  function oy() {
    var l = rd !== 0;
    return (rd = 0), l;
  }
  function Ws() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Yn === null ? (Tn.memoizedState = Yn = l) : (Yn = Yn.next = l), Yn;
  }
  function ys() {
    if (fi === null) {
      var l = Tn.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = fi.next;
    var c = Yn === null ? Tn.memoizedState : Yn.next;
    if (c !== null) (Yn = c), (fi = l);
    else {
      if (l === null) throw Error(o(310));
      (fi = l),
        (l = {
          memoizedState: fi.memoizedState,
          baseState: fi.baseState,
          baseQueue: fi.baseQueue,
          queue: fi.queue,
          next: null,
        }),
        Yn === null ? (Tn.memoizedState = Yn = l) : (Yn = Yn.next = l);
    }
    return Yn;
  }
  function Ha(l, c) {
    return typeof c == "function" ? c(l) : c;
  }
  function jf(l) {
    var c = ys(),
      M = c.queue;
    if (M === null) throw Error(o(311));
    M.lastRenderedReducer = l;
    var E = fi,
      b = E.baseQueue,
      R = M.pending;
    if (R !== null) {
      if (b !== null) {
        var z = b.next;
        (b.next = R.next), (R.next = z);
      }
      (E.baseQueue = b = R), (M.pending = null);
    }
    if (b !== null) {
      (R = b.next), (E = E.baseState);
      var ie = (z = null),
        me = null,
        ke = R;
      do {
        var st = ke.lane;
        if ((uu & st) === st)
          me !== null &&
            (me = me.next =
              {
                lane: 0,
                action: ke.action,
                hasEagerState: ke.hasEagerState,
                eagerState: ke.eagerState,
                next: null,
              }),
            (E = ke.hasEagerState ? ke.eagerState : l(E, ke.action));
        else {
          var Et = {
            lane: st,
            action: ke.action,
            hasEagerState: ke.hasEagerState,
            eagerState: ke.eagerState,
            next: null,
          };
          me === null ? ((ie = me = Et), (z = E)) : (me = me.next = Et),
            (Tn.lanes |= st),
            (du |= st);
        }
        ke = ke.next;
      } while (ke !== null && ke !== R);
      me === null ? (z = E) : (me.next = ie),
        wr(E, c.memoizedState) || (rr = !0),
        (c.memoizedState = E),
        (c.baseState = z),
        (c.baseQueue = me),
        (M.lastRenderedState = E);
    }
    if (((l = M.interleaved), l !== null)) {
      b = l;
      do (R = b.lane), (Tn.lanes |= R), (du |= R), (b = b.next);
      while (b !== l);
    } else b === null && (M.lanes = 0);
    return [c.memoizedState, M.dispatch];
  }
  function Xf(l) {
    var c = ys(),
      M = c.queue;
    if (M === null) throw Error(o(311));
    M.lastRenderedReducer = l;
    var E = M.dispatch,
      b = M.pending,
      R = c.memoizedState;
    if (b !== null) {
      M.pending = null;
      var z = (b = b.next);
      do (R = l(R, z.action)), (z = z.next);
      while (z !== b);
      wr(R, c.memoizedState) || (rr = !0),
        (c.memoizedState = R),
        c.baseQueue === null && (c.baseState = R),
        (M.lastRenderedState = R);
    }
    return [R, E];
  }
  function R1() {}
  function L1(l, c) {
    var M = Tn,
      E = ys(),
      b = c(),
      R = !wr(E.memoizedState, b);
    if (
      (R && ((E.memoizedState = b), (rr = !0)),
      (E = E.queue),
      od(N1.bind(null, M, E, l), [l]),
      E.getSnapshot !== c || R || (Yn !== null && Yn.memoizedState.tag & 1))
    ) {
      if (
        ((M.flags |= 2048),
        sd(9, O1.bind(null, M, E, b, c), void 0, null),
        Dn === null)
      )
        throw Error(o(349));
      uu & 30 || I1(M, c, b);
    }
    return b;
  }
  function I1(l, c, M) {
    (l.flags |= 16384),
      (l = { getSnapshot: c, value: M }),
      (c = Tn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (Tn.updateQueue = c),
          (c.stores = [l]))
        : ((M = c.stores), M === null ? (c.stores = [l]) : M.push(l));
  }
  function O1(l, c, M, E) {
    (c.value = M), (c.getSnapshot = E), D1(c) && Ar(l, 1, -1);
  }
  function N1(l, c, M) {
    return M(function () {
      D1(c) && Ar(l, 1, -1);
    });
  }
  function D1(l) {
    var c = l.getSnapshot;
    l = l.value;
    try {
      var M = c();
      return !wr(l, M);
    } catch {
      return !0;
    }
  }
  function ay(l) {
    var c = Ws();
    return (
      typeof l == "function" && (l = l()),
      (c.memoizedState = c.baseState = l),
      (l = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ha,
        lastRenderedState: l,
      }),
      (c.queue = l),
      (l = l.dispatch = iI.bind(null, Tn, l)),
      [c.memoizedState, l]
    );
  }
  function sd(l, c, M, E) {
    return (
      (l = { tag: l, create: c, destroy: M, deps: E, next: null }),
      (c = Tn.updateQueue),
      c === null
        ? ((c = { lastEffect: null, stores: null }),
          (Tn.updateQueue = c),
          (c.lastEffect = l.next = l))
        : ((M = c.lastEffect),
          M === null
            ? (c.lastEffect = l.next = l)
            : ((E = M.next), (M.next = l), (l.next = E), (c.lastEffect = l))),
      l
    );
  }
  function k1() {
    return ys().memoizedState;
  }
  function qf(l, c, M, E) {
    var b = Ws();
    (Tn.flags |= l),
      (b.memoizedState = sd(1 | c, M, void 0, E === void 0 ? null : E));
  }
  function $f(l, c, M, E) {
    var b = ys();
    E = E === void 0 ? null : E;
    var R = void 0;
    if (fi !== null) {
      var z = fi.memoizedState;
      if (((R = z.destroy), E !== null && ry(E, z.deps))) {
        b.memoizedState = sd(c, M, R, E);
        return;
      }
    }
    (Tn.flags |= l), (b.memoizedState = sd(1 | c, M, R, E));
  }
  function ly(l, c) {
    return qf(8390656, 8, l, c);
  }
  function od(l, c) {
    return $f(2048, 8, l, c);
  }
  function U1(l, c) {
    return $f(4, 2, l, c);
  }
  function F1(l, c) {
    return $f(4, 4, l, c);
  }
  function B1(l, c) {
    if (typeof c == "function")
      return (
        (l = l()),
        c(l),
        function () {
          c(null);
        }
      );
    if (c != null)
      return (
        (l = l()),
        (c.current = l),
        function () {
          c.current = null;
        }
      );
  }
  function z1(l, c, M) {
    return (
      (M = M != null ? M.concat([l]) : null), $f(4, 4, B1.bind(null, c, l), M)
    );
  }
  function uy() {}
  function H1(l, c) {
    var M = ys();
    c = c === void 0 ? null : c;
    var E = M.memoizedState;
    return E !== null && c !== null && ry(c, E[1])
      ? E[0]
      : ((M.memoizedState = [l, c]), l);
  }
  function V1(l, c) {
    var M = ys();
    c = c === void 0 ? null : c;
    var E = M.memoizedState;
    return E !== null && c !== null && ry(c, E[1])
      ? E[0]
      : ((l = l()), (M.memoizedState = [l, c]), l);
  }
  function tI(l, c) {
    var M = Ut;
    (Ut = M !== 0 && 4 > M ? M : 4), l(!0);
    var E = br.transition;
    br.transition = {};
    try {
      l(!1), c();
    } finally {
      (Ut = M), (br.transition = E);
    }
  }
  function G1() {
    return ys().memoizedState;
  }
  function nI(l, c, M) {
    var E = Io(l);
    (M = {
      lane: E,
      action: M,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      W1(l)
        ? j1(c, M)
        : (X1(l, c, M),
          (M = Pi()),
          (l = Ar(l, E, M)),
          l !== null && q1(l, c, E));
  }
  function iI(l, c, M) {
    var E = Io(l),
      b = {
        lane: E,
        action: M,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (W1(l)) j1(c, b);
    else {
      X1(l, c, b);
      var R = l.alternate;
      if (
        l.lanes === 0 &&
        (R === null || R.lanes === 0) &&
        ((R = c.lastRenderedReducer), R !== null)
      )
        try {
          var z = c.lastRenderedState,
            ie = R(z, M);
          if (((b.hasEagerState = !0), (b.eagerState = ie), wr(ie, z))) return;
        } catch {
        } finally {
        }
      (M = Pi()), (l = Ar(l, E, M)), l !== null && q1(l, c, E);
    }
  }
  function W1(l) {
    var c = l.alternate;
    return l === Tn || (c !== null && c === Tn);
  }
  function j1(l, c) {
    id = Wf = !0;
    var M = l.pending;
    M === null ? (c.next = c) : ((c.next = M.next), (M.next = c)),
      (l.pending = c);
  }
  function X1(l, c, M) {
    Dn !== null && l.mode & 1 && !(Dt & 2)
      ? ((l = c.interleaved),
        l === null
          ? ((M.next = M), gs === null ? (gs = [c]) : gs.push(c))
          : ((M.next = l.next), (l.next = M)),
        (c.interleaved = M))
      : ((l = c.pending),
        l === null ? (M.next = M) : ((M.next = l.next), (l.next = M)),
        (c.pending = M));
  }
  function q1(l, c, M) {
    if (M & 4194240) {
      var E = c.lanes;
      (E &= l.pendingLanes), (M |= E), (c.lanes = M), ka(l, M);
    }
  }
  var Yf = {
      readContext: Mr,
      useCallback: pi,
      useContext: pi,
      useEffect: pi,
      useImperativeHandle: pi,
      useInsertionEffect: pi,
      useLayoutEffect: pi,
      useMemo: pi,
      useReducer: pi,
      useRef: pi,
      useState: pi,
      useDebugValue: pi,
      useDeferredValue: pi,
      useTransition: pi,
      useMutableSource: pi,
      useSyncExternalStore: pi,
      useId: pi,
      unstable_isNewReconciler: !1,
    },
    rI = {
      readContext: Mr,
      useCallback: function (l, c) {
        return (Ws().memoizedState = [l, c === void 0 ? null : c]), l;
      },
      useContext: Mr,
      useEffect: ly,
      useImperativeHandle: function (l, c, M) {
        return (
          (M = M != null ? M.concat([l]) : null),
          qf(4194308, 4, B1.bind(null, c, l), M)
        );
      },
      useLayoutEffect: function (l, c) {
        return qf(4194308, 4, l, c);
      },
      useInsertionEffect: function (l, c) {
        return qf(4, 2, l, c);
      },
      useMemo: function (l, c) {
        var M = Ws();
        return (
          (c = c === void 0 ? null : c),
          (l = l()),
          (M.memoizedState = [l, c]),
          l
        );
      },
      useReducer: function (l, c, M) {
        var E = Ws();
        return (
          (c = M !== void 0 ? M(c) : c),
          (E.memoizedState = E.baseState = c),
          (l = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: l,
            lastRenderedState: c,
          }),
          (E.queue = l),
          (l = l.dispatch = nI.bind(null, Tn, l)),
          [E.memoizedState, l]
        );
      },
      useRef: function (l) {
        var c = Ws();
        return (l = { current: l }), (c.memoizedState = l);
      },
      useState: ay,
      useDebugValue: uy,
      useDeferredValue: function (l) {
        var c = ay(l),
          M = c[0],
          E = c[1];
        return (
          ly(
            function () {
              var b = br.transition;
              br.transition = {};
              try {
                E(l);
              } finally {
                br.transition = b;
              }
            },
            [l],
          ),
          M
        );
      },
      useTransition: function () {
        var l = ay(!1),
          c = l[0];
        return (l = tI.bind(null, l[1])), (Ws().memoizedState = l), [c, l];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (l, c, M) {
        var E = Tn,
          b = Ws();
        if (gn) {
          if (M === void 0) throw Error(o(407));
          M = M();
        } else {
          if (((M = c()), Dn === null)) throw Error(o(349));
          uu & 30 || I1(E, c, M);
        }
        b.memoizedState = M;
        var R = { value: M, getSnapshot: c };
        return (
          (b.queue = R),
          ly(N1.bind(null, E, R, l), [l]),
          (E.flags |= 2048),
          sd(9, O1.bind(null, E, R, M, c), void 0, null),
          M
        );
      },
      useId: function () {
        var l = Ws(),
          c = Dn.identifierPrefix;
        if (gn) {
          var M = Gs,
            E = Vs;
          (M = (E & ~(1 << (32 - Pn(E) - 1))).toString(32) + M),
            (c = ":" + c + "R" + M),
            (M = rd++),
            0 < M && (c += "H" + M.toString(32)),
            (c += ":");
        } else (M = eI++), (c = ":" + c + "r" + M.toString(32) + ":");
        return (l.memoizedState = c);
      },
      unstable_isNewReconciler: !1,
    },
    sI = {
      readContext: Mr,
      useCallback: H1,
      useContext: Mr,
      useEffect: od,
      useImperativeHandle: z1,
      useInsertionEffect: U1,
      useLayoutEffect: F1,
      useMemo: V1,
      useReducer: jf,
      useRef: k1,
      useState: function () {
        return jf(Ha);
      },
      useDebugValue: uy,
      useDeferredValue: function (l) {
        var c = jf(Ha),
          M = c[0],
          E = c[1];
        return (
          od(
            function () {
              var b = br.transition;
              br.transition = {};
              try {
                E(l);
              } finally {
                br.transition = b;
              }
            },
            [l],
          ),
          M
        );
      },
      useTransition: function () {
        var l = jf(Ha)[0],
          c = ys().memoizedState;
        return [l, c];
      },
      useMutableSource: R1,
      useSyncExternalStore: L1,
      useId: G1,
      unstable_isNewReconciler: !1,
    },
    oI = {
      readContext: Mr,
      useCallback: H1,
      useContext: Mr,
      useEffect: od,
      useImperativeHandle: z1,
      useInsertionEffect: U1,
      useLayoutEffect: F1,
      useMemo: V1,
      useReducer: Xf,
      useRef: k1,
      useState: function () {
        return Xf(Ha);
      },
      useDebugValue: uy,
      useDeferredValue: function (l) {
        var c = Xf(Ha),
          M = c[0],
          E = c[1];
        return (
          od(
            function () {
              var b = br.transition;
              br.transition = {};
              try {
                E(l);
              } finally {
                br.transition = b;
              }
            },
            [l],
          ),
          M
        );
      },
      useTransition: function () {
        var l = Xf(Ha)[0],
          c = ys().memoizedState;
        return [l, c];
      },
      useMutableSource: R1,
      useSyncExternalStore: L1,
      useId: G1,
      unstable_isNewReconciler: !1,
    };
  function cy(l, c) {
    try {
      var M = "",
        E = c;
      do (M += JL(E)), (E = E.return);
      while (E);
      var b = M;
    } catch (R) {
      b =
        `
Error generating stack: ` +
        R.message +
        `
` +
        R.stack;
    }
    return { value: l, source: c, stack: b };
  }
  function dy(l, c) {
    try {
      console.error(c.value);
    } catch (M) {
      setTimeout(function () {
        throw M;
      });
    }
  }
  var aI = typeof WeakMap == "function" ? WeakMap : Map;
  function $1(l, c, M) {
    (M = Hs(-1, M)), (M.tag = 3), (M.payload = { element: null });
    var E = c.value;
    return (
      (M.callback = function () {
        dp || ((dp = !0), (Py = E)), dy(l, c);
      }),
      M
    );
  }
  function Y1(l, c, M) {
    (M = Hs(-1, M)), (M.tag = 3);
    var E = l.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var b = c.value;
      (M.payload = function () {
        return E(b);
      }),
        (M.callback = function () {
          dy(l, c);
        });
    }
    var R = l.stateNode;
    return (
      R !== null &&
        typeof R.componentDidCatch == "function" &&
        (M.callback = function () {
          dy(l, c),
            typeof E != "function" &&
              (Ro === null ? (Ro = new Set([this])) : Ro.add(this));
          var z = c.stack;
          this.componentDidCatch(c.value, {
            componentStack: z !== null ? z : "",
          });
        }),
      M
    );
  }
  function K1(l, c, M) {
    var E = l.pingCache;
    if (E === null) {
      E = l.pingCache = new aI();
      var b = new Set();
      E.set(c, b);
    } else (b = E.get(c)), b === void 0 && ((b = new Set()), E.set(c, b));
    b.has(M) || (b.add(M), (l = SI.bind(null, l, c, M)), c.then(l, l));
  }
  function Q1(l) {
    do {
      var c;
      if (
        ((c = l.tag === 13) &&
          ((c = l.memoizedState),
          (c = c !== null ? c.dehydrated !== null : !0)),
        c)
      )
        return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function Z1(l, c, M, E, b) {
    return l.mode & 1
      ? ((l.flags |= 65536), (l.lanes = b), l)
      : (l === c
          ? (l.flags |= 65536)
          : ((l.flags |= 128),
            (M.flags |= 131072),
            (M.flags &= -52805),
            M.tag === 1 &&
              (M.alternate === null
                ? (M.tag = 17)
                : ((c = Hs(-1, 1)), (c.tag = 2), Po(M, c))),
            (M.lanes |= 1)),
        l);
  }
  function _s(l) {
    l.flags |= 4;
  }
  function J1(l, c) {
    if (l !== null && l.child === c.child) return !0;
    if (c.flags & 16) return !1;
    for (l = c.child; l !== null; ) {
      if (l.flags & 12854 || l.subtreeFlags & 12854) return !1;
      l = l.sibling;
    }
    return !0;
  }
  var ad, ld, Kf, Qf;
  if (Ge)
    (ad = function (l, c) {
      for (var M = c.child; M !== null; ) {
        if (M.tag === 5 || M.tag === 6) ae(l, M.stateNode);
        else if (M.tag !== 4 && M.child !== null) {
          (M.child.return = M), (M = M.child);
          continue;
        }
        if (M === c) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === c) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      }
    }),
      (ld = function () {}),
      (Kf = function (l, c, M, E, b) {
        if (((l = l.memoizedProps), l !== E)) {
          var R = c.stateNode,
            z = vs(Cr.current);
          (M = te(R, M, l, E, b, z)), (c.updateQueue = M) && _s(c);
        }
      }),
      (Qf = function (l, c, M, E) {
        M !== E && _s(c);
      });
  else if (V) {
    ad = function (l, c, M, E) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var R = b.stateNode;
          M && E && (R = mn(R, b.type, b.memoizedProps, b)), ae(l, R);
        } else if (b.tag === 6)
          (R = b.stateNode),
            M && E && (R = $n(R, b.memoizedProps, b)),
            ae(l, R);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null)
            (R = b.child), R !== null && (R.return = b), ad(l, b, !0, !0);
          else if (b.child !== null) {
            (b.child.return = b), (b = b.child);
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      }
    };
    var eM = function (l, c, M, E) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var R = b.stateNode;
          M && E && (R = mn(R, b.type, b.memoizedProps, b)), ft(l, R);
        } else if (b.tag === 6)
          (R = b.stateNode),
            M && E && (R = $n(R, b.memoizedProps, b)),
            ft(l, R);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null)
            (R = b.child), R !== null && (R.return = b), eM(l, b, !0, !0);
          else if (b.child !== null) {
            (b.child.return = b), (b = b.child);
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      }
    };
    (ld = function (l, c) {
      var M = c.stateNode;
      if (!J1(l, c)) {
        l = M.containerInfo;
        var E = ot(l);
        eM(E, c, !1, !1), (M.pendingChildren = E), _s(c), Vt(l, E);
      }
    }),
      (Kf = function (l, c, M, E, b) {
        var R = l.stateNode,
          z = l.memoizedProps;
        if ((l = J1(l, c)) && z === E) c.stateNode = R;
        else {
          var ie = c.stateNode,
            me = vs(Cr.current),
            ke = null;
          z !== E && (ke = te(ie, M, z, E, b, me)),
            l && ke === null
              ? (c.stateNode = R)
              : ((R = De(R, ke, M, z, E, c, l, ie)),
                xe(R, M, E, b, me) && _s(c),
                (c.stateNode = R),
                l ? _s(c) : ad(R, c, !1, !1));
        }
      }),
      (Qf = function (l, c, M, E) {
        M !== E
          ? ((l = vs(au.current)),
            (M = vs(Cr.current)),
            (c.stateNode = ye(E, l, M, c)),
            _s(c))
          : (c.stateNode = l.stateNode);
      });
  } else (ld = function () {}), (Kf = function () {}), (Qf = function () {});
  function ud(l, c) {
    if (!gn)
      switch (l.tailMode) {
        case "hidden":
          c = l.tail;
          for (var M = null; c !== null; )
            c.alternate !== null && (M = c), (c = c.sibling);
          M === null ? (l.tail = null) : (M.sibling = null);
          break;
        case "collapsed":
          M = l.tail;
          for (var E = null; M !== null; )
            M.alternate !== null && (E = M), (M = M.sibling);
          E === null
            ? c || l.tail === null
              ? (l.tail = null)
              : (l.tail.sibling = null)
            : (E.sibling = null);
      }
  }
  function mi(l) {
    var c = l.alternate !== null && l.alternate.child === l.child,
      M = 0,
      E = 0;
    if (c)
      for (var b = l.child; b !== null; )
        (M |= b.lanes | b.childLanes),
          (E |= b.subtreeFlags & 14680064),
          (E |= b.flags & 14680064),
          (b.return = l),
          (b = b.sibling);
    else
      for (b = l.child; b !== null; )
        (M |= b.lanes | b.childLanes),
          (E |= b.subtreeFlags),
          (E |= b.flags),
          (b.return = l),
          (b = b.sibling);
    return (l.subtreeFlags |= E), (l.childLanes = M), c;
  }
  function lI(l, c, M) {
    var E = c.pendingProps;
    switch ((Kv(c), c.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return mi(c), null;
      case 1:
        return tn(c.type) && Gt(), mi(c), null;
      case 3:
        return (
          (E = c.stateNode),
          lu(),
          Ne(gt),
          Ne(et),
          iy(),
          E.pendingContext &&
            ((E.context = E.pendingContext), (E.pendingContext = null)),
          (l === null || l.child === null) &&
            (Jc(c)
              ? _s(c)
              : l === null ||
                (l.memoizedState.isDehydrated && !(c.flags & 256)) ||
                ((c.flags |= 1024), qr !== null && (Iy(qr), (qr = null)))),
          ld(l, c),
          mi(c),
          null
        );
      case 5:
        ty(c), (M = vs(au.current));
        var b = c.type;
        if (l !== null && c.stateNode != null)
          Kf(l, c, b, E, M),
            l.ref !== c.ref && ((c.flags |= 512), (c.flags |= 2097152));
        else {
          if (!E) {
            if (c.stateNode === null) throw Error(o(166));
            return mi(c), null;
          }
          if (((l = vs(Cr.current)), Jc(c))) {
            if (!be) throw Error(o(175));
            (l = fe(c.stateNode, c.type, c.memoizedProps, M, l, c, !Zc)),
              (c.updateQueue = l),
              l !== null && _s(c);
          } else {
            var R = ee(b, E, M, l, c);
            ad(R, c, !1, !1), (c.stateNode = R), xe(R, b, E, M, l) && _s(c);
          }
          c.ref !== null && ((c.flags |= 512), (c.flags |= 2097152));
        }
        return mi(c), null;
      case 6:
        if (l && c.stateNode != null) Qf(l, c, l.memoizedProps, E);
        else {
          if (typeof E != "string" && c.stateNode === null) throw Error(o(166));
          if (((l = vs(au.current)), (M = vs(Cr.current)), Jc(c))) {
            if (!be) throw Error(o(176));
            if (
              ((l = c.stateNode),
              (E = c.memoizedProps),
              (M = we(l, E, c, !Zc)) && ((b = nr), b !== null))
            )
              switch (((R = (b.mode & 1) !== 0), b.tag)) {
                case 3:
                  _e(b.stateNode.containerInfo, l, E, R);
                  break;
                case 5:
                  Ve(b.type, b.memoizedProps, b.stateNode, l, E, R);
              }
            M && _s(c);
          } else c.stateNode = ye(E, l, M, c);
        }
        return mi(c), null;
      case 13:
        if (
          (Ne(yn),
          (E = c.memoizedState),
          gn && ir !== null && c.mode & 1 && !(c.flags & 128))
        ) {
          for (l = ir; l; ) l = hs(l);
          return su(), (c.flags |= 98560), c;
        }
        if (E !== null && E.dehydrated !== null) {
          if (((E = Jc(c)), l === null)) {
            if (!E) throw Error(o(318));
            if (!be) throw Error(o(344));
            if (
              ((l = c.memoizedState),
              (l = l !== null ? l.dehydrated : null),
              !l)
            )
              throw Error(o(317));
            Xe(l, c);
          } else
            su(), !(c.flags & 128) && (c.memoizedState = null), (c.flags |= 4);
          return mi(c), null;
        }
        return (
          qr !== null && (Iy(qr), (qr = null)),
          c.flags & 128
            ? ((c.lanes = M), c)
            : ((E = E !== null),
              (M = !1),
              l === null ? Jc(c) : (M = l.memoizedState !== null),
              E &&
                !M &&
                ((c.child.flags |= 8192),
                c.mode & 1 &&
                  (l === null || yn.current & 1 ? Hn === 0 && (Hn = 3) : Ny())),
              c.updateQueue !== null && (c.flags |= 4),
              mi(c),
              null)
        );
      case 4:
        return (
          lu(),
          ld(l, c),
          l === null && Le(c.stateNode.containerInfo),
          mi(c),
          null
        );
      case 10:
        return Wv(c.type._context), mi(c), null;
      case 17:
        return tn(c.type) && Gt(), mi(c), null;
      case 19:
        if ((Ne(yn), (b = c.memoizedState), b === null)) return mi(c), null;
        if (((E = (c.flags & 128) !== 0), (R = b.rendering), R === null))
          if (E) ud(b, !1);
          else {
            if (Hn !== 0 || (l !== null && l.flags & 128))
              for (l = c.child; l !== null; ) {
                if (((R = Vf(l)), R !== null)) {
                  for (
                    c.flags |= 128,
                      ud(b, !1),
                      l = R.updateQueue,
                      l !== null && ((c.updateQueue = l), (c.flags |= 4)),
                      c.subtreeFlags = 0,
                      l = M,
                      E = c.child;
                    E !== null;

                  )
                    (M = E),
                      (b = l),
                      (M.flags &= 14680066),
                      (R = M.alternate),
                      R === null
                        ? ((M.childLanes = 0),
                          (M.lanes = b),
                          (M.child = null),
                          (M.subtreeFlags = 0),
                          (M.memoizedProps = null),
                          (M.memoizedState = null),
                          (M.updateQueue = null),
                          (M.dependencies = null),
                          (M.stateNode = null))
                        : ((M.childLanes = R.childLanes),
                          (M.lanes = R.lanes),
                          (M.child = R.child),
                          (M.subtreeFlags = 0),
                          (M.deletions = null),
                          (M.memoizedProps = R.memoizedProps),
                          (M.memoizedState = R.memoizedState),
                          (M.updateQueue = R.updateQueue),
                          (M.type = R.type),
                          (b = R.dependencies),
                          (M.dependencies =
                            b === null
                              ? null
                              : {
                                  lanes: b.lanes,
                                  firstContext: b.firstContext,
                                })),
                      (E = E.sibling);
                  return Pe(yn, (yn.current & 1) | 2), c.child;
                }
                l = l.sibling;
              }
            b.tail !== null &&
              ln() > Ay &&
              ((c.flags |= 128), (E = !0), ud(b, !1), (c.lanes = 4194304));
          }
        else {
          if (!E)
            if (((l = Vf(R)), l !== null)) {
              if (
                ((c.flags |= 128),
                (E = !0),
                (l = l.updateQueue),
                l !== null && ((c.updateQueue = l), (c.flags |= 4)),
                ud(b, !0),
                b.tail === null &&
                  b.tailMode === "hidden" &&
                  !R.alternate &&
                  !gn)
              )
                return mi(c), null;
            } else
              2 * ln() - b.renderingStartTime > Ay &&
                M !== 1073741824 &&
                ((c.flags |= 128), (E = !0), ud(b, !1), (c.lanes = 4194304));
          b.isBackwards
            ? ((R.sibling = c.child), (c.child = R))
            : ((l = b.last),
              l !== null ? (l.sibling = R) : (c.child = R),
              (b.last = R));
        }
        return b.tail !== null
          ? ((c = b.tail),
            (b.rendering = c),
            (b.tail = c.sibling),
            (b.renderingStartTime = ln()),
            (c.sibling = null),
            (l = yn.current),
            Pe(yn, E ? (l & 1) | 2 : l & 1),
            c)
          : (mi(c), null);
      case 22:
      case 23:
        return (
          Oy(),
          (E = c.memoizedState !== null),
          l !== null && (l.memoizedState !== null) !== E && (c.flags |= 8192),
          E && c.mode & 1
            ? sr & 1073741824 &&
              (mi(c), Ge && c.subtreeFlags & 6 && (c.flags |= 8192))
            : mi(c),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, c.tag));
  }
  var uI = a.ReactCurrentOwner,
    rr = !1;
  function Ai(l, c, M, E) {
    c.child = l === null ? A1(c, null, M, E) : ou(c, l.child, M, E);
  }
  function tM(l, c, M, E, b) {
    M = M.render;
    var R = c.ref;
    return (
      nu(c, b),
      (E = sy(l, c, M, E, R, b)),
      (M = oy()),
      l !== null && !rr
        ? ((c.updateQueue = l.updateQueue),
          (c.flags &= -2053),
          (l.lanes &= ~b),
          js(l, c, b))
        : (gn && M && Yv(c), (c.flags |= 1), Ai(l, c, E, b), c.child)
    );
  }
  function nM(l, c, M, E, b) {
    if (l === null) {
      var R = M.type;
      return typeof R == "function" &&
        !Dy(R) &&
        R.defaultProps === void 0 &&
        M.compare === null &&
        M.defaultProps === void 0
        ? ((c.tag = 15), (c.type = R), iM(l, c, R, E, b))
        : ((l = yp(M.type, null, E, c, c.mode, b)),
          (l.ref = c.ref),
          (l.return = c),
          (c.child = l));
    }
    if (((R = l.child), !(l.lanes & b))) {
      var z = R.memoizedProps;
      if (
        ((M = M.compare), (M = M !== null ? M : Of), M(z, E) && l.ref === c.ref)
      )
        return js(l, c, b);
    }
    return (
      (c.flags |= 1),
      (l = No(R, E)),
      (l.ref = c.ref),
      (l.return = c),
      (c.child = l)
    );
  }
  function iM(l, c, M, E, b) {
    if (l !== null && Of(l.memoizedProps, E) && l.ref === c.ref)
      if (((rr = !1), (l.lanes & b) !== 0)) l.flags & 131072 && (rr = !0);
      else return (c.lanes = l.lanes), js(l, c, b);
    return hy(l, c, M, E, b);
  }
  function rM(l, c, M) {
    var E = c.pendingProps,
      b = E.children,
      R = l !== null ? l.memoizedState : null;
    if (E.mode === "hidden")
      if (!(c.mode & 1))
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          Pe(cu, sr),
          (sr |= M);
      else if (M & 1073741824)
        (c.memoizedState = { baseLanes: 0, cachePool: null }),
          (E = R !== null ? R.baseLanes : M),
          Pe(cu, sr),
          (sr |= E);
      else
        return (
          (l = R !== null ? R.baseLanes | M : M),
          (c.lanes = c.childLanes = 1073741824),
          (c.memoizedState = { baseLanes: l, cachePool: null }),
          (c.updateQueue = null),
          Pe(cu, sr),
          (sr |= l),
          null
        );
    else
      R !== null ? ((E = R.baseLanes | M), (c.memoizedState = null)) : (E = M),
        Pe(cu, sr),
        (sr |= E);
    return Ai(l, c, b, M), c.child;
  }
  function sM(l, c) {
    var M = c.ref;
    ((l === null && M !== null) || (l !== null && l.ref !== M)) &&
      ((c.flags |= 512), (c.flags |= 2097152));
  }
  function hy(l, c, M, E, b) {
    var R = tn(M) ? qt : et.current;
    return (
      (R = on(c, R)),
      nu(c, b),
      (M = sy(l, c, M, E, R, b)),
      (E = oy()),
      l !== null && !rr
        ? ((c.updateQueue = l.updateQueue),
          (c.flags &= -2053),
          (l.lanes &= ~b),
          js(l, c, b))
        : (gn && E && Yv(c), (c.flags |= 1), Ai(l, c, M, b), c.child)
    );
  }
  function oM(l, c, M, E, b) {
    if (tn(M)) {
      var R = !0;
      Bt(c);
    } else R = !1;
    if ((nu(c, b), c.stateNode === null))
      l !== null &&
        ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
        x1(c, M, E),
        $v(c, M, E, b),
        (E = !0);
    else if (l === null) {
      var z = c.stateNode,
        ie = c.memoizedProps;
      z.props = ie;
      var me = z.context,
        ke = M.contextType;
      typeof ke == "object" && ke !== null
        ? (ke = Mr(ke))
        : ((ke = tn(M) ? qt : et.current), (ke = on(c, ke)));
      var st = M.getDerivedStateFromProps,
        Et =
          typeof st == "function" ||
          typeof z.getSnapshotBeforeUpdate == "function";
      Et ||
        (typeof z.UNSAFE_componentWillReceiveProps != "function" &&
          typeof z.componentWillReceiveProps != "function") ||
        ((ie !== E || me !== ke) && S1(c, z, E, ke)),
        (Ao = !1);
      var vt = c.memoizedState;
      (z.state = vt),
        Uf(c, E, z, b),
        (me = c.memoizedState),
        ie !== E || vt !== me || gt.current || Ao
          ? (typeof st == "function" &&
              (qv(c, M, st, E), (me = c.memoizedState)),
            (ie = Ao || _1(c, M, ie, E, vt, me, ke))
              ? (Et ||
                  (typeof z.UNSAFE_componentWillMount != "function" &&
                    typeof z.componentWillMount != "function") ||
                  (typeof z.componentWillMount == "function" &&
                    z.componentWillMount(),
                  typeof z.UNSAFE_componentWillMount == "function" &&
                    z.UNSAFE_componentWillMount()),
                typeof z.componentDidMount == "function" &&
                  (c.flags |= 4194308))
              : (typeof z.componentDidMount == "function" &&
                  (c.flags |= 4194308),
                (c.memoizedProps = E),
                (c.memoizedState = me)),
            (z.props = E),
            (z.state = me),
            (z.context = ke),
            (E = ie))
          : (typeof z.componentDidMount == "function" && (c.flags |= 4194308),
            (E = !1));
    } else {
      (z = c.stateNode),
        m1(l, c),
        (ie = c.memoizedProps),
        (ke = c.type === c.elementType ? ie : Xr(c.type, ie)),
        (z.props = ke),
        (Et = c.pendingProps),
        (vt = z.context),
        (me = M.contextType),
        typeof me == "object" && me !== null
          ? (me = Mr(me))
          : ((me = tn(M) ? qt : et.current), (me = on(c, me)));
      var an = M.getDerivedStateFromProps;
      (st =
        typeof an == "function" ||
        typeof z.getSnapshotBeforeUpdate == "function") ||
        (typeof z.UNSAFE_componentWillReceiveProps != "function" &&
          typeof z.componentWillReceiveProps != "function") ||
        ((ie !== Et || vt !== me) && S1(c, z, E, me)),
        (Ao = !1),
        (vt = c.memoizedState),
        (z.state = vt),
        Uf(c, E, z, b);
      var ht = c.memoizedState;
      ie !== Et || vt !== ht || gt.current || Ao
        ? (typeof an == "function" && (qv(c, M, an, E), (ht = c.memoizedState)),
          (ke = Ao || _1(c, M, ke, E, vt, ht, me) || !1)
            ? (st ||
                (typeof z.UNSAFE_componentWillUpdate != "function" &&
                  typeof z.componentWillUpdate != "function") ||
                (typeof z.componentWillUpdate == "function" &&
                  z.componentWillUpdate(E, ht, me),
                typeof z.UNSAFE_componentWillUpdate == "function" &&
                  z.UNSAFE_componentWillUpdate(E, ht, me)),
              typeof z.componentDidUpdate == "function" && (c.flags |= 4),
              typeof z.getSnapshotBeforeUpdate == "function" &&
                (c.flags |= 1024))
            : (typeof z.componentDidUpdate != "function" ||
                (ie === l.memoizedProps && vt === l.memoizedState) ||
                (c.flags |= 4),
              typeof z.getSnapshotBeforeUpdate != "function" ||
                (ie === l.memoizedProps && vt === l.memoizedState) ||
                (c.flags |= 1024),
              (c.memoizedProps = E),
              (c.memoizedState = ht)),
          (z.props = E),
          (z.state = ht),
          (z.context = me),
          (E = ke))
        : (typeof z.componentDidUpdate != "function" ||
            (ie === l.memoizedProps && vt === l.memoizedState) ||
            (c.flags |= 4),
          typeof z.getSnapshotBeforeUpdate != "function" ||
            (ie === l.memoizedProps && vt === l.memoizedState) ||
            (c.flags |= 1024),
          (E = !1));
    }
    return fy(l, c, M, E, R, b);
  }
  function fy(l, c, M, E, b, R) {
    sM(l, c);
    var z = (c.flags & 128) !== 0;
    if (!E && !z) return b && bi(c, M, !1), js(l, c, R);
    (E = c.stateNode), (uI.current = c);
    var ie =
      z && typeof M.getDerivedStateFromError != "function" ? null : E.render();
    return (
      (c.flags |= 1),
      l !== null && z
        ? ((c.child = ou(c, l.child, null, R)), (c.child = ou(c, null, ie, R)))
        : Ai(l, c, ie, R),
      (c.memoizedState = E.state),
      b && bi(c, M, !0),
      c.child
    );
  }
  function aM(l) {
    var c = l.stateNode;
    c.pendingContext
      ? Nn(l, c.pendingContext, c.pendingContext !== c.context)
      : c.context && Nn(l, c.context, !1),
      ey(l, c.containerInfo);
  }
  function lM(l, c, M, E, b) {
    return su(), Jv(b), (c.flags |= 256), Ai(l, c, M, E), c.child;
  }
  var Zf = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Jf(l) {
    return { baseLanes: l, cachePool: null };
  }
  function uM(l, c, M) {
    var E = c.pendingProps,
      b = yn.current,
      R = !1,
      z = (c.flags & 128) !== 0,
      ie;
    if (
      ((ie = z) ||
        (ie = l !== null && l.memoizedState === null ? !1 : (b & 2) !== 0),
      ie
        ? ((R = !0), (c.flags &= -129))
        : (l === null || l.memoizedState !== null) && (b |= 1),
      Pe(yn, b & 1),
      l === null)
    )
      return (
        Zv(c),
        (l = c.memoizedState),
        l !== null && ((l = l.dehydrated), l !== null)
          ? (c.mode & 1
              ? ds(l)
                ? (c.lanes = 8)
                : (c.lanes = 1073741824)
              : (c.lanes = 1),
            null)
          : ((b = E.children),
            (l = E.fallback),
            R
              ? ((E = c.mode),
                (R = c.child),
                (b = { mode: "hidden", children: b }),
                !(E & 1) && R !== null
                  ? ((R.childLanes = 0), (R.pendingProps = b))
                  : (R = _p(b, E, 0, null)),
                (l = qa(l, E, M, null)),
                (R.return = c),
                (l.return = c),
                (R.sibling = l),
                (c.child = R),
                (c.child.memoizedState = Jf(M)),
                (c.memoizedState = Zf),
                l)
              : py(c, b))
      );
    if (((b = l.memoizedState), b !== null)) {
      if (((ie = b.dehydrated), ie !== null)) {
        if (z)
          return c.flags & 256
            ? ((c.flags &= -257), ep(l, c, M, Error(o(422))))
            : c.memoizedState !== null
              ? ((c.child = l.child), (c.flags |= 128), null)
              : ((R = E.fallback),
                (b = c.mode),
                (E = _p({ mode: "visible", children: E.children }, b, 0, null)),
                (R = qa(R, b, M, null)),
                (R.flags |= 2),
                (E.return = c),
                (R.return = c),
                (E.sibling = R),
                (c.child = E),
                c.mode & 1 && ou(c, l.child, null, M),
                (c.child.memoizedState = Jf(M)),
                (c.memoizedState = Zf),
                R);
        if (!(c.mode & 1)) c = ep(l, c, M, null);
        else if (ds(ie)) c = ep(l, c, M, Error(o(419)));
        else if (((E = (M & l.childLanes) !== 0), rr || E)) {
          if (((E = Dn), E !== null)) {
            switch (M & -M) {
              case 4:
                R = 2;
                break;
              case 16:
                R = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                R = 32;
                break;
              case 536870912:
                R = 268435456;
                break;
              default:
                R = 0;
            }
            (E = R & (E.suspendedLanes | M) ? 0 : R),
              E !== 0 && E !== b.retryLane && ((b.retryLane = E), Ar(l, E, -1));
          }
          Ny(), (c = ep(l, c, M, Error(o(421))));
        } else
          So(ie)
            ? ((c.flags |= 128),
              (c.child = l.child),
              (c = wI.bind(null, l)),
              wo(ie, c),
              (c = null))
            : ((M = b.treeContext),
              be &&
                ((ir = K(ie)),
                (nr = c),
                (gn = !0),
                (qr = null),
                (Zc = !1),
                M !== null &&
                  ((Er[Tr++] = Vs),
                  (Er[Tr++] = Gs),
                  (Er[Tr++] = Ba),
                  (Vs = M.id),
                  (Gs = M.overflow),
                  (Ba = c))),
              (c = py(c, c.pendingProps.children)),
              (c.flags |= 4096));
        return c;
      }
      return R
        ? ((E = dM(l, c, E.children, E.fallback, M)),
          (R = c.child),
          (b = l.child.memoizedState),
          (R.memoizedState =
            b === null
              ? Jf(M)
              : { baseLanes: b.baseLanes | M, cachePool: null }),
          (R.childLanes = l.childLanes & ~M),
          (c.memoizedState = Zf),
          E)
        : ((M = cM(l, c, E.children, M)), (c.memoizedState = null), M);
    }
    return R
      ? ((E = dM(l, c, E.children, E.fallback, M)),
        (R = c.child),
        (b = l.child.memoizedState),
        (R.memoizedState =
          b === null ? Jf(M) : { baseLanes: b.baseLanes | M, cachePool: null }),
        (R.childLanes = l.childLanes & ~M),
        (c.memoizedState = Zf),
        E)
      : ((M = cM(l, c, E.children, M)), (c.memoizedState = null), M);
  }
  function py(l, c) {
    return (
      (c = _p({ mode: "visible", children: c }, l.mode, 0, null)),
      (c.return = l),
      (l.child = c)
    );
  }
  function cM(l, c, M, E) {
    var b = l.child;
    return (
      (l = b.sibling),
      (M = No(b, { mode: "visible", children: M })),
      !(c.mode & 1) && (M.lanes = E),
      (M.return = c),
      (M.sibling = null),
      l !== null &&
        ((E = c.deletions),
        E === null ? ((c.deletions = [l]), (c.flags |= 16)) : E.push(l)),
      (c.child = M)
    );
  }
  function dM(l, c, M, E, b) {
    var R = c.mode;
    l = l.child;
    var z = l.sibling,
      ie = { mode: "hidden", children: M };
    return (
      !(R & 1) && c.child !== l
        ? ((M = c.child),
          (M.childLanes = 0),
          (M.pendingProps = ie),
          (c.deletions = null))
        : ((M = No(l, ie)), (M.subtreeFlags = l.subtreeFlags & 14680064)),
      z !== null ? (E = No(z, E)) : ((E = qa(E, R, b, null)), (E.flags |= 2)),
      (E.return = c),
      (M.return = c),
      (M.sibling = E),
      (c.child = M),
      E
    );
  }
  function ep(l, c, M, E) {
    return (
      E !== null && Jv(E),
      ou(c, l.child, null, M),
      (l = py(c, c.pendingProps.children)),
      (l.flags |= 2),
      (c.memoizedState = null),
      l
    );
  }
  function hM(l, c, M) {
    l.lanes |= c;
    var E = l.alternate;
    E !== null && (E.lanes |= c), jv(l.return, c, M);
  }
  function my(l, c, M, E, b) {
    var R = l.memoizedState;
    R === null
      ? (l.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: E,
          tail: M,
          tailMode: b,
        })
      : ((R.isBackwards = c),
        (R.rendering = null),
        (R.renderingStartTime = 0),
        (R.last = E),
        (R.tail = M),
        (R.tailMode = b));
  }
  function fM(l, c, M) {
    var E = c.pendingProps,
      b = E.revealOrder,
      R = E.tail;
    if ((Ai(l, c, E.children, M), (E = yn.current), E & 2))
      (E = (E & 1) | 2), (c.flags |= 128);
    else {
      if (l !== null && l.flags & 128)
        e: for (l = c.child; l !== null; ) {
          if (l.tag === 13) l.memoizedState !== null && hM(l, M, c);
          else if (l.tag === 19) hM(l, M, c);
          else if (l.child !== null) {
            (l.child.return = l), (l = l.child);
            continue;
          }
          if (l === c) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === c) break e;
            l = l.return;
          }
          (l.sibling.return = l.return), (l = l.sibling);
        }
      E &= 1;
    }
    if ((Pe(yn, E), !(c.mode & 1))) c.memoizedState = null;
    else
      switch (b) {
        case "forwards":
          for (M = c.child, b = null; M !== null; )
            (l = M.alternate),
              l !== null && Vf(l) === null && (b = M),
              (M = M.sibling);
          (M = b),
            M === null
              ? ((b = c.child), (c.child = null))
              : ((b = M.sibling), (M.sibling = null)),
            my(c, !1, b, M, R);
          break;
        case "backwards":
          for (M = null, b = c.child, c.child = null; b !== null; ) {
            if (((l = b.alternate), l !== null && Vf(l) === null)) {
              c.child = b;
              break;
            }
            (l = b.sibling), (b.sibling = M), (M = b), (b = l);
          }
          my(c, !0, M, null, R);
          break;
        case "together":
          my(c, !1, null, null, void 0);
          break;
        default:
          c.memoizedState = null;
      }
    return c.child;
  }
  function js(l, c, M) {
    if (
      (l !== null && (c.dependencies = l.dependencies),
      (du |= c.lanes),
      !(M & c.childLanes))
    )
      return null;
    if (l !== null && c.child !== l.child) throw Error(o(153));
    if (c.child !== null) {
      for (
        l = c.child, M = No(l, l.pendingProps), c.child = M, M.return = c;
        l.sibling !== null;

      )
        (l = l.sibling),
          (M = M.sibling = No(l, l.pendingProps)),
          (M.return = c);
      M.sibling = null;
    }
    return c.child;
  }
  function cI(l, c, M) {
    switch (c.tag) {
      case 3:
        aM(c), su();
        break;
      case 5:
        P1(c);
        break;
      case 1:
        tn(c.type) && Bt(c);
        break;
      case 4:
        ey(c, c.stateNode.containerInfo);
        break;
      case 10:
        p1(c, c.type._context, c.memoizedProps.value);
        break;
      case 13:
        var E = c.memoizedState;
        if (E !== null)
          return E.dehydrated !== null
            ? (Pe(yn, yn.current & 1), (c.flags |= 128), null)
            : M & c.child.childLanes
              ? uM(l, c, M)
              : (Pe(yn, yn.current & 1),
                (l = js(l, c, M)),
                l !== null ? l.sibling : null);
        Pe(yn, yn.current & 1);
        break;
      case 19:
        if (((E = (M & c.childLanes) !== 0), l.flags & 128)) {
          if (E) return fM(l, c, M);
          c.flags |= 128;
        }
        var b = c.memoizedState;
        if (
          (b !== null &&
            ((b.rendering = null), (b.tail = null), (b.lastEffect = null)),
          Pe(yn, yn.current),
          E)
        )
          break;
        return null;
      case 22:
      case 23:
        return (c.lanes = 0), rM(l, c, M);
    }
    return js(l, c, M);
  }
  function dI(l, c) {
    switch ((Kv(c), c.tag)) {
      case 1:
        return (
          tn(c.type) && Gt(),
          (l = c.flags),
          l & 65536 ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 3:
        return (
          lu(),
          Ne(gt),
          Ne(et),
          iy(),
          (l = c.flags),
          l & 65536 && !(l & 128) ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 5:
        return ty(c), null;
      case 13:
        if (
          (Ne(yn), (l = c.memoizedState), l !== null && l.dehydrated !== null)
        ) {
          if (c.alternate === null) throw Error(o(340));
          su();
        }
        return (
          (l = c.flags), l & 65536 ? ((c.flags = (l & -65537) | 128), c) : null
        );
      case 19:
        return Ne(yn), null;
      case 4:
        return lu(), null;
      case 10:
        return Wv(c.type._context), null;
      case 22:
      case 23:
        return Oy(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var tp = !1,
    Va = !1,
    hI = typeof WeakSet == "function" ? WeakSet : Set,
    qe = null;
  function np(l, c) {
    var M = l.ref;
    if (M !== null)
      if (typeof M == "function")
        try {
          M(null);
        } catch (E) {
          ji(l, c, E);
        }
      else M.current = null;
  }
  function gy(l, c, M) {
    try {
      M();
    } catch (E) {
      ji(l, c, E);
    }
  }
  var pM = !1;
  function fI(l, c) {
    for (W(l.containerInfo), qe = c; qe !== null; )
      if (
        ((l = qe), (c = l.child), (l.subtreeFlags & 1028) !== 0 && c !== null)
      )
        (c.return = l), (qe = c);
      else
        for (; qe !== null; ) {
          l = qe;
          try {
            var M = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (M !== null) {
                    var E = M.memoizedProps,
                      b = M.memoizedState,
                      R = l.stateNode,
                      z = R.getSnapshotBeforeUpdate(
                        l.elementType === l.type ? E : Xr(l.type, E),
                        b,
                      );
                    R.__reactInternalSnapshotBeforeUpdate = z;
                  }
                  break;
                case 3:
                  Ge && Oe(l.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (ie) {
            ji(l, l.return, ie);
          }
          if (((c = l.sibling), c !== null)) {
            (c.return = l.return), (qe = c);
            break;
          }
          qe = l.return;
        }
    return (M = pM), (pM = !1), M;
  }
  function Ga(l, c, M) {
    var E = c.updateQueue;
    if (((E = E !== null ? E.lastEffect : null), E !== null)) {
      var b = (E = E.next);
      do {
        if ((b.tag & l) === l) {
          var R = b.destroy;
          (b.destroy = void 0), R !== void 0 && gy(c, M, R);
        }
        b = b.next;
      } while (b !== E);
    }
  }
  function cd(l, c) {
    if (
      ((c = c.updateQueue), (c = c !== null ? c.lastEffect : null), c !== null)
    ) {
      var M = (c = c.next);
      do {
        if ((M.tag & l) === l) {
          var E = M.create;
          M.destroy = E();
        }
        M = M.next;
      } while (M !== c);
    }
  }
  function vy(l) {
    var c = l.ref;
    if (c !== null) {
      var M = l.stateNode;
      switch (l.tag) {
        case 5:
          l = G(M);
          break;
        default:
          l = M;
      }
      typeof c == "function" ? c(l) : (c.current = l);
    }
  }
  function mM(l, c, M) {
    if (tr && typeof tr.onCommitFiberUnmount == "function")
      try {
        tr.onCommitFiberUnmount(Fa, c);
      } catch {}
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((l = c.updateQueue), l !== null && ((l = l.lastEffect), l !== null))
        ) {
          var E = (l = l.next);
          do {
            var b = E,
              R = b.destroy;
            (b = b.tag),
              R !== void 0 && (b & 2 || b & 4) && gy(c, M, R),
              (E = E.next);
          } while (E !== l);
        }
        break;
      case 1:
        if (
          (np(c, M),
          (l = c.stateNode),
          typeof l.componentWillUnmount == "function")
        )
          try {
            (l.props = c.memoizedProps),
              (l.state = c.memoizedState),
              l.componentWillUnmount();
          } catch (z) {
            ji(c, M, z);
          }
        break;
      case 5:
        np(c, M);
        break;
      case 4:
        Ge
          ? SM(l, c, M)
          : V && V && ((c = c.stateNode.containerInfo), (M = ot(c)), Xt(c, M));
    }
  }
  function gM(l, c, M) {
    for (var E = c; ; )
      if ((mM(l, E, M), E.child === null || (Ge && E.tag === 4))) {
        if (E === c) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === c) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      } else (E.child.return = E), (E = E.child);
  }
  function vM(l) {
    var c = l.alternate;
    c !== null && ((l.alternate = null), vM(c)),
      (l.child = null),
      (l.deletions = null),
      (l.sibling = null),
      l.tag === 5 && ((c = l.stateNode), c !== null && at(c)),
      (l.stateNode = null),
      (l.return = null),
      (l.dependencies = null),
      (l.memoizedProps = null),
      (l.memoizedState = null),
      (l.pendingProps = null),
      (l.stateNode = null),
      (l.updateQueue = null);
  }
  function yM(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function _M(l) {
    e: for (;;) {
      for (; l.sibling === null; ) {
        if (l.return === null || yM(l.return)) return null;
        l = l.return;
      }
      for (
        l.sibling.return = l.return, l = l.sibling;
        l.tag !== 5 && l.tag !== 6 && l.tag !== 18;

      ) {
        if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
        (l.child.return = l), (l = l.child);
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function xM(l) {
    if (Ge) {
      e: {
        for (var c = l.return; c !== null; ) {
          if (yM(c)) break e;
          c = c.return;
        }
        throw Error(o(160));
      }
      var M = c;
      switch (M.tag) {
        case 5:
          (c = M.stateNode),
            M.flags & 32 && (kt(c), (M.flags &= -33)),
            (M = _M(l)),
            _y(l, M, c);
          break;
        case 3:
        case 4:
          (c = M.stateNode.containerInfo), (M = _M(l)), yy(l, M, c);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function yy(l, c, M) {
    var E = l.tag;
    if (E === 5 || E === 6) (l = l.stateNode), c ? dt(M, l, c) : wt(M, l);
    else if (E !== 4 && ((l = l.child), l !== null))
      for (yy(l, c, M), l = l.sibling; l !== null; )
        yy(l, c, M), (l = l.sibling);
  }
  function _y(l, c, M) {
    var E = l.tag;
    if (E === 5 || E === 6) (l = l.stateNode), c ? yt(M, l, c) : mt(M, l);
    else if (E !== 4 && ((l = l.child), l !== null))
      for (_y(l, c, M), l = l.sibling; l !== null; )
        _y(l, c, M), (l = l.sibling);
  }
  function SM(l, c, M) {
    for (var E = c, b = !1, R, z; ; ) {
      if (!b) {
        b = E.return;
        e: for (;;) {
          if (b === null) throw Error(o(160));
          switch (((R = b.stateNode), b.tag)) {
            case 5:
              z = !1;
              break e;
            case 3:
              (R = R.containerInfo), (z = !0);
              break e;
            case 4:
              (R = R.containerInfo), (z = !0);
              break e;
          }
          b = b.return;
        }
        b = !0;
      }
      if (E.tag === 5 || E.tag === 6)
        gM(l, E, M), z ? Mt(R, E.stateNode) : nt(R, E.stateNode);
      else if (E.tag === 18) z ? J(R, E.stateNode) : Y(R, E.stateNode);
      else if (E.tag === 4) {
        if (E.child !== null) {
          (R = E.stateNode.containerInfo),
            (z = !0),
            (E.child.return = E),
            (E = E.child);
          continue;
        }
      } else if ((mM(l, E, M), E.child !== null)) {
        (E.child.return = E), (E = E.child);
        continue;
      }
      if (E === c) break;
      for (; E.sibling === null; ) {
        if (E.return === null || E.return === c) return;
        (E = E.return), E.tag === 4 && (b = !1);
      }
      (E.sibling.return = E.return), (E = E.sibling);
    }
  }
  function xy(l, c) {
    if (Ge) {
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ga(3, c, c.return), cd(3, c), Ga(5, c, c.return);
          return;
        case 1:
          return;
        case 5:
          var M = c.stateNode;
          if (M != null) {
            var E = c.memoizedProps;
            l = l !== null ? l.memoizedProps : E;
            var b = c.type,
              R = c.updateQueue;
            (c.updateQueue = null), R !== null && Ct(M, R, b, l, E, c);
          }
          return;
        case 6:
          if (c.stateNode === null) throw Error(o(162));
          (M = c.memoizedProps),
            Ae(c.stateNode, l !== null ? l.memoizedProps : M, M);
          return;
        case 3:
          be &&
            l !== null &&
            l.memoizedState.isDehydrated &&
            q(c.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          ip(c);
          return;
        case 19:
          ip(c);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Ga(3, c, c.return), cd(3, c), Ga(5, c, c.return);
        return;
      case 12:
        return;
      case 13:
        ip(c);
        return;
      case 19:
        ip(c);
        return;
      case 3:
        be &&
          l !== null &&
          l.memoizedState.isDehydrated &&
          q(c.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (V) {
      switch (c.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (c = c.stateNode), Xt(c.containerInfo, c.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function ip(l) {
    var c = l.updateQueue;
    if (c !== null) {
      l.updateQueue = null;
      var M = l.stateNode;
      M === null && (M = l.stateNode = new hI()),
        c.forEach(function (E) {
          var b = MI.bind(null, l, E);
          M.has(E) || (M.add(E), E.then(b, b));
        });
    }
  }
  function pI(l, c) {
    for (qe = c; qe !== null; ) {
      c = qe;
      var M = c.deletions;
      if (M !== null)
        for (var E = 0; E < M.length; E++) {
          var b = M[E];
          try {
            var R = l;
            Ge ? SM(R, b, c) : gM(R, b, c);
            var z = b.alternate;
            z !== null && (z.return = null), (b.return = null);
          } catch (ut) {
            ji(b, c, ut);
          }
        }
      if (((M = c.child), c.subtreeFlags & 12854 && M !== null))
        (M.return = c), (qe = M);
      else
        for (; qe !== null; ) {
          c = qe;
          try {
            var ie = c.flags;
            if ((ie & 32 && Ge && kt(c.stateNode), ie & 512)) {
              var me = c.alternate;
              if (me !== null) {
                var ke = me.ref;
                ke !== null &&
                  (typeof ke == "function" ? ke(null) : (ke.current = null));
              }
            }
            if (ie & 8192)
              switch (c.tag) {
                case 13:
                  if (c.memoizedState !== null) {
                    var st = c.alternate;
                    (st === null || st.memoizedState === null) && (by = ln());
                  }
                  break;
                case 22:
                  var Et = c.memoizedState !== null,
                    vt = c.alternate,
                    an = vt !== null && vt.memoizedState !== null;
                  if (((M = c), Ge)) {
                    e: if (((E = M), (b = Et), (R = null), Ge))
                      for (var ht = E; ; ) {
                        if (ht.tag === 5) {
                          if (R === null) {
                            R = ht;
                            var gi = ht.stateNode;
                            b ? Qt(gi) : Zt(ht.stateNode, ht.memoizedProps);
                          }
                        } else if (ht.tag === 6) {
                          if (R === null) {
                            var Rr = ht.stateNode;
                            b ? Lt(Rr) : j(Rr, ht.memoizedProps);
                          }
                        } else if (
                          ((ht.tag !== 22 && ht.tag !== 23) ||
                            ht.memoizedState === null ||
                            ht === E) &&
                          ht.child !== null
                        ) {
                          (ht.child.return = ht), (ht = ht.child);
                          continue;
                        }
                        if (ht === E) break;
                        for (; ht.sibling === null; ) {
                          if (ht.return === null || ht.return === E) break e;
                          R === ht && (R = null), (ht = ht.return);
                        }
                        R === ht && (R = null),
                          (ht.sibling.return = ht.return),
                          (ht = ht.sibling);
                      }
                  }
                  if (Et && !an && M.mode & 1) {
                    qe = M;
                    for (var he = M.child; he !== null; ) {
                      for (M = qe = he; qe !== null; ) {
                        E = qe;
                        var oe = E.child;
                        switch (E.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Ga(4, E, E.return);
                            break;
                          case 1:
                            np(E, E.return);
                            var pe = E.stateNode;
                            if (typeof pe.componentWillUnmount == "function") {
                              var Ye = E.return;
                              try {
                                (pe.props = E.memoizedProps),
                                  (pe.state = E.memoizedState),
                                  pe.componentWillUnmount();
                              } catch (ut) {
                                ji(E, Ye, ut);
                              }
                            }
                            break;
                          case 5:
                            np(E, E.return);
                            break;
                          case 22:
                            if (E.memoizedState !== null) {
                              EM(M);
                              continue;
                            }
                        }
                        oe !== null ? ((oe.return = E), (qe = oe)) : EM(M);
                      }
                      he = he.sibling;
                    }
                  }
              }
            switch (ie & 4102) {
              case 2:
                xM(c), (c.flags &= -3);
                break;
              case 6:
                xM(c), (c.flags &= -3), xy(c.alternate, c);
                break;
              case 4096:
                c.flags &= -4097;
                break;
              case 4100:
                (c.flags &= -4097), xy(c.alternate, c);
                break;
              case 4:
                xy(c.alternate, c);
            }
          } catch (ut) {
            ji(c, c.return, ut);
          }
          if (((M = c.sibling), M !== null)) {
            (M.return = c.return), (qe = M);
            break;
          }
          qe = c.return;
        }
    }
  }
  function mI(l, c, M) {
    (qe = l), wM(l);
  }
  function wM(l, c, M) {
    for (var E = (l.mode & 1) !== 0; qe !== null; ) {
      var b = qe,
        R = b.child;
      if (b.tag === 22 && E) {
        var z = b.memoizedState !== null || tp;
        if (!z) {
          var ie = b.alternate,
            me = (ie !== null && ie.memoizedState !== null) || Va;
          ie = tp;
          var ke = Va;
          if (((tp = z), (Va = me) && !ke))
            for (qe = b; qe !== null; )
              (z = qe),
                (me = z.child),
                z.tag === 22 && z.memoizedState !== null
                  ? TM(b)
                  : me !== null
                    ? ((me.return = z), (qe = me))
                    : TM(b);
          for (; R !== null; ) (qe = R), wM(R), (R = R.sibling);
          (qe = b), (tp = ie), (Va = ke);
        }
        MM(l);
      } else
        b.subtreeFlags & 8772 && R !== null
          ? ((R.return = b), (qe = R))
          : MM(l);
    }
  }
  function MM(l) {
    for (; qe !== null; ) {
      var c = qe;
      if (c.flags & 8772) {
        var M = c.alternate;
        try {
          if (c.flags & 8772)
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
                Va || cd(5, c);
                break;
              case 1:
                var E = c.stateNode;
                if (c.flags & 4 && !Va)
                  if (M === null) E.componentDidMount();
                  else {
                    var b =
                      c.elementType === c.type
                        ? M.memoizedProps
                        : Xr(c.type, M.memoizedProps);
                    E.componentDidUpdate(
                      b,
                      M.memoizedState,
                      E.__reactInternalSnapshotBeforeUpdate,
                    );
                  }
                var R = c.updateQueue;
                R !== null && v1(c, R, E);
                break;
              case 3:
                var z = c.updateQueue;
                if (z !== null) {
                  if (((M = null), c.child !== null))
                    switch (c.child.tag) {
                      case 5:
                        M = G(c.child.stateNode);
                        break;
                      case 1:
                        M = c.child.stateNode;
                    }
                  v1(c, z, M);
                }
                break;
              case 5:
                var ie = c.stateNode;
                M === null && c.flags & 4 && Ht(ie, c.type, c.memoizedProps, c);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (be && c.memoizedState === null) {
                  var me = c.alternate;
                  if (me !== null) {
                    var ke = me.memoizedState;
                    if (ke !== null) {
                      var st = ke.dehydrated;
                      st !== null && $(st);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          Va || (c.flags & 512 && vy(c));
        } catch (Et) {
          ji(c, c.return, Et);
        }
      }
      if (c === l) {
        qe = null;
        break;
      }
      if (((M = c.sibling), M !== null)) {
        (M.return = c.return), (qe = M);
        break;
      }
      qe = c.return;
    }
  }
  function EM(l) {
    for (; qe !== null; ) {
      var c = qe;
      if (c === l) {
        qe = null;
        break;
      }
      var M = c.sibling;
      if (M !== null) {
        (M.return = c.return), (qe = M);
        break;
      }
      qe = c.return;
    }
  }
  function TM(l) {
    for (; qe !== null; ) {
      var c = qe;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var M = c.return;
            try {
              cd(4, c);
            } catch (me) {
              ji(c, M, me);
            }
            break;
          case 1:
            var E = c.stateNode;
            if (typeof E.componentDidMount == "function") {
              var b = c.return;
              try {
                E.componentDidMount();
              } catch (me) {
                ji(c, b, me);
              }
            }
            var R = c.return;
            try {
              vy(c);
            } catch (me) {
              ji(c, R, me);
            }
            break;
          case 5:
            var z = c.return;
            try {
              vy(c);
            } catch (me) {
              ji(c, z, me);
            }
        }
      } catch (me) {
        ji(c, c.return, me);
      }
      if (c === l) {
        qe = null;
        break;
      }
      var ie = c.sibling;
      if (ie !== null) {
        (ie.return = c.return), (qe = ie);
        break;
      }
      qe = c.return;
    }
  }
  var rp = 0,
    sp = 1,
    op = 2,
    ap = 3,
    lp = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var dd = Symbol.for;
    (rp = dd("selector.component")),
      (sp = dd("selector.has_pseudo_class")),
      (op = dd("selector.role")),
      (ap = dd("selector.test_id")),
      (lp = dd("selector.text"));
  }
  function Sy(l) {
    var c = ge(l);
    if (c != null) {
      if (typeof c.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return c;
    }
    if (((l = le(l)), l === null)) throw Error(o(362));
    return l.stateNode.current;
  }
  function wy(l, c) {
    switch (c.$$typeof) {
      case rp:
        if (l.type === c.value) return !0;
        break;
      case sp:
        e: {
          (c = c.value), (l = [l, 0]);
          for (var M = 0; M < l.length; ) {
            var E = l[M++],
              b = l[M++],
              R = c[b];
            if (E.tag !== 5 || !Te(E)) {
              for (; R != null && wy(E, R); ) b++, (R = c[b]);
              if (b === c.length) {
                c = !0;
                break e;
              } else
                for (E = E.child; E !== null; ) l.push(E, b), (E = E.sibling);
            }
          }
          c = !1;
        }
        return c;
      case op:
        if (l.tag === 5 && rt(l.stateNode, c.value)) return !0;
        break;
      case lp:
        if (
          (l.tag === 5 || l.tag === 6) &&
          ((l = Ee(l)), l !== null && 0 <= l.indexOf(c.value))
        )
          return !0;
        break;
      case ap:
        if (
          l.tag === 5 &&
          ((l = l.memoizedProps["data-testname"]),
          typeof l == "string" && l.toLowerCase() === c.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function My(l) {
    switch (l.$$typeof) {
      case rp:
        return "<" + (A(l.value) || "Unknown") + ">";
      case sp:
        return ":has(" + (My(l) || "") + ")";
      case op:
        return '[role="' + l.value + '"]';
      case lp:
        return '"' + l.value + '"';
      case ap:
        return '[data-testname="' + l.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function CM(l, c) {
    var M = [];
    l = [l, 0];
    for (var E = 0; E < l.length; ) {
      var b = l[E++],
        R = l[E++],
        z = c[R];
      if (b.tag !== 5 || !Te(b)) {
        for (; z != null && wy(b, z); ) R++, (z = c[R]);
        if (R === c.length) M.push(b);
        else for (b = b.child; b !== null; ) l.push(b, R), (b = b.sibling);
      }
    }
    return M;
  }
  function Ey(l, c) {
    if (!D) throw Error(o(363));
    (l = Sy(l)), (l = CM(l, c)), (c = []), (l = Array.from(l));
    for (var M = 0; M < l.length; ) {
      var E = l[M++];
      if (E.tag === 5) Te(E) || c.push(E.stateNode);
      else for (E = E.child; E !== null; ) l.push(E), (E = E.sibling);
    }
    return c;
  }
  var gI = Math.ceil,
    up = a.ReactCurrentDispatcher,
    Ty = a.ReactCurrentOwner,
    Rn = a.ReactCurrentBatchConfig,
    Dt = 0,
    Dn = null,
    kn = null,
    ii = 0,
    sr = 0,
    cu = xt(0),
    Hn = 0,
    hd = null,
    du = 0,
    cp = 0,
    Cy = 0,
    fd = null,
    Gi = null,
    by = 0,
    Ay = 1 / 0;
  function hu() {
    Ay = ln() + 500;
  }
  var dp = !1,
    Py = null,
    Ro = null,
    hp = !1,
    Lo = null,
    fp = 0,
    pd = 0,
    Ry = null,
    pp = -1,
    mp = 0;
  function Pi() {
    return Dt & 6 ? ln() : pp !== -1 ? pp : (pp = ln());
  }
  function Io(l) {
    return l.mode & 1
      ? Dt & 2 && ii !== 0
        ? ii & -ii
        : ZL.transition !== null
          ? (mp === 0 &&
              ((l = di), (di <<= 1), !(di & 4194240) && (di = 64), (mp = l)),
            mp)
          : ((l = Ut), l !== 0 ? l : Se())
      : 1;
  }
  function Ar(l, c, M) {
    if (50 < pd) throw ((pd = 0), (Ry = null), Error(o(185)));
    var E = gp(l, c);
    return E === null
      ? null
      : (Fs(E, c, M),
        (!(Dt & 2) || E !== Dn) &&
          (E === Dn && (!(Dt & 2) && (cp |= c), Hn === 4 && Oo(E, ii)),
          Wi(E, M),
          c === 1 && Dt === 0 && !(l.mode & 1) && (hu(), bo && ms())),
        E);
  }
  function gp(l, c) {
    l.lanes |= c;
    var M = l.alternate;
    for (M !== null && (M.lanes |= c), M = l, l = l.return; l !== null; )
      (l.childLanes |= c),
        (M = l.alternate),
        M !== null && (M.childLanes |= c),
        (M = l),
        (l = l.return);
    return M.tag === 3 ? M.stateNode : null;
  }
  function Wi(l, c) {
    var M = l.callbackNode;
    Zl(l, c);
    var E = hi(l, l === Dn ? ii : 0);
    if (E === 0)
      M !== null && Bs(M), (l.callbackNode = null), (l.callbackPriority = 0);
    else if (((c = E & -E), l.callbackPriority !== c)) {
      if ((M != null && Bs(M), c === 1))
        l.tag === 0 ? QL(AM.bind(null, l)) : f1(AM.bind(null, l)),
          We
            ? U(function () {
                Dt === 0 && ms();
              })
            : ps(Co, ms),
          (M = null);
      else {
        switch (Ua(E)) {
          case 1:
            M = Co;
            break;
          case 4:
            M = Rf;
            break;
          case 16:
            M = Jl;
            break;
          case 536870912:
            M = Qc;
            break;
          default:
            M = Jl;
        }
        M = UM(M, bM.bind(null, l));
      }
      (l.callbackPriority = c), (l.callbackNode = M);
    }
  }
  function bM(l, c) {
    if (((pp = -1), (mp = 0), Dt & 6)) throw Error(o(327));
    var M = l.callbackNode;
    if (Xa() && l.callbackNode !== M) return null;
    var E = hi(l, l === Dn ? ii : 0);
    if (E === 0) return null;
    if (E & 30 || E & l.expiredLanes || c) c = vp(l, E);
    else {
      c = E;
      var b = Dt;
      Dt |= 2;
      var R = LM();
      (Dn !== l || ii !== c) && (hu(), Wa(l, c));
      do
        try {
          _I();
          break;
        } catch (ie) {
          RM(l, ie);
        }
      while (1);
      Gv(),
        (up.current = R),
        (Dt = b),
        kn !== null ? (c = 0) : ((Dn = null), (ii = 0), (c = Hn));
    }
    if (c !== 0) {
      if (
        (c === 2 && ((b = fs(l)), b !== 0 && ((E = b), (c = Ly(l, b)))),
        c === 1)
      )
        throw ((M = hd), Wa(l, 0), Oo(l, E), Wi(l, ln()), M);
      if (c === 6) Oo(l, E);
      else {
        if (
          ((b = l.current.alternate),
          !(E & 30) &&
            !vI(b) &&
            ((c = vp(l, E)),
            c === 2 && ((R = fs(l)), R !== 0 && ((E = R), (c = Ly(l, R)))),
            c === 1))
        )
          throw ((M = hd), Wa(l, 0), Oo(l, E), Wi(l, ln()), M);
        switch (((l.finishedWork = b), (l.finishedLanes = E), c)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            ja(l, Gi);
            break;
          case 3:
            if (
              (Oo(l, E),
              (E & 130023424) === E && ((c = by + 500 - ln()), 10 < c))
            ) {
              if (hi(l, 0) !== 0) break;
              if (((b = l.suspendedLanes), (b & E) !== E)) {
                Pi(), (l.pingedLanes |= l.suspendedLanes & b);
                break;
              }
              l.timeoutHandle = Ce(ja.bind(null, l, Gi), c);
              break;
            }
            ja(l, Gi);
            break;
          case 4:
            if ((Oo(l, E), (E & 4194240) === E)) break;
            for (c = l.eventTimes, b = -1; 0 < E; ) {
              var z = 31 - Pn(E);
              (R = 1 << z), (z = c[z]), z > b && (b = z), (E &= ~R);
            }
            if (
              ((E = b),
              (E = ln() - E),
              (E =
                (120 > E
                  ? 120
                  : 480 > E
                    ? 480
                    : 1080 > E
                      ? 1080
                      : 1920 > E
                        ? 1920
                        : 3e3 > E
                          ? 3e3
                          : 4320 > E
                            ? 4320
                            : 1960 * gI(E / 1960)) - E),
              10 < E)
            ) {
              l.timeoutHandle = Ce(ja.bind(null, l, Gi), E);
              break;
            }
            ja(l, Gi);
            break;
          case 5:
            ja(l, Gi);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Wi(l, ln()), l.callbackNode === M ? bM.bind(null, l) : null;
  }
  function Ly(l, c) {
    var M = fd;
    return (
      l.current.memoizedState.isDehydrated && (Wa(l, c).flags |= 256),
      (l = vp(l, c)),
      l !== 2 && ((c = Gi), (Gi = M), c !== null && Iy(c)),
      l
    );
  }
  function Iy(l) {
    Gi === null ? (Gi = l) : Gi.push.apply(Gi, l);
  }
  function vI(l) {
    for (var c = l; ; ) {
      if (c.flags & 16384) {
        var M = c.updateQueue;
        if (M !== null && ((M = M.stores), M !== null))
          for (var E = 0; E < M.length; E++) {
            var b = M[E],
              R = b.getSnapshot;
            b = b.value;
            try {
              if (!wr(R(), b)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((M = c.child), c.subtreeFlags & 16384 && M !== null))
        (M.return = c), (c = M);
      else {
        if (c === l) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === l) return !0;
          c = c.return;
        }
        (c.sibling.return = c.return), (c = c.sibling);
      }
    }
    return !0;
  }
  function Oo(l, c) {
    for (
      c &= ~Cy,
        c &= ~cp,
        l.suspendedLanes |= c,
        l.pingedLanes &= ~c,
        l = l.expirationTimes;
      0 < c;

    ) {
      var M = 31 - Pn(c),
        E = 1 << M;
      (l[M] = -1), (c &= ~E);
    }
  }
  function AM(l) {
    if (Dt & 6) throw Error(o(327));
    Xa();
    var c = hi(l, 0);
    if (!(c & 1)) return Wi(l, ln()), null;
    var M = vp(l, c);
    if (l.tag !== 0 && M === 2) {
      var E = fs(l);
      E !== 0 && ((c = E), (M = Ly(l, E)));
    }
    if (M === 1) throw ((M = hd), Wa(l, 0), Oo(l, c), Wi(l, ln()), M);
    if (M === 6) throw Error(o(345));
    return (
      (l.finishedWork = l.current.alternate),
      (l.finishedLanes = c),
      ja(l, Gi),
      Wi(l, ln()),
      null
    );
  }
  function PM(l) {
    Lo !== null && Lo.tag === 0 && !(Dt & 6) && Xa();
    var c = Dt;
    Dt |= 1;
    var M = Rn.transition,
      E = Ut;
    try {
      if (((Rn.transition = null), (Ut = 1), l)) return l();
    } finally {
      (Ut = E), (Rn.transition = M), (Dt = c), !(Dt & 6) && ms();
    }
  }
  function Oy() {
    (sr = cu.current), Ne(cu);
  }
  function Wa(l, c) {
    (l.finishedWork = null), (l.finishedLanes = 0);
    var M = l.timeoutHandle;
    if ((M !== ze && ((l.timeoutHandle = ze), Ze(M)), kn !== null))
      for (M = kn.return; M !== null; ) {
        var E = M;
        switch ((Kv(E), E.tag)) {
          case 1:
            (E = E.type.childContextTypes), E != null && Gt();
            break;
          case 3:
            lu(), Ne(gt), Ne(et), iy();
            break;
          case 5:
            ty(E);
            break;
          case 4:
            lu();
            break;
          case 13:
            Ne(yn);
            break;
          case 19:
            Ne(yn);
            break;
          case 10:
            Wv(E.type._context);
            break;
          case 22:
          case 23:
            Oy();
        }
        M = M.return;
      }
    if (
      ((Dn = l),
      (kn = l = No(l.current, null)),
      (ii = sr = c),
      (Hn = 0),
      (hd = null),
      (Cy = cp = du = 0),
      (Gi = fd = null),
      gs !== null)
    ) {
      for (c = 0; c < gs.length; c++)
        if (((M = gs[c]), (E = M.interleaved), E !== null)) {
          M.interleaved = null;
          var b = E.next,
            R = M.pending;
          if (R !== null) {
            var z = R.next;
            (R.next = b), (E.next = z);
          }
          M.pending = E;
        }
      gs = null;
    }
    return l;
  }
  function RM(l, c) {
    do {
      var M = kn;
      try {
        if ((Gv(), (Gf.current = Yf), Wf)) {
          for (var E = Tn.memoizedState; E !== null; ) {
            var b = E.queue;
            b !== null && (b.pending = null), (E = E.next);
          }
          Wf = !1;
        }
        if (
          ((uu = 0),
          (Yn = fi = Tn = null),
          (id = !1),
          (rd = 0),
          (Ty.current = null),
          M === null || M.return === null)
        ) {
          (Hn = 1), (hd = c), (kn = null);
          break;
        }
        e: {
          var R = l,
            z = M.return,
            ie = M,
            me = c;
          if (
            ((c = ii),
            (ie.flags |= 32768),
            me !== null &&
              typeof me == "object" &&
              typeof me.then == "function")
          ) {
            var ke = me,
              st = ie,
              Et = st.tag;
            if (!(st.mode & 1) && (Et === 0 || Et === 11 || Et === 15)) {
              var vt = st.alternate;
              vt
                ? ((st.updateQueue = vt.updateQueue),
                  (st.memoizedState = vt.memoizedState),
                  (st.lanes = vt.lanes))
                : ((st.updateQueue = null), (st.memoizedState = null));
            }
            var an = Q1(z);
            if (an !== null) {
              (an.flags &= -257),
                Z1(an, z, ie, R, c),
                an.mode & 1 && K1(R, ke, c),
                (c = an),
                (me = ke);
              var ht = c.updateQueue;
              if (ht === null) {
                var gi = new Set();
                gi.add(me), (c.updateQueue = gi);
              } else ht.add(me);
              break e;
            } else {
              if (!(c & 1)) {
                K1(R, ke, c), Ny();
                break e;
              }
              me = Error(o(426));
            }
          } else if (gn && ie.mode & 1) {
            var Rr = Q1(z);
            if (Rr !== null) {
              !(Rr.flags & 65536) && (Rr.flags |= 256),
                Z1(Rr, z, ie, R, c),
                Jv(me);
              break e;
            }
          }
          (R = me),
            Hn !== 4 && (Hn = 2),
            fd === null ? (fd = [R]) : fd.push(R),
            (me = cy(me, ie)),
            (ie = z);
          do {
            switch (ie.tag) {
              case 3:
                (ie.flags |= 65536), (c &= -c), (ie.lanes |= c);
                var he = $1(ie, me, c);
                g1(ie, he);
                break e;
              case 1:
                R = me;
                var oe = ie.type,
                  pe = ie.stateNode;
                if (
                  !(ie.flags & 128) &&
                  (typeof oe.getDerivedStateFromError == "function" ||
                    (pe !== null &&
                      typeof pe.componentDidCatch == "function" &&
                      (Ro === null || !Ro.has(pe))))
                ) {
                  (ie.flags |= 65536), (c &= -c), (ie.lanes |= c);
                  var Ye = Y1(ie, R, c);
                  g1(ie, Ye);
                  break e;
                }
            }
            ie = ie.return;
          } while (ie !== null);
        }
        OM(M);
      } catch (ut) {
        (c = ut), kn === M && M !== null && (kn = M = M.return);
        continue;
      }
      break;
    } while (1);
  }
  function LM() {
    var l = up.current;
    return (up.current = Yf), l === null ? Yf : l;
  }
  function Ny() {
    (Hn === 0 || Hn === 3 || Hn === 2) && (Hn = 4),
      Dn === null || (!(du & 268435455) && !(cp & 268435455)) || Oo(Dn, ii);
  }
  function vp(l, c) {
    var M = Dt;
    Dt |= 2;
    var E = LM();
    (Dn === l && ii === c) || Wa(l, c);
    do
      try {
        yI();
        break;
      } catch (b) {
        RM(l, b);
      }
    while (1);
    if ((Gv(), (Dt = M), (up.current = E), kn !== null)) throw Error(o(261));
    return (Dn = null), (ii = 0), Hn;
  }
  function yI() {
    for (; kn !== null; ) IM(kn);
  }
  function _I() {
    for (; kn !== null && !Sr(); ) IM(kn);
  }
  function IM(l) {
    var c = kM(l.alternate, l, sr);
    (l.memoizedProps = l.pendingProps),
      c === null ? OM(l) : (kn = c),
      (Ty.current = null);
  }
  function OM(l) {
    var c = l;
    do {
      var M = c.alternate;
      if (((l = c.return), c.flags & 32768)) {
        if (((M = dI(M, c)), M !== null)) {
          (M.flags &= 32767), (kn = M);
          return;
        }
        if (l !== null)
          (l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null);
        else {
          (Hn = 6), (kn = null);
          return;
        }
      } else if (((M = lI(M, c, sr)), M !== null)) {
        kn = M;
        return;
      }
      if (((c = c.sibling), c !== null)) {
        kn = c;
        return;
      }
      kn = c = l;
    } while (c !== null);
    Hn === 0 && (Hn = 5);
  }
  function ja(l, c) {
    var M = Ut,
      E = Rn.transition;
    try {
      (Rn.transition = null), (Ut = 1), xI(l, c, M);
    } finally {
      (Rn.transition = E), (Ut = M);
    }
    return null;
  }
  function xI(l, c, M) {
    do Xa();
    while (Lo !== null);
    if (Dt & 6) throw Error(o(327));
    var E = l.finishedWork,
      b = l.finishedLanes;
    if (E === null) return null;
    if (((l.finishedWork = null), (l.finishedLanes = 0), E === l.current))
      throw Error(o(177));
    (l.callbackNode = null), (l.callbackPriority = 0);
    var R = E.lanes | E.childLanes;
    if (
      (To(l, R),
      l === Dn && ((kn = Dn = null), (ii = 0)),
      (!(E.subtreeFlags & 2064) && !(E.flags & 2064)) ||
        hp ||
        ((hp = !0),
        UM(Jl, function () {
          return Xa(), null;
        })),
      (R = (E.flags & 15990) !== 0),
      E.subtreeFlags & 15990 || R)
    ) {
      (R = Rn.transition), (Rn.transition = null);
      var z = Ut;
      Ut = 1;
      var ie = Dt;
      (Dt |= 4),
        (Ty.current = null),
        fI(l, E),
        pI(l, E),
        H(l.containerInfo),
        (l.current = E),
        mI(E),
        zs(),
        (Dt = ie),
        (Ut = z),
        (Rn.transition = R);
    } else l.current = E;
    if (
      (hp && ((hp = !1), (Lo = l), (fp = b)),
      (R = l.pendingLanes),
      R === 0 && (Ro = null),
      Lf(E.stateNode),
      Wi(l, ln()),
      c !== null)
    )
      for (M = l.onRecoverableError, E = 0; E < c.length; E++) M(c[E]);
    if (dp) throw ((dp = !1), (l = Py), (Py = null), l);
    return (
      fp & 1 && l.tag !== 0 && Xa(),
      (R = l.pendingLanes),
      R & 1 ? (l === Ry ? pd++ : ((pd = 0), (Ry = l))) : (pd = 0),
      ms(),
      null
    );
  }
  function Xa() {
    if (Lo !== null) {
      var l = Ua(fp),
        c = Rn.transition,
        M = Ut;
      try {
        if (((Rn.transition = null), (Ut = 16 > l ? 16 : l), Lo === null))
          var E = !1;
        else {
          if (((l = Lo), (Lo = null), (fp = 0), Dt & 6)) throw Error(o(331));
          var b = Dt;
          for (Dt |= 4, qe = l.current; qe !== null; ) {
            var R = qe,
              z = R.child;
            if (qe.flags & 16) {
              var ie = R.deletions;
              if (ie !== null) {
                for (var me = 0; me < ie.length; me++) {
                  var ke = ie[me];
                  for (qe = ke; qe !== null; ) {
                    var st = qe;
                    switch (st.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ga(8, st, R);
                    }
                    var Et = st.child;
                    if (Et !== null) (Et.return = st), (qe = Et);
                    else
                      for (; qe !== null; ) {
                        st = qe;
                        var vt = st.sibling,
                          an = st.return;
                        if ((vM(st), st === ke)) {
                          qe = null;
                          break;
                        }
                        if (vt !== null) {
                          (vt.return = an), (qe = vt);
                          break;
                        }
                        qe = an;
                      }
                  }
                }
                var ht = R.alternate;
                if (ht !== null) {
                  var gi = ht.child;
                  if (gi !== null) {
                    ht.child = null;
                    do {
                      var Rr = gi.sibling;
                      (gi.sibling = null), (gi = Rr);
                    } while (gi !== null);
                  }
                }
                qe = R;
              }
            }
            if (R.subtreeFlags & 2064 && z !== null) (z.return = R), (qe = z);
            else
              e: for (; qe !== null; ) {
                if (((R = qe), R.flags & 2048))
                  switch (R.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ga(9, R, R.return);
                  }
                var he = R.sibling;
                if (he !== null) {
                  (he.return = R.return), (qe = he);
                  break e;
                }
                qe = R.return;
              }
          }
          var oe = l.current;
          for (qe = oe; qe !== null; ) {
            z = qe;
            var pe = z.child;
            if (z.subtreeFlags & 2064 && pe !== null)
              (pe.return = z), (qe = pe);
            else
              e: for (z = oe; qe !== null; ) {
                if (((ie = qe), ie.flags & 2048))
                  try {
                    switch (ie.tag) {
                      case 0:
                      case 11:
                      case 15:
                        cd(9, ie);
                    }
                  } catch (ut) {
                    ji(ie, ie.return, ut);
                  }
                if (ie === z) {
                  qe = null;
                  break e;
                }
                var Ye = ie.sibling;
                if (Ye !== null) {
                  (Ye.return = ie.return), (qe = Ye);
                  break e;
                }
                qe = ie.return;
              }
          }
          if (
            ((Dt = b),
            ms(),
            tr && typeof tr.onPostCommitFiberRoot == "function")
          )
            try {
              tr.onPostCommitFiberRoot(Fa, l);
            } catch {}
          E = !0;
        }
        return E;
      } finally {
        (Ut = M), (Rn.transition = c);
      }
    }
    return !1;
  }
  function NM(l, c, M) {
    (c = cy(M, c)),
      (c = $1(l, c, 1)),
      Po(l, c),
      (c = Pi()),
      (l = gp(l, 1)),
      l !== null && (Fs(l, 1, c), Wi(l, c));
  }
  function ji(l, c, M) {
    if (l.tag === 3) NM(l, l, M);
    else
      for (; c !== null; ) {
        if (c.tag === 3) {
          NM(c, l, M);
          break;
        } else if (c.tag === 1) {
          var E = c.stateNode;
          if (
            typeof c.type.getDerivedStateFromError == "function" ||
            (typeof E.componentDidCatch == "function" &&
              (Ro === null || !Ro.has(E)))
          ) {
            (l = cy(M, l)),
              (l = Y1(c, l, 1)),
              Po(c, l),
              (l = Pi()),
              (c = gp(c, 1)),
              c !== null && (Fs(c, 1, l), Wi(c, l));
            break;
          }
        }
        c = c.return;
      }
  }
  function SI(l, c, M) {
    var E = l.pingCache;
    E !== null && E.delete(c),
      (c = Pi()),
      (l.pingedLanes |= l.suspendedLanes & M),
      Dn === l &&
        (ii & M) === M &&
        (Hn === 4 || (Hn === 3 && (ii & 130023424) === ii && 500 > ln() - by)
          ? Wa(l, 0)
          : (Cy |= M)),
      Wi(l, c);
  }
  function DM(l, c) {
    c === 0 &&
      (l.mode & 1
        ? ((c = Wr), (Wr <<= 1), !(Wr & 130023424) && (Wr = 4194304))
        : (c = 1));
    var M = Pi();
    (l = gp(l, c)), l !== null && (Fs(l, c, M), Wi(l, M));
  }
  function wI(l) {
    var c = l.memoizedState,
      M = 0;
    c !== null && (M = c.retryLane), DM(l, M);
  }
  function MI(l, c) {
    var M = 0;
    switch (l.tag) {
      case 13:
        var E = l.stateNode,
          b = l.memoizedState;
        b !== null && (M = b.retryLane);
        break;
      case 19:
        E = l.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    E !== null && E.delete(c), DM(l, M);
  }
  var kM;
  kM = function (l, c, M) {
    if (l !== null)
      if (l.memoizedProps !== c.pendingProps || gt.current) rr = !0;
      else {
        if (!(l.lanes & M) && !(c.flags & 128)) return (rr = !1), cI(l, c, M);
        rr = !!(l.flags & 131072);
      }
    else (rr = !1), gn && c.flags & 1048576 && w1(c, zf, c.index);
    switch (((c.lanes = 0), c.tag)) {
      case 2:
        var E = c.type;
        l !== null &&
          ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (l = c.pendingProps);
        var b = on(c, et.current);
        nu(c, M), (b = sy(null, c, E, l, b, M));
        var R = oy();
        return (
          (c.flags |= 1),
          typeof b == "object" &&
          b !== null &&
          typeof b.render == "function" &&
          b.$$typeof === void 0
            ? ((c.tag = 1),
              (c.memoizedState = null),
              (c.updateQueue = null),
              tn(E) ? ((R = !0), Bt(c)) : (R = !1),
              (c.memoizedState =
                b.state !== null && b.state !== void 0 ? b.state : null),
              Xv(c),
              (b.updater = Ff),
              (c.stateNode = b),
              (b._reactInternals = c),
              $v(c, E, l, M),
              (c = fy(null, c, E, !0, R, M)))
            : ((c.tag = 0), gn && R && Yv(c), Ai(null, c, b, M), (c = c.child)),
          c
        );
      case 16:
        E = c.elementType;
        e: {
          switch (
            (l !== null &&
              ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
            (l = c.pendingProps),
            (b = E._init),
            (E = b(E._payload)),
            (c.type = E),
            (b = c.tag = TI(E)),
            (l = Xr(E, l)),
            b)
          ) {
            case 0:
              c = hy(null, c, E, l, M);
              break e;
            case 1:
              c = oM(null, c, E, l, M);
              break e;
            case 11:
              c = tM(null, c, E, l, M);
              break e;
            case 14:
              c = nM(null, c, E, Xr(E.type, l), M);
              break e;
          }
          throw Error(o(306, E, ""));
        }
        return c;
      case 0:
        return (
          (E = c.type),
          (b = c.pendingProps),
          (b = c.elementType === E ? b : Xr(E, b)),
          hy(l, c, E, b, M)
        );
      case 1:
        return (
          (E = c.type),
          (b = c.pendingProps),
          (b = c.elementType === E ? b : Xr(E, b)),
          oM(l, c, E, b, M)
        );
      case 3:
        e: {
          if ((aM(c), l === null)) throw Error(o(387));
          (E = c.pendingProps),
            (R = c.memoizedState),
            (b = R.element),
            m1(l, c),
            Uf(c, E, null, M);
          var z = c.memoizedState;
          if (((E = z.element), be && R.isDehydrated))
            if (
              ((R = {
                element: E,
                isDehydrated: !1,
                cache: z.cache,
                transitions: z.transitions,
              }),
              (c.updateQueue.baseState = R),
              (c.memoizedState = R),
              c.flags & 256)
            ) {
              (b = Error(o(423))), (c = lM(l, c, E, M, b));
              break e;
            } else if (E !== b) {
              (b = Error(o(424))), (c = lM(l, c, E, M, b));
              break e;
            } else
              for (
                be &&
                  ((ir = Z(c.stateNode.containerInfo)),
                  (nr = c),
                  (gn = !0),
                  (qr = null),
                  (Zc = !1)),
                  M = A1(c, null, E, M),
                  c.child = M;
                M;

              )
                (M.flags = (M.flags & -3) | 4096), (M = M.sibling);
          else {
            if ((su(), E === b)) {
              c = js(l, c, M);
              break e;
            }
            Ai(l, c, E, M);
          }
          c = c.child;
        }
        return c;
      case 5:
        return (
          P1(c),
          l === null && Zv(c),
          (E = c.type),
          (b = c.pendingProps),
          (R = l !== null ? l.memoizedProps : null),
          (z = b.children),
          de(E, b) ? (z = null) : R !== null && de(E, R) && (c.flags |= 32),
          sM(l, c),
          Ai(l, c, z, M),
          c.child
        );
      case 6:
        return l === null && Zv(c), null;
      case 13:
        return uM(l, c, M);
      case 4:
        return (
          ey(c, c.stateNode.containerInfo),
          (E = c.pendingProps),
          l === null ? (c.child = ou(c, null, E, M)) : Ai(l, c, E, M),
          c.child
        );
      case 11:
        return (
          (E = c.type),
          (b = c.pendingProps),
          (b = c.elementType === E ? b : Xr(E, b)),
          tM(l, c, E, b, M)
        );
      case 7:
        return Ai(l, c, c.pendingProps, M), c.child;
      case 8:
        return Ai(l, c, c.pendingProps.children, M), c.child;
      case 12:
        return Ai(l, c, c.pendingProps.children, M), c.child;
      case 10:
        e: {
          if (
            ((E = c.type._context),
            (b = c.pendingProps),
            (R = c.memoizedProps),
            (z = b.value),
            p1(c, E, z),
            R !== null)
          )
            if (wr(R.value, z)) {
              if (R.children === b.children && !gt.current) {
                c = js(l, c, M);
                break e;
              }
            } else
              for (R = c.child, R !== null && (R.return = c); R !== null; ) {
                var ie = R.dependencies;
                if (ie !== null) {
                  z = R.child;
                  for (var me = ie.firstContext; me !== null; ) {
                    if (me.context === E) {
                      if (R.tag === 1) {
                        (me = Hs(-1, M & -M)), (me.tag = 2);
                        var ke = R.updateQueue;
                        if (ke !== null) {
                          ke = ke.shared;
                          var st = ke.pending;
                          st === null
                            ? (me.next = me)
                            : ((me.next = st.next), (st.next = me)),
                            (ke.pending = me);
                        }
                      }
                      (R.lanes |= M),
                        (me = R.alternate),
                        me !== null && (me.lanes |= M),
                        jv(R.return, M, c),
                        (ie.lanes |= M);
                      break;
                    }
                    me = me.next;
                  }
                } else if (R.tag === 10) z = R.type === c.type ? null : R.child;
                else if (R.tag === 18) {
                  if (((z = R.return), z === null)) throw Error(o(341));
                  (z.lanes |= M),
                    (ie = z.alternate),
                    ie !== null && (ie.lanes |= M),
                    jv(z, M, c),
                    (z = R.sibling);
                } else z = R.child;
                if (z !== null) z.return = R;
                else
                  for (z = R; z !== null; ) {
                    if (z === c) {
                      z = null;
                      break;
                    }
                    if (((R = z.sibling), R !== null)) {
                      (R.return = z.return), (z = R);
                      break;
                    }
                    z = z.return;
                  }
                R = z;
              }
          Ai(l, c, b.children, M), (c = c.child);
        }
        return c;
      case 9:
        return (
          (b = c.type),
          (E = c.pendingProps.children),
          nu(c, M),
          (b = Mr(b)),
          (E = E(b)),
          (c.flags |= 1),
          Ai(l, c, E, M),
          c.child
        );
      case 14:
        return (
          (E = c.type),
          (b = Xr(E, c.pendingProps)),
          (b = Xr(E.type, b)),
          nM(l, c, E, b, M)
        );
      case 15:
        return iM(l, c, c.type, c.pendingProps, M);
      case 17:
        return (
          (E = c.type),
          (b = c.pendingProps),
          (b = c.elementType === E ? b : Xr(E, b)),
          l !== null &&
            ((l.alternate = null), (c.alternate = null), (c.flags |= 2)),
          (c.tag = 1),
          tn(E) ? ((l = !0), Bt(c)) : (l = !1),
          nu(c, M),
          x1(c, E, b),
          $v(c, E, b, M),
          fy(null, c, E, !0, l, M)
        );
      case 19:
        return fM(l, c, M);
      case 22:
        return rM(l, c, M);
    }
    throw Error(o(156, c.tag));
  };
  function UM(l, c) {
    return ps(l, c);
  }
  function EI(l, c, M, E) {
    (this.tag = l),
      (this.key = M),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = c),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = E),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Pr(l, c, M, E) {
    return new EI(l, c, M, E);
  }
  function Dy(l) {
    return (l = l.prototype), !(!l || !l.isReactComponent);
  }
  function TI(l) {
    if (typeof l == "function") return Dy(l) ? 1 : 0;
    if (l != null) {
      if (((l = l.$$typeof), l === _)) return 11;
      if (l === m) return 14;
    }
    return 2;
  }
  function No(l, c) {
    var M = l.alternate;
    return (
      M === null
        ? ((M = Pr(l.tag, c, l.key, l.mode)),
          (M.elementType = l.elementType),
          (M.type = l.type),
          (M.stateNode = l.stateNode),
          (M.alternate = l),
          (l.alternate = M))
        : ((M.pendingProps = c),
          (M.type = l.type),
          (M.flags = 0),
          (M.subtreeFlags = 0),
          (M.deletions = null)),
      (M.flags = l.flags & 14680064),
      (M.childLanes = l.childLanes),
      (M.lanes = l.lanes),
      (M.child = l.child),
      (M.memoizedProps = l.memoizedProps),
      (M.memoizedState = l.memoizedState),
      (M.updateQueue = l.updateQueue),
      (c = l.dependencies),
      (M.dependencies =
        c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (M.sibling = l.sibling),
      (M.index = l.index),
      (M.ref = l.ref),
      M
    );
  }
  function yp(l, c, M, E, b, R) {
    var z = 2;
    if (((E = l), typeof l == "function")) Dy(l) && (z = 1);
    else if (typeof l == "string") z = 5;
    else
      e: switch (l) {
        case p:
          return qa(M.children, b, R, c);
        case v:
          (z = 8), (b |= 8);
          break;
        case y:
          return (
            (l = Pr(12, M, c, b | 2)), (l.elementType = y), (l.lanes = R), l
          );
        case f:
          return (l = Pr(13, M, c, b)), (l.elementType = f), (l.lanes = R), l;
        case d:
          return (l = Pr(19, M, c, b)), (l.elementType = d), (l.lanes = R), l;
        case w:
          return _p(M, b, R, c);
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case S:
                z = 10;
                break e;
              case x:
                z = 9;
                break e;
              case _:
                z = 11;
                break e;
              case m:
                z = 14;
                break e;
              case g:
                (z = 16), (E = null);
                break e;
            }
          throw Error(o(130, l == null ? l : typeof l, ""));
      }
    return (
      (c = Pr(z, M, c, b)), (c.elementType = l), (c.type = E), (c.lanes = R), c
    );
  }
  function qa(l, c, M, E) {
    return (l = Pr(7, l, E, c)), (l.lanes = M), l;
  }
  function _p(l, c, M, E) {
    return (
      (l = Pr(22, l, E, c)),
      (l.elementType = w),
      (l.lanes = M),
      (l.stateNode = {}),
      l
    );
  }
  function ky(l, c, M) {
    return (l = Pr(6, l, null, c)), (l.lanes = M), l;
  }
  function Uy(l, c, M) {
    return (
      (c = Pr(4, l.children !== null ? l.children : [], l.key, c)),
      (c.lanes = M),
      (c.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation,
      }),
      c
    );
  }
  function CI(l, c, M, E, b) {
    (this.tag = c),
      (this.containerInfo = l),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = ze),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Da(0)),
      (this.expirationTimes = Da(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Da(0)),
      (this.identifierPrefix = E),
      (this.onRecoverableError = b),
      be && (this.mutableSourceEagerHydrationData = null);
  }
  function FM(l, c, M, E, b, R, z, ie, me) {
    return (
      (l = new CI(l, c, M, ie, me)),
      c === 1 ? ((c = 1), R === !0 && (c |= 8)) : (c = 0),
      (R = Pr(3, null, null, c)),
      (l.current = R),
      (R.stateNode = l),
      (R.memoizedState = {
        element: E,
        isDehydrated: M,
        cache: null,
        transitions: null,
      }),
      Xv(R),
      l
    );
  }
  function BM(l) {
    if (!l) return At;
    l = l._reactInternals;
    e: {
      if (N(l) !== l || l.tag !== 1) throw Error(o(170));
      var c = l;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (tn(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(o(171));
    }
    if (l.tag === 1) {
      var M = l.type;
      if (tn(M)) return ni(l, M, c);
    }
    return c;
  }
  function zM(l) {
    var c = l._reactInternals;
    if (c === void 0)
      throw typeof l.render == "function"
        ? Error(o(188))
        : ((l = Object.keys(l).join(",")), Error(o(268, l)));
    return (l = Q(c)), l === null ? null : l.stateNode;
  }
  function HM(l, c) {
    if (((l = l.memoizedState), l !== null && l.dehydrated !== null)) {
      var M = l.retryLane;
      l.retryLane = M !== 0 && M < c ? M : c;
    }
  }
  function Fy(l, c) {
    HM(l, c), (l = l.alternate) && HM(l, c);
  }
  function bI(l) {
    return (l = Q(l)), l === null ? null : l.stateNode;
  }
  function AI() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (l) {
      if (l.tag === 13) {
        var c = Pi();
        Ar(l, 134217728, c), Fy(l, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (l) {
      if (l.tag === 13) {
        var c = Pi(),
          M = Io(l);
        Ar(l, M, c), Fy(l, M);
      }
    }),
    (t.attemptSynchronousHydration = function (l) {
      switch (l.tag) {
        case 3:
          var c = l.stateNode;
          if (c.current.memoizedState.isDehydrated) {
            var M = Vi(c.pendingLanes);
            M !== 0 && (ka(c, M | 1), Wi(c, ln()), !(Dt & 6) && (hu(), ms()));
          }
          break;
        case 13:
          var E = Pi();
          PM(function () {
            return Ar(l, 1, E);
          }),
            Fy(l, 1);
      }
    }),
    (t.batchedUpdates = function (l, c) {
      var M = Dt;
      Dt |= 1;
      try {
        return l(c);
      } finally {
        (Dt = M), Dt === 0 && (hu(), bo && ms());
      }
    }),
    (t.createComponentSelector = function (l) {
      return { $$typeof: rp, value: l };
    }),
    (t.createContainer = function (l, c, M, E, b, R, z) {
      return FM(l, c, !1, null, M, E, b, R, z);
    }),
    (t.createHasPseudoClassSelector = function (l) {
      return { $$typeof: sp, value: l };
    }),
    (t.createHydrationContainer = function (l, c, M, E, b, R, z, ie, me) {
      return (
        (l = FM(M, E, !0, l, b, R, z, ie, me)),
        (l.context = BM(null)),
        (M = l.current),
        (E = Pi()),
        (b = Io(M)),
        (R = Hs(E, b)),
        (R.callback = c ?? null),
        Po(M, R),
        (l.current.lanes = b),
        Fs(l, b, E),
        Wi(l, E),
        l
      );
    }),
    (t.createPortal = function (l, c, M) {
      var E =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: h,
        key: E == null ? null : "" + E,
        children: l,
        containerInfo: c,
        implementation: M,
      };
    }),
    (t.createRoleSelector = function (l) {
      return { $$typeof: op, value: l };
    }),
    (t.createTestNameSelector = function (l) {
      return { $$typeof: ap, value: l };
    }),
    (t.createTextSelector = function (l) {
      return { $$typeof: lp, value: l };
    }),
    (t.deferredUpdates = function (l) {
      var c = Ut,
        M = Rn.transition;
      try {
        return (Rn.transition = null), (Ut = 16), l();
      } finally {
        (Ut = c), (Rn.transition = M);
      }
    }),
    (t.discreteUpdates = function (l, c, M, E, b) {
      var R = Ut,
        z = Rn.transition;
      try {
        return (Rn.transition = null), (Ut = 1), l(c, M, E, b);
      } finally {
        (Ut = R), (Rn.transition = z), Dt === 0 && hu();
      }
    }),
    (t.findAllNodes = Ey),
    (t.findBoundingRects = function (l, c) {
      if (!D) throw Error(o(363));
      (c = Ey(l, c)), (l = []);
      for (var M = 0; M < c.length; M++) l.push(Re(c[M]));
      for (c = l.length - 1; 0 < c; c--) {
        M = l[c];
        for (
          var E = M.x, b = E + M.width, R = M.y, z = R + M.height, ie = c - 1;
          0 <= ie;
          ie--
        )
          if (c !== ie) {
            var me = l[ie],
              ke = me.x,
              st = ke + me.width,
              Et = me.y,
              vt = Et + me.height;
            if (E >= ke && R >= Et && b <= st && z <= vt) {
              l.splice(c, 1);
              break;
            } else if (E !== ke || M.width !== me.width || vt < R || Et > z) {
              if (!(R !== Et || M.height !== me.height || st < E || ke > b)) {
                ke > E && ((me.width += ke - E), (me.x = E)),
                  st < b && (me.width = b - ke),
                  l.splice(c, 1);
                break;
              }
            } else {
              Et > R && ((me.height += Et - R), (me.y = R)),
                vt < z && (me.height = z - Et),
                l.splice(c, 1);
              break;
            }
          }
      }
      return l;
    }),
    (t.findHostInstance = zM),
    (t.findHostInstanceWithNoPortals = function (l) {
      return (
        (l = I(l)),
        (l = l !== null ? F(l) : null),
        l === null ? null : l.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (l) {
      return zM(l);
    }),
    (t.flushControlled = function (l) {
      var c = Dt;
      Dt |= 1;
      var M = Rn.transition,
        E = Ut;
      try {
        (Rn.transition = null), (Ut = 1), l();
      } finally {
        (Ut = E), (Rn.transition = M), (Dt = c), Dt === 0 && (hu(), ms());
      }
    }),
    (t.flushPassiveEffects = Xa),
    (t.flushSync = PM),
    (t.focusWithin = function (l, c) {
      if (!D) throw Error(o(363));
      for (l = Sy(l), c = CM(l, c), c = Array.from(c), l = 0; l < c.length; ) {
        var M = c[l++];
        if (!Te(M)) {
          if (M.tag === 5 && Be(M.stateNode)) return !0;
          for (M = M.child; M !== null; ) c.push(M), (M = M.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Ut;
    }),
    (t.getFindAllNodesFailureDescription = function (l, c) {
      if (!D) throw Error(o(363));
      var M = 0,
        E = [];
      l = [Sy(l), 0];
      for (var b = 0; b < l.length; ) {
        var R = l[b++],
          z = l[b++],
          ie = c[z];
        if (
          (R.tag !== 5 || !Te(R)) &&
          (wy(R, ie) && (E.push(My(ie)), z++, z > M && (M = z)), z < c.length)
        )
          for (R = R.child; R !== null; ) l.push(R, z), (R = R.sibling);
      }
      if (M < c.length) {
        for (l = []; M < c.length; M++) l.push(My(c[M]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (E.join(" > ") +
            `

No matching component was found for:
  `) +
          l.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (l) {
      if (((l = l.current), !l.child)) return null;
      switch (l.child.tag) {
        case 5:
          return G(l.child.stateNode);
        default:
          return l.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (l) {
      if (
        ((l = {
          bundleType: l.bundleType,
          version: l.version,
          rendererPackageName: l.rendererPackageName,
          rendererConfig: l.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: bI,
          findFiberByHostInstance: l.findFiberByHostInstance || AI,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        l = !1;
      else {
        var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (c.isDisabled || !c.supportsFiber) l = !0;
        else {
          try {
            (Fa = c.inject(l)), (tr = c);
          } catch {}
          l = !!c.checkDCE;
        }
      }
      return l;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (l, c, M, E) {
      if (!D) throw Error(o(363));
      l = Ey(l, c);
      var b = Ke(l, M, E).disconnect;
      return {
        disconnect: function () {
          b();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (l, c) {
      var M = c._getVersion;
      (M = M(c._source)),
        l.mutableSourceEagerHydrationData == null
          ? (l.mutableSourceEagerHydrationData = [c, M])
          : l.mutableSourceEagerHydrationData.push(c, M);
    }),
    (t.runWithPriority = function (l, c) {
      var M = Ut;
      try {
        return (Ut = l), c();
      } finally {
        Ut = M;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (l, c, M, E) {
      var b = c.current,
        R = Pi(),
        z = Io(b);
      return (
        (M = BM(M)),
        c.context === null ? (c.context = M) : (c.pendingContext = M),
        (c = Hs(R, z)),
        (c.payload = { element: l }),
        (E = E === void 0 ? null : E),
        E !== null && (c.callback = E),
        Po(b, c),
        (l = Ar(b, z, R)),
        l !== null && kf(l, b, z),
        z
      );
    }),
    t
  );
};
EL.exports = n6;
var i6 = EL.exports;
const r6 = Wg(i6),
  s6 = (n) => typeof n == "object" && typeof n.then == "function",
  yl = [];
function bL(n, e, t = (i, r) => i === r) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const i = n.length;
  if (e.length !== i) return !1;
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1;
  return !0;
}
function AL(n, e = null, t = !1, i = {}) {
  e === null && (e = [n]);
  for (const s of yl)
    if (bL(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          i.lifespan &&
            i.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, i.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: i.equal,
    remove: () => {
      const s = yl.indexOf(r);
      s !== -1 && yl.splice(s, 1);
    },
    promise: (s6(n) ? n : n(...e))
      .then((s) => {
        (r.response = s),
          i.lifespan &&
            i.lifespan > 0 &&
            (r.timeout = setTimeout(r.remove, i.lifespan));
      })
      .catch((s) => (r.error = s)),
  };
  if ((yl.push(r), !t)) throw r.promise;
}
const o6 = (n, e, t) => AL(n, e, !1, t),
  a6 = (n, e, t) => void AL(n, e, !0, t),
  l6 = (n) => {
    if (n === void 0 || n.length === 0) yl.splice(0, yl.length);
    else {
      const e = yl.find((t) => bL(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  l1 = {},
  PL = (n) => void Object.assign(l1, n);
function u6(n, e) {
  function t(p, { args: v = [], attach: y, ...S }, x) {
    let _ = `${p[0].toUpperCase()}${p.slice(1)}`,
      f;
    if (p === "primitive") {
      if (S.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const d = S.object;
      f = Fu(d, { type: p, root: x, attach: y, primitive: !0 });
    } else {
      const d = l1[_];
      if (!d)
        throw new Error(
          `R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
        );
      if (!Array.isArray(v))
        throw new Error("R3F: The args prop must be an array!");
      f = Fu(new d(...v), {
        type: p,
        root: x,
        attach: y,
        memoizedProps: { args: v },
      });
    }
    return (
      f.__r3f.attach === void 0 &&
        (f instanceof Rt
          ? (f.__r3f.attach = "geometry")
          : f instanceof ci && (f.__r3f.attach = "material")),
      _ !== "inject" && a_(f, S),
      f
    );
  }
  function i(p, v) {
    let y = !1;
    if (v) {
      var S, x;
      (S = v.__r3f) != null && S.attach
        ? o_(p, v, v.__r3f.attach)
        : v.isObject3D && p.isObject3D && (p.add(v), (y = !0)),
        y || (x = p.__r3f) == null || x.objects.push(v),
        v.__r3f || Fu(v, {}),
        (v.__r3f.parent = p),
        vS(v),
        Bu(v);
    }
  }
  function r(p, v, y) {
    let S = !1;
    if (v) {
      var x, _;
      if ((x = v.__r3f) != null && x.attach) o_(p, v, v.__r3f.attach);
      else if (v.isObject3D && p.isObject3D) {
        (v.parent = p), v.dispatchEvent({ type: "added" });
        const f = p.children.filter((m) => m !== v),
          d = f.indexOf(y);
        (p.children = [...f.slice(0, d), v, ...f.slice(d)]), (S = !0);
      }
      S || (_ = p.__r3f) == null || _.objects.push(v),
        v.__r3f || Fu(v, {}),
        (v.__r3f.parent = p),
        vS(v),
        Bu(v);
    }
  }
  function s(p, v, y = !1) {
    p && [...p].forEach((S) => o(v, S, y));
  }
  function o(p, v, y) {
    if (v) {
      var S, x, _;
      if (
        (v.__r3f && (v.__r3f.parent = null),
        (S = p.__r3f) != null &&
          S.objects &&
          (p.__r3f.objects = p.__r3f.objects.filter((w) => w !== v)),
        (x = v.__r3f) != null && x.attach)
      )
        KC(p, v, v.__r3f.attach);
      else if (v.isObject3D && p.isObject3D) {
        var f;
        p.remove(v), (f = v.__r3f) != null && f.root && y6(og(v), v);
      }
      const m = (_ = v.__r3f) == null ? void 0 : _.primitive,
        g = !m && (y === void 0 ? v.dispose !== null : y);
      if (!m) {
        var d;
        s((d = v.__r3f) == null ? void 0 : d.objects, v, g),
          s(v.children, v, g);
      }
      if ((delete v.__r3f, g && v.dispose && v.type !== "Scene")) {
        const w = () => {
          try {
            v.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? mS.unstable_scheduleCallback(mS.unstable_IdlePriority, w)
          : w();
      }
      Bu(p);
    }
  }
  function a(p, v, y, S) {
    var x;
    const _ = (x = p.__r3f) == null ? void 0 : x.parent;
    if (!_) return;
    const f = t(v, y, p.__r3f.root);
    if (p.children) {
      for (const d of p.children) d.__r3f && i(f, d);
      p.children = p.children.filter((d) => !d.__r3f);
    }
    p.__r3f.objects.forEach((d) => i(f, d)),
      (p.__r3f.objects = []),
      p.__r3f.autoRemovedBeforeAppend || o(_, p),
      f.parent && (f.__r3f.autoRemovedBeforeAppend = !0),
      i(_, f),
      f.raycast &&
        f.__r3f.eventCount &&
        og(f).getState().internal.interaction.push(f),
      [S, S.alternate].forEach((d) => {
        d !== null &&
          ((d.stateNode = f),
          d.ref &&
            (typeof d.ref == "function" ? d.ref(f) : (d.ref.current = f)));
      });
  }
  const u = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters.",
    );
  return {
    reconciler: r6({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (p, v) => {
        if (!v) return;
        const y = p.getState().scene;
        y.__r3f && ((y.__r3f.root = p), i(y, v));
      },
      removeChildFromContainer: (p, v) => {
        v && o(p.getState().scene, v);
      },
      insertInContainerBefore: (p, v, y) => {
        if (!v || !y) return;
        const S = p.getState().scene;
        S.__r3f && r(S, v, y);
      },
      getRootHostContext: () => null,
      getChildHostContext: (p) => p,
      finalizeInitialChildren(p) {
        var v;
        return !!((v = p == null ? void 0 : p.__r3f) != null ? v : {}).handlers;
      },
      prepareUpdate(p, v, y, S) {
        var x;
        if (
          ((x = p == null ? void 0 : p.__r3f) != null ? x : {}).primitive &&
          S.object &&
          S.object !== p
        )
          return [!0];
        {
          const { args: f = [], children: d, ...m } = S,
            { args: g = [], children: w, ...T } = y;
          if (!Array.isArray(f))
            throw new Error("R3F: the args prop must be an array!");
          if (f.some((A, L) => A !== g[L])) return [!0];
          const C = kL(p, m, T, !0);
          return C.changes.length ? [!1, C] : null;
        }
      },
      commitUpdate(p, [v, y], S, x, _, f) {
        v ? a(p, S, _, f) : a_(p, y);
      },
      commitMount(p, v, y, S) {
        var x;
        const _ = (x = p.__r3f) != null ? x : {};
        p.raycast &&
          _.handlers &&
          _.eventCount &&
          og(p).getState().internal.interaction.push(p);
      },
      getPublicInstance: (p) => p,
      prepareForCommit: () => null,
      preparePortalMount: (p) => Fu(p.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(p) {
        var v;
        const { attach: y, parent: S } = (v = p.__r3f) != null ? v : {};
        y && S && KC(S, p, y), p.isObject3D && (p.visible = !1), Bu(p);
      },
      unhideInstance(p, v) {
        var y;
        const { attach: S, parent: x } = (y = p.__r3f) != null ? y : {};
        S && x && o_(x, p, S),
          ((p.isObject3D && v.visible == null) || v.visible) &&
            (p.visible = !0),
          Bu(p);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      getCurrentEventPriority: () => (e ? e() : rc.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && fn.fun(performance.now)
          ? performance.now
          : fn.fun(Date.now)
            ? Date.now
            : () => 0,
      scheduleTimeout: fn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: fn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: a_,
  };
}
var XC, qC;
const s_ = (n) => "colorSpace" in n || "outputColorSpace" in n,
  RL = () => {
    var n;
    return (n = l1.ColorManagement) != null ? n : null;
  },
  LL = (n) => n && n.isOrthographicCamera,
  c6 = (n) => n && n.hasOwnProperty("current"),
  Af =
    typeof window < "u" &&
    (((XC = window.document) != null && XC.createElement) ||
      ((qC = window.navigator) == null ? void 0 : qC.product) === "ReactNative")
      ? se.useLayoutEffect
      : se.useEffect;
function IL(n) {
  const e = se.useRef(n);
  return Af(() => void (e.current = n), [n]), e;
}
function d6({ set: n }) {
  return Af(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class OL extends se.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
OL.getDerivedStateFromError = () => ({ error: !0 });
const NL = "__default",
  $C = new Map(),
  h6 = (n) => n && !!n.memoized && !!n.changes;
function DL(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Nd = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function og(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const fn = {
  obj: (n) => n === Object(n) && !fn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {},
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (fn.str(n) || fn.num(n)) return n === e;
    const s = fn.obj(n);
    if (s && i === "reference") return n === e;
    const o = fn.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || s) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (s && t === "shallow" && i === "shallow") {
      for (a in r ? e : n)
        if (!fn.equ(n[a], e[a], { strict: r, objects: "reference" })) return !1;
    } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
    if (fn.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function f6(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function p6(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Fu(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function gS(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
  } else return { target: t, key: e };
}
const YC = /-\d+$/;
function o_(n, e, t) {
  if (fn.str(t)) {
    if (YC.test(t)) {
      const s = t.replace(YC, ""),
        { target: o, key: a } = gS(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = gS(n, t);
    (e.__r3f.previousAttach = i[r]), (i[r] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function KC(n, e, t) {
  var i, r;
  if (fn.str(t)) {
    const { target: s, key: o } = gS(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function kL(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...u } = {},
  h = !1,
) {
  var p;
  const v = (p = n == null ? void 0 : n.__r3f) != null ? p : {},
    y = Object.entries(r),
    S = [];
  if (h) {
    const _ = Object.keys(u);
    for (let f = 0; f < _.length; f++)
      r.hasOwnProperty(_[f]) || y.unshift([_[f], NL + "remove"]);
  }
  y.forEach(([_, f]) => {
    var d;
    if (
      ((d = n.__r3f) != null && d.primitive && _ === "object") ||
      fn.equ(f, u[_])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_))
      return S.push([_, f, !0, []]);
    let m = [];
    _.includes("-") && (m = _.split("-")), S.push([_, f, !1, m]);
    for (const g in r) {
      const w = r[g];
      g.startsWith(`${_}-`) && S.push([g, w, !1, g.split("-")]);
    }
  });
  const x = { ...r };
  return (
    v.memoizedProps && v.memoizedProps.args && (x.args = v.memoizedProps.args),
    v.memoizedProps &&
      v.memoizedProps.attach &&
      (x.attach = v.memoizedProps.attach),
    { memoized: x, changes: S }
  );
}
const m6 = typeof process < "u" && !1;
function a_(n, e) {
  var t, i, r;
  const s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a =
      (i = o == null || o.getState == null ? void 0 : o.getState()) != null
        ? i
        : {},
    { memoized: u, changes: h } = h6(e) ? e : kL(n, e),
    p = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = u);
  for (let y = 0; y < h.length; y++) {
    let [S, x, _, f] = h[y];
    if (s_(n)) {
      const w = "srgb",
        T = "srgb-linear";
      S === "encoding"
        ? ((S = "colorSpace"), (x = x === 3001 ? w : T))
        : S === "outputEncoding" &&
          ((S = "outputColorSpace"), (x = x === 3001 ? w : T));
    }
    let d = n,
      m = d[S];
    if (f.length && ((m = f.reduce((g, w) => g[w], n)), !(m && m.set))) {
      const [g, ...w] = f.reverse();
      (d = w.reverse().reduce((T, C) => T[C], n)), (S = g);
    }
    if (x === NL + "remove")
      if (d.constructor) {
        let g = $C.get(d.constructor);
        g || ((g = new d.constructor()), $C.set(d.constructor, g)), (x = g[S]);
      } else x = 0;
    if (_)
      x ? (s.handlers[S] = x) : delete s.handlers[S],
        (s.eventCount = Object.keys(s.handlers).length);
    else if (m && m.set && (m.copy || m instanceof Il)) {
      if (Array.isArray(x)) m.fromArray ? m.fromArray(x) : m.set(...x);
      else if (
        m.copy &&
        x &&
        x.constructor &&
        (m6
          ? m.constructor.name === x.constructor.name
          : m.constructor === x.constructor)
      )
        m.copy(x);
      else if (x !== void 0) {
        const g = m instanceof Qe;
        !g && m.setScalar
          ? m.setScalar(x)
          : m instanceof Il && x instanceof Il
            ? (m.mask = x.mask)
            : m.set(x),
          !RL() && !a.linear && g && m.convertSRGBToLinear();
      }
    } else if (
      ((d[S] = x), d[S] instanceof Mn && d[S].format === Ni && d[S].type === Os)
    ) {
      const g = d[S];
      s_(g) && s_(a.gl)
        ? (g.colorSpace = a.gl.outputColorSpace)
        : (g.encoding = a.gl.outputEncoding);
    }
    Bu(n);
  }
  if (s.parent && n.raycast && p !== s.eventCount) {
    const y = og(n).getState().internal,
      S = y.interaction.indexOf(n);
    S > -1 && y.interaction.splice(S, 1), s.eventCount && y.interaction.push(n);
  }
  return (
    !(h.length === 1 && h[0][0] === "onUpdate") &&
      h.length &&
      (r = n.__r3f) != null &&
      r.parent &&
      vS(n),
    n
  );
}
function Bu(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function vS(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function g6(n, e) {
  n.manual ||
    (LL(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Rm(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function v6() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return rc.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return rc.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return rc.ContinuousEventPriority;
    default:
      return rc.DefaultEventPriority;
  }
}
function UL(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function y6(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      UL(t.capturedMap, e, i, r);
    });
}
function _6(n) {
  function e(u) {
    const { internal: h } = n.getState(),
      p = u.offsetX - h.initialClick[0],
      v = u.offsetY - h.initialClick[1];
    return Math.round(Math.sqrt(p * p + v * v));
  }
  function t(u) {
    return u.filter((h) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((p) => {
        var v;
        return (v = h.__r3f) == null ? void 0 : v.handlers["onPointer" + p];
      }),
    );
  }
  function i(u, h) {
    const p = n.getState(),
      v = new Set(),
      y = [],
      S = h ? h(p.internal.interaction) : p.internal.interaction;
    for (let d = 0; d < S.length; d++) {
      const m = Nd(S[d]);
      m && (m.raycaster.camera = void 0);
    }
    p.previousRoot || p.events.compute == null || p.events.compute(u, p);
    function x(d) {
      const m = Nd(d);
      if (!m || !m.events.enabled || m.raycaster.camera === null) return [];
      if (m.raycaster.camera === void 0) {
        var g;
        m.events.compute == null ||
          m.events.compute(
            u,
            m,
            (g = m.previousRoot) == null ? void 0 : g.getState(),
          ),
          m.raycaster.camera === void 0 && (m.raycaster.camera = null);
      }
      return m.raycaster.camera ? m.raycaster.intersectObject(d, !0) : [];
    }
    let _ = S.flatMap(x)
      .sort((d, m) => {
        const g = Nd(d.object),
          w = Nd(m.object);
        return !g || !w
          ? d.distance - m.distance
          : w.events.priority - g.events.priority || d.distance - m.distance;
      })
      .filter((d) => {
        const m = Rm(d);
        return v.has(m) ? !1 : (v.add(m), !0);
      });
    p.events.filter && (_ = p.events.filter(_, p));
    for (const d of _) {
      let m = d.object;
      for (; m; ) {
        var f;
        (f = m.__r3f) != null &&
          f.eventCount &&
          y.push({ ...d, eventObject: m }),
          (m = m.parent);
      }
    }
    if ("pointerId" in u && p.internal.capturedMap.has(u.pointerId))
      for (let d of p.internal.capturedMap.get(u.pointerId).values())
        v.has(Rm(d.intersection)) || y.push(d.intersection);
    return y;
  }
  function r(u, h, p, v) {
    const y = n.getState();
    if (u.length) {
      const S = { stopped: !1 };
      for (const x of u) {
        const _ = Nd(x.object) || y,
          { raycaster: f, pointer: d, camera: m, internal: g } = _,
          w = new B(d.x, d.y, 0).unproject(m),
          T = (P) => {
            var I, Q;
            return (I =
              (Q = g.capturedMap.get(P)) == null
                ? void 0
                : Q.has(x.eventObject)) != null
              ? I
              : !1;
          },
          C = (P) => {
            const I = { intersection: x, target: h.target };
            g.capturedMap.has(P)
              ? g.capturedMap.get(P).set(x.eventObject, I)
              : g.capturedMap.set(P, new Map([[x.eventObject, I]])),
              h.target.setPointerCapture(P);
          },
          A = (P) => {
            const I = g.capturedMap.get(P);
            I && UL(g.capturedMap, x.eventObject, I, P);
          };
        let L = {};
        for (let P in h) {
          let I = h[P];
          typeof I != "function" && (L[P] = I);
        }
        let N = {
          ...x,
          ...L,
          pointer: d,
          intersections: u,
          stopped: S.stopped,
          delta: p,
          unprojectedPoint: w,
          ray: f.ray,
          camera: m,
          stopPropagation() {
            const P = "pointerId" in h && g.capturedMap.get(h.pointerId);
            if (
              (!P || P.has(x.eventObject)) &&
              ((N.stopped = S.stopped = !0),
              g.hovered.size &&
                Array.from(g.hovered.values()).find(
                  (I) => I.eventObject === x.eventObject,
                ))
            ) {
              const I = u.slice(0, u.indexOf(x));
              s([...I, x]);
            }
          },
          target: {
            hasPointerCapture: T,
            setPointerCapture: C,
            releasePointerCapture: A,
          },
          currentTarget: {
            hasPointerCapture: T,
            setPointerCapture: C,
            releasePointerCapture: A,
          },
          nativeEvent: h,
        };
        if ((v(N), S.stopped === !0)) break;
      }
    }
    return u;
  }
  function s(u) {
    const { internal: h } = n.getState();
    for (const p of h.hovered.values())
      if (
        !u.length ||
        !u.find(
          (v) =>
            v.object === p.object &&
            v.index === p.index &&
            v.instanceId === p.instanceId,
        )
      ) {
        const y = p.eventObject.__r3f,
          S = y == null ? void 0 : y.handlers;
        if ((h.hovered.delete(Rm(p)), y != null && y.eventCount)) {
          const x = { ...p, intersections: u };
          S.onPointerOut == null || S.onPointerOut(x),
            S.onPointerLeave == null || S.onPointerLeave(x);
        }
      }
  }
  function o(u, h) {
    for (let p = 0; p < h.length; p++) {
      const v = h[p].__r3f;
      v == null ||
        v.handlers.onPointerMissed == null ||
        v.handlers.onPointerMissed(u);
    }
  }
  function a(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (h) => {
          const { internal: p } = n.getState();
          "pointerId" in h &&
            p.capturedMap.has(h.pointerId) &&
            requestAnimationFrame(() => {
              p.capturedMap.has(h.pointerId) &&
                (p.capturedMap.delete(h.pointerId), s([]));
            });
        };
    }
    return function (p) {
      const { onPointerMissed: v, internal: y } = n.getState();
      y.lastEvent.current = p;
      const S = u === "onPointerMove",
        x = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick",
        f = i(p, S ? t : void 0),
        d = x ? e(p) : 0;
      u === "onPointerDown" &&
        ((y.initialClick = [p.offsetX, p.offsetY]),
        (y.initialHits = f.map((g) => g.eventObject))),
        x && !f.length && d <= 2 && (o(p, y.interaction), v && v(p)),
        S && s(f);
      function m(g) {
        const w = g.eventObject,
          T = w.__r3f,
          C = T == null ? void 0 : T.handlers;
        if (T != null && T.eventCount)
          if (S) {
            if (
              C.onPointerOver ||
              C.onPointerEnter ||
              C.onPointerOut ||
              C.onPointerLeave
            ) {
              const A = Rm(g),
                L = y.hovered.get(A);
              L
                ? L.stopped && g.stopPropagation()
                : (y.hovered.set(A, g),
                  C.onPointerOver == null || C.onPointerOver(g),
                  C.onPointerEnter == null || C.onPointerEnter(g));
            }
            C.onPointerMove == null || C.onPointerMove(g);
          } else {
            const A = C[u];
            A
              ? (!x || y.initialHits.includes(w)) &&
                (o(
                  p,
                  y.interaction.filter((L) => !y.initialHits.includes(L)),
                ),
                A(g))
              : x &&
                y.initialHits.includes(w) &&
                o(
                  p,
                  y.interaction.filter((L) => !y.initialHits.includes(L)),
                );
          }
      }
      r(f, p, d, m);
    };
  }
  return { handlePointer: a };
}
const FL = (n) => !!(n != null && n.render),
  BL = se.createContext(null),
  x6 = (n, e) => {
    const t = t6((a, u) => {
        const h = new B(),
          p = new B(),
          v = new B();
        function y(d = u().camera, m = p, g = u().size) {
          const { width: w, height: T, top: C, left: A } = g,
            L = w / T;
          m instanceof B ? v.copy(m) : v.set(...m);
          const N = d.getWorldPosition(h).distanceTo(v);
          if (LL(d))
            return {
              width: w / d.zoom,
              height: T / d.zoom,
              top: C,
              left: A,
              factor: 1,
              distance: N,
              aspect: L,
            };
          {
            const P = (d.fov * Math.PI) / 180,
              I = 2 * Math.tan(P / 2) * N,
              Q = I * (w / T);
            return {
              width: Q,
              height: I,
              top: C,
              left: A,
              factor: w / Q,
              distance: N,
              aspect: L,
            };
          }
        }
        let S;
        const x = (d) =>
            a((m) => ({ performance: { ...m.performance, current: d } })),
          _ = new Me();
        return {
          set: a,
          get: u,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (d = 1) => n(u(), d),
          advance: (d, m) => e(d, m, u()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new r1(),
          pointer: _,
          mouse: _,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const d = u();
              S && clearTimeout(S),
                d.performance.current !== d.performance.min &&
                  x(d.performance.min),
                (S = setTimeout(
                  () => x(u().performance.max),
                  d.performance.debounce,
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: y,
          },
          setEvents: (d) => a((m) => ({ ...m, events: { ...m.events, ...d } })),
          setSize: (d, m, g, w, T) => {
            const C = u().camera,
              A = {
                width: d,
                height: m,
                top: w || 0,
                left: T || 0,
                updateStyle: g,
              };
            a((L) => ({ size: A, viewport: { ...L.viewport, ...y(C, p, A) } }));
          },
          setDpr: (d) =>
            a((m) => {
              const g = DL(d);
              return {
                viewport: {
                  ...m.viewport,
                  dpr: g,
                  initialDpr: m.viewport.initialDpr || g,
                },
              };
            }),
          setFrameloop: (d = "always") => {
            const m = u().clock;
            m.stop(),
              (m.elapsedTime = 0),
              d !== "never" && (m.start(), (m.elapsedTime = 0)),
              a(() => ({ frameloop: d }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: se.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (d, m, g) => {
              const w = u().internal;
              return (
                (w.priority = w.priority + (m > 0 ? 1 : 0)),
                w.subscribers.push({ ref: d, priority: m, store: g }),
                (w.subscribers = w.subscribers.sort(
                  (T, C) => T.priority - C.priority,
                )),
                () => {
                  const T = u().internal;
                  T != null &&
                    T.subscribers &&
                    ((T.priority = T.priority - (m > 0 ? 1 : 0)),
                    (T.subscribers = T.subscribers.filter((C) => C.ref !== d)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: u, viewport: h, gl: p, set: v } = t.getState();
        if (u.width !== r.width || u.height !== r.height || h.dpr !== s) {
          var y;
          (r = u), (s = h.dpr), g6(a, u), p.setPixelRatio(h.dpr);
          const S =
            (y = u.updateStyle) != null
              ? y
              : typeof HTMLCanvasElement < "u" &&
                p.domElement instanceof HTMLCanvasElement;
          p.setSize(u.width, u.height, S);
        }
        a !== o &&
          ((o = a),
          v((S) => ({
            viewport: { ...S.viewport, ...S.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Lm,
  S6 = new Set(),
  w6 = new Set(),
  M6 = new Set();
function l_(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Dd(n, e) {
  switch (n) {
    case "before":
      return l_(S6, e);
    case "after":
      return l_(w6, e);
    case "tail":
      return l_(M6, e);
  }
}
let u_, c_;
function d_(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      u_ = e.internal.subscribers,
      Lm = 0;
    Lm < u_.length;
    Lm++
  )
    (c_ = u_[Lm]), c_.ref.current(c_.store.getState(), i, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function E6(n) {
  let e = !1,
    t,
    i,
    r;
  function s(u) {
    (i = requestAnimationFrame(s)), (e = !0), (t = 0), Dd("before", u);
    for (const p of n.values()) {
      var h;
      (r = p.store.getState()),
        r.internal.active &&
          (r.frameloop === "always" || r.internal.frames > 0) &&
          !((h = r.gl.xr) != null && h.isPresenting) &&
          (t += d_(u, r));
    }
    if ((Dd("after", u), t === 0))
      return Dd("tail", u), (e = !1), cancelAnimationFrame(i);
  }
  function o(u, h = 1) {
    var p;
    if (!u) return n.forEach((v) => o(v.store.getState()), h);
    ((p = u.gl.xr) != null && p.isPresenting) ||
      !u.internal.active ||
      u.frameloop === "never" ||
      ((u.internal.frames = Math.min(60, u.internal.frames + h)),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function a(u, h = !0, p, v) {
    if ((h && Dd("before", u), p)) d_(u, p, v);
    else for (const y of n.values()) d_(u, y.store.getState());
    h && Dd("after", u);
  }
  return { loop: s, invalidate: o, advance: a };
}
function zL() {
  const n = se.useContext(BL);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function T6(n = (t) => t, e) {
  return zL()(n, e);
}
function u1(n, e = 0) {
  const t = zL(),
    i = t.getState().internal.subscribe,
    r = IL(n);
  return Af(() => i(r, e, t), [e, i, t]), null;
}
const QC = new WeakMap();
function HL(n, e) {
  return function (t, ...i) {
    let r = QC.get(t);
    return (
      r || ((r = new t()), QC.set(t, r)),
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (u) => {
                  u.scene && Object.assign(u, f6(u.scene)), o(u);
                },
                e,
                (u) =>
                  a(
                    new Error(
                      `Could not load ${s}: ${u == null ? void 0 : u.message}`,
                    ),
                  ),
              ),
            ),
        ),
      ).finally(() => (r.dispose == null ? void 0 : r.dispose()))
    );
  };
}
function Pf(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = o6(HL(t, i), [n, ...r], { equal: fn.equ });
  return Array.isArray(e) ? s : s[0];
}
Pf.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e];
  return a6(HL(t), [n, ...i]);
};
Pf.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return l6([n, ...t]);
};
const Hc = new Map(),
  { invalidate: ZC, advance: JC } = E6(Hc),
  { reconciler: Vg, applyProps: ll } = u6(Hc, v6),
  ku = { objects: "shallow", strict: !1 },
  C6 = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return FL(t)
      ? t
      : new Vw({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function b6(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
    return { width: i, height: r, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: i,
      height: r,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect();
    return { width: i, height: r, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function A6(n) {
  const e = Hc.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || x6(ZC, JC),
    o =
      t ||
      Vg.createContainer(s, rc.ConcurrentRoot, null, !1, null, "", r, null);
  e || Hc.set(n, { fiber: o, store: s });
  let a,
    u = !1,
    h;
  return {
    configure(p = {}) {
      let {
          gl: v,
          size: y,
          scene: S,
          events: x,
          onCreated: _,
          shadows: f = !1,
          linear: d = !1,
          flat: m = !1,
          legacy: g = !1,
          orthographic: w = !1,
          frameloop: T = "always",
          dpr: C = [1, 2],
          performance: A,
          raycaster: L,
          camera: N,
          onPointerMissed: P,
        } = p,
        I = s.getState(),
        Q = I.gl;
      I.gl || I.set({ gl: (Q = C6(v, n)) });
      let ue = I.raycaster;
      ue || I.set({ raycaster: (ue = new SL()) });
      const { params: F, ...X } = L || {};
      if (
        (fn.equ(X, ue, ku) || ll(ue, { ...X }),
        fn.equ(F, ue.params, ku) || ll(ue, { params: { ...ue.params, ...F } }),
        !I.camera || (I.camera === h && !fn.equ(h, N, ku)))
      ) {
        h = N;
        const ae = N instanceof xf,
          xe = ae
            ? N
            : w
              ? new Mf(0, 0, 0, 0, 0.1, 1e3)
              : new ei(75, 0, 0.1, 1e3);
        ae ||
          ((xe.position.z = 5),
          N && ll(xe, N),
          !I.camera && !(N != null && N.rotation) && xe.lookAt(0, 0, 0)),
          I.set({ camera: xe }),
          (ue.camera = xe);
      }
      if (!I.scene) {
        let ae;
        S instanceof zg ? (ae = S) : ((ae = new zg()), S && ll(ae, S)),
          I.set({ scene: Fu(ae) });
      }
      if (!I.xr) {
        var G;
        const ae = (de, ye) => {
            const Ce = s.getState();
            Ce.frameloop !== "never" && JC(de, !0, Ce, ye);
          },
          xe = () => {
            const de = s.getState();
            (de.gl.xr.enabled = de.gl.xr.isPresenting),
              de.gl.xr.setAnimationLoop(de.gl.xr.isPresenting ? ae : null),
              de.gl.xr.isPresenting || ZC(de);
          },
          te = {
            connect() {
              const de = s.getState().gl;
              de.xr.addEventListener("sessionstart", xe),
                de.xr.addEventListener("sessionend", xe);
            },
            disconnect() {
              const de = s.getState().gl;
              de.xr.removeEventListener("sessionstart", xe),
                de.xr.removeEventListener("sessionend", xe);
            },
          };
        typeof ((G = Q.xr) == null ? void 0 : G.addEventListener) ==
          "function" && te.connect(),
          I.set({ xr: te });
      }
      if (Q.shadowMap) {
        const ae = Q.shadowMap.enabled,
          xe = Q.shadowMap.type;
        if (((Q.shadowMap.enabled = !!f), fn.boo(f))) Q.shadowMap.type = eh;
        else if (fn.str(f)) {
          var ne;
          const te = { basic: p2, percentage: hv, soft: eh, variance: Jr };
          Q.shadowMap.type = (ne = te[f]) != null ? ne : eh;
        } else fn.obj(f) && Object.assign(Q.shadowMap, f);
        (ae !== Q.shadowMap.enabled || xe !== Q.shadowMap.type) &&
          (Q.shadowMap.needsUpdate = !0);
      }
      const k = RL();
      k &&
        ("enabled" in k
          ? (k.enabled = !g)
          : "legacyMode" in k && (k.legacyMode = g)),
        ll(Q, { outputEncoding: d ? 3e3 : 3001, toneMapping: m ? Is : ww }),
        I.legacy !== g && I.set(() => ({ legacy: g })),
        I.linear !== d && I.set(() => ({ linear: d })),
        I.flat !== m && I.set(() => ({ flat: m })),
        v && !fn.fun(v) && !FL(v) && !fn.equ(v, Q, ku) && ll(Q, v),
        x && !I.events.handlers && I.set({ events: x(s) });
      const ee = b6(n, y);
      return (
        fn.equ(ee, I.size, ku) ||
          I.setSize(ee.width, ee.height, ee.updateStyle, ee.top, ee.left),
        C && I.viewport.dpr !== DL(C) && I.setDpr(C),
        I.frameloop !== T && I.setFrameloop(T),
        I.onPointerMissed || I.set({ onPointerMissed: P }),
        A &&
          !fn.equ(A, I.performance, ku) &&
          I.set((ae) => ({ performance: { ...ae.performance, ...A } })),
        (a = _),
        (u = !0),
        this
      );
    },
    render(p) {
      return (
        u || this.configure(),
        Vg.updateContainer(
          se.createElement(P6, {
            store: s,
            children: p,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {},
        ),
        s
      );
    },
    unmount() {
      VL(n);
    },
  };
}
function P6({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    Af(() => {
      const r = n.getState();
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i);
    }, []),
    se.createElement(BL.Provider, { value: n }, e)
  );
}
function VL(n, e) {
  const t = Hc.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1),
      Vg.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, u;
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (u = r.gl) != null && u.xr && r.xr.disconnect(),
                p6(r),
                Hc.delete(n),
                e && e(n);
            } catch {}
          }, 500);
      });
  }
}
Vg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: se.version,
});
function yS(n, e, t) {
  var i, r, s, o, a;
  e == null && (e = 100);
  function u() {
    var p = Date.now() - o;
    p < e && p >= 0
      ? (i = setTimeout(u, e - p))
      : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)));
  }
  var h = function () {
    (s = this), (r = arguments), (o = Date.now());
    var p = t && !i;
    return (
      i || (i = setTimeout(u, e)), p && ((a = n.apply(s, r)), (s = r = null)), a
    );
  };
  return (
    (h.clear = function () {
      i && (clearTimeout(i), (i = null));
    }),
    (h.flush = function () {
      i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null));
    }),
    h
  );
}
yS.debounce = yS;
var R6 = yS;
const eb = Wg(R6);
function L6(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: i,
    offsetSize: r,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = i || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills",
    );
  const [o, a] = se.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = se.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    h = e ? (typeof e == "number" ? e : e.scroll) : null,
    p = e ? (typeof e == "number" ? e : e.resize) : null,
    v = se.useRef(!1);
  se.useEffect(() => ((v.current = !0), () => void (v.current = !1)));
  const [y, S, x] = se.useMemo(() => {
    const m = () => {
      if (!u.current.element) return;
      const {
          left: g,
          top: w,
          width: T,
          height: C,
          bottom: A,
          right: L,
          x: N,
          y: P,
        } = u.current.element.getBoundingClientRect(),
        I = {
          left: g,
          top: w,
          width: T,
          height: C,
          bottom: A,
          right: L,
          x: N,
          y: P,
        };
      u.current.element instanceof HTMLElement &&
        r &&
        ((I.height = u.current.element.offsetHeight),
        (I.width = u.current.element.offsetWidth)),
        Object.freeze(I),
        v.current &&
          !D6(u.current.lastBounds, I) &&
          a((u.current.lastBounds = I));
    };
    return [m, p ? eb(m, p) : m, h ? eb(m, h) : m];
  }, [a, r, h, p]);
  function _() {
    u.current.scrollContainers &&
      (u.current.scrollContainers.forEach((m) =>
        m.removeEventListener("scroll", x, !0),
      ),
      (u.current.scrollContainers = null)),
      u.current.resizeObserver &&
        (u.current.resizeObserver.disconnect(),
        (u.current.resizeObserver = null));
  }
  function f() {
    u.current.element &&
      ((u.current.resizeObserver = new s(x)),
      u.current.resizeObserver.observe(u.current.element),
      t &&
        u.current.scrollContainers &&
        u.current.scrollContainers.forEach((m) =>
          m.addEventListener("scroll", x, { capture: !0, passive: !0 }),
        ));
  }
  const d = (m) => {
    !m ||
      m === u.current.element ||
      (_(), (u.current.element = m), (u.current.scrollContainers = GL(m)), f());
  };
  return (
    O6(x, !!t),
    I6(S),
    se.useEffect(() => {
      _(), f();
    }, [t, x, S]),
    se.useEffect(() => _, []),
    [d, o, y]
  );
}
function I6(n) {
  se.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function O6(n, e) {
  se.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function GL(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...GL(n.parentElement)]
  );
}
const N6 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  D6 = (n, e) => N6.every((t) => n[t] === e[t]);
var k6 = Object.defineProperty,
  U6 = Object.defineProperties,
  F6 = Object.getOwnPropertyDescriptors,
  tb = Object.getOwnPropertySymbols,
  B6 = Object.prototype.hasOwnProperty,
  z6 = Object.prototype.propertyIsEnumerable,
  nb = (n, e, t) =>
    e in n
      ? k6(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  ib = (n, e) => {
    for (var t in e || (e = {})) B6.call(e, t) && nb(n, t, e[t]);
    if (tb) for (var t of tb(e)) z6.call(e, t) && nb(n, t, e[t]);
    return n;
  },
  H6 = (n, e) => U6(n, F6(e));
function WL(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = WL(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function jL(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const c1 = jL(se.createContext(null));
class XL extends se.Component {
  render() {
    return se.createElement(
      c1.Provider,
      { value: this._reactInternals },
      this.props.children,
    );
  }
}
const { ReactCurrentOwner: rb, ReactCurrentDispatcher: sb } =
  se.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function V6() {
  const n = se.useContext(c1);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!",
    );
  const e = se.useId();
  return se.useMemo(() => {
    for (const i of [
      rb == null ? void 0 : rb.current,
      n,
      n == null ? void 0 : n.alternate,
    ]) {
      if (!i) continue;
      const r = WL(i, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n, e]);
}
function G6() {
  var n, e;
  const t = V6(),
    [i] = se.useState(() => new Map());
  i.clear();
  let r = t;
  for (; r; ) {
    const s = (n = r.type) == null ? void 0 : n._context;
    s &&
      s !== c1 &&
      !i.has(s) &&
      i.set(
        s,
        (e = sb == null ? void 0 : sb.current) == null
          ? void 0
          : e.readContext(jL(s)),
      ),
      (r = r.return);
  }
  return i;
}
function W6() {
  const n = G6();
  return se.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          se.createElement(
            e,
            null,
            se.createElement(t.Provider, H6(ib({}, i), { value: n.get(t) })),
          ),
        (e) => se.createElement(XL, ib({}, e)),
      ),
    [n],
  );
}
const h_ = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function j6(n) {
  const { handlePointer: e } = _6(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1,
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(h_).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [u, h] = h_[o];
          t.addEventListener(u, a, { passive: h });
        });
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = h_[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
const X6 = se.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = j6,
      eventSource: a,
      eventPrefix: u,
      shadows: h,
      linear: p,
      flat: v,
      legacy: y,
      orthographic: S,
      frameloop: x,
      dpr: _,
      performance: f,
      raycaster: d,
      camera: m,
      scene: g,
      onPointerMissed: w,
      onCreated: T,
      ...C
    },
    A,
  ) {
    se.useMemo(() => PL(ZV), []);
    const L = W6(),
      [N, P] = L6({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      I = se.useRef(null),
      Q = se.useRef(null);
    se.useImperativeHandle(A, () => I.current);
    const ue = IL(w),
      [F, X] = se.useState(!1),
      [G, ne] = se.useState(!1);
    if (F) throw F;
    if (G) throw G;
    const k = se.useRef(null);
    Af(() => {
      const H = I.current;
      P.width > 0 &&
        P.height > 0 &&
        H &&
        (k.current || (k.current = A6(H)),
        k.current.configure({
          gl: s,
          events: o,
          shadows: h,
          linear: p,
          flat: v,
          legacy: y,
          orthographic: S,
          frameloop: x,
          dpr: _,
          performance: f,
          raycaster: d,
          camera: m,
          scene: g,
          size: P,
          onPointerMissed: (...ee) =>
            ue.current == null ? void 0 : ue.current(...ee),
          onCreated: (ee) => {
            ee.events.connect == null ||
              ee.events.connect(a ? (c6(a) ? a.current : a) : Q.current),
              u &&
                ee.setEvents({
                  compute: (ae, xe) => {
                    const te = ae[u + "X"],
                      de = ae[u + "Y"];
                    xe.pointer.set(
                      (te / xe.size.width) * 2 - 1,
                      -(de / xe.size.height) * 2 + 1,
                    ),
                      xe.raycaster.setFromCamera(xe.pointer, xe.camera);
                  },
                }),
              T == null || T(ee);
          },
        }),
        k.current.render(
          se.createElement(
            L,
            null,
            se.createElement(
              OL,
              { set: ne },
              se.createElement(
                se.Suspense,
                { fallback: se.createElement(d6, { set: X }) },
                e,
              ),
            ),
          ),
        ));
    }),
      se.useEffect(() => {
        const H = I.current;
        if (H) return () => VL(H);
      }, []);
    const W = a ? "none" : "auto";
    return se.createElement(
      "div",
      Ma(
        {
          ref: Q,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: W,
            ...r,
          },
        },
        C,
      ),
      se.createElement(
        "div",
        { ref: N, style: { width: "100%", height: "100%" } },
        se.createElement("canvas", { ref: I, style: { display: "block" } }, t),
      ),
    );
  }),
  q6 = se.forwardRef(function (e, t) {
    return se.createElement(
      XL,
      null,
      se.createElement(X6, Ma({}, e, { ref: t })),
    );
  }),
  ob = (n) => n === Object(n) && !Array.isArray(n) && typeof n != "function";
function d1(n, e) {
  const t = T6((r) => r.gl),
    i = Pf(zv, ob(n) ? Object.values(n) : n);
  if (
    (se.useLayoutEffect(() => {
      e == null || e(i);
    }, [e]),
    se.useEffect(() => {
      "initTexture" in t && (Array.isArray(i) ? i : [i]).forEach(t.initTexture);
    }, [t, i]),
    ob(n))
  ) {
    const r = {};
    let s = 0;
    for (const o in n) r[o] = i[s++];
    return r;
  } else return i;
}
d1.preload = (n) => Pf.preload(zv, n);
d1.clear = (n) => Pf.clear(zv, n);
const f_ = (n, e) => {
  "updateRanges" in n ? (n.updateRanges[0] = e) : (n.updateRange = e);
};
let Im;
const $6 = new Uint8Array(16);
function Y6() {
  if (
    !Im &&
    ((Im =
      typeof crypto < "u" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto)),
    !Im)
  )
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
    );
  return Im($6);
}
const ri = [];
for (let n = 0; n < 256; ++n) ri.push((n + 256).toString(16).slice(1));
function K6(n, e = 0) {
  return (
    ri[n[e + 0]] +
    ri[n[e + 1]] +
    ri[n[e + 2]] +
    ri[n[e + 3]] +
    "-" +
    ri[n[e + 4]] +
    ri[n[e + 5]] +
    "-" +
    ri[n[e + 6]] +
    ri[n[e + 7]] +
    "-" +
    ri[n[e + 8]] +
    ri[n[e + 9]] +
    "-" +
    ri[n[e + 10]] +
    ri[n[e + 11]] +
    ri[n[e + 12]] +
    ri[n[e + 13]] +
    ri[n[e + 14]] +
    ri[n[e + 15]]
  );
}
const Q6 =
    typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  ab = { randomUUID: Q6 };
function Z6(n, e, t) {
  if (ab.randomUUID && !e && !n) return ab.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || Y6)();
  if (((i[6] = (i[6] & 15) | 64), (i[8] = (i[8] & 63) | 128), e)) {
    t = t || 0;
    for (let r = 0; r < 16; ++r) e[t + r] = i[r];
    return e;
  }
  return K6(i);
}
const J6 =
    "https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",
  lb = new _t(),
  Om = new B(),
  Nm = new li(),
  ub = new B(),
  cb = new li(),
  kd = new B(),
  h1 = se.createContext(null),
  qL = se.forwardRef(
    (
      {
        children: n,
        material: e = Bv,
        texture: t = J6,
        range: i,
        limit: r = 200,
        frustumCulled: s,
        ...o
      },
      a,
    ) => {
      var u, h;
      const p = se.useMemo(
        () =>
          class extends e {
            constructor() {
              super();
              const L =
                parseInt(gf.replace(/\D+/g, "")) >= 154
                  ? "opaque_fragment"
                  : "output_fragment";
              this.onBeforeCompile = (N) => {
                (N.vertexShader =
                  `attribute float opacity;
               varying float vOpacity;
              ` +
                  N.vertexShader.replace(
                    "#include <fog_vertex>",
                    `#include <fog_vertex>
                 vOpacity = opacity;
                `,
                  )),
                  (N.fragmentShader =
                    `varying float vOpacity;
              ` +
                    N.fragmentShader.replace(
                      `#include <${L}>`,
                      `#include <${L}>
                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);
                `,
                    ));
              };
            }
          },
        [e],
      );
      PL({ CloudMaterial: p });
      const v = se.useRef(null),
        y = se.useRef([]),
        S = se.useMemo(
          () => new Float32Array(Array.from({ length: r }, () => 1)),
          [r],
        ),
        x = se.useMemo(
          () =>
            new Float32Array(Array.from({ length: r }, () => [1, 1, 1]).flat()),
          [r],
        ),
        _ = d1(t);
      let f = 0,
        d = 0,
        m;
      const g = new li(),
        w = new B(0, 0, 1),
        T = new B();
      u1((L, N) => {
        for (
          f = L.clock.getElapsedTime(),
            lb.copy(v.current.matrixWorld).invert(),
            L.camera.matrixWorld.decompose(ub, cb, kd),
            d = 0;
          d < y.current.length;
          d++
        )
          (m = y.current[d]),
            m.ref.current.matrixWorld.decompose(Om, Nm, kd),
            Om.add(T.copy(m.position).applyQuaternion(Nm).multiply(kd)),
            Nm.copy(cb).multiply(
              g.setFromAxisAngle(w, (m.rotation += N * m.rotationFactor)),
            ),
            kd.multiplyScalar(
              m.volume +
                ((1 + Math.sin(f * m.density * m.speed)) / 2) * m.growth,
            ),
            m.matrix.compose(Om, Nm, kd).premultiply(lb),
            (m.dist = Om.distanceTo(ub));
        for (
          y.current.sort((P, I) => I.dist - P.dist), d = 0;
          d < y.current.length;
          d++
        )
          (m = y.current[d]),
            (S[d] = m.opacity * (m.dist < m.fade - 1 ? m.dist / m.fade : 1)),
            v.current.setMatrixAt(d, m.matrix),
            v.current.setColorAt(d, m.color);
        (v.current.geometry.attributes.opacity.needsUpdate = !0),
          (v.current.instanceMatrix.needsUpdate = !0),
          v.current.instanceColor && (v.current.instanceColor.needsUpdate = !0);
      }),
        se.useLayoutEffect(() => {
          const L = Math.min(r, i !== void 0 ? i : r, y.current.length);
          (v.current.count = L),
            f_(v.current.instanceMatrix, { offset: 0, count: L * 16 }),
            v.current.instanceColor &&
              f_(v.current.instanceColor, { offset: 0, count: L * 3 }),
            f_(v.current.geometry.attributes.opacity, { offset: 0, count: L });
        });
      let C = [
          (u = _.image.width) !== null && u !== void 0 ? u : 1,
          (h = _.image.height) !== null && h !== void 0 ? h : 1,
        ],
        A = Math.max(C[0], C[1]);
      return (
        (C = [C[0] / A, C[1] / A]),
        se.createElement(
          "group",
          Ma({ ref: a }, o),
          se.createElement(
            h1.Provider,
            { value: y },
            n,
            se.createElement(
              "instancedMesh",
              {
                matrixAutoUpdate: !1,
                ref: v,
                args: [null, null, r],
                frustumCulled: s,
              },
              se.createElement("instancedBufferAttribute", {
                usage: rS,
                attach: "instanceColor",
                args: [x, 3],
              }),
              se.createElement(
                "planeGeometry",
                { args: [...C] },
                se.createElement("instancedBufferAttribute", {
                  usage: rS,
                  attach: "attributes-opacity",
                  args: [S, 1],
                }),
              ),
              se.createElement("cloudMaterial", {
                key: e.name,
                map: _,
                transparent: !0,
                depthWrite: !1,
              }),
            ),
          ),
        )
      );
    },
  ),
  db = se.forwardRef(
    (
      {
        opacity: n = 1,
        speed: e = 0,
        bounds: t = [5, 1, 1],
        segments: i = 20,
        color: r = "#ffffff",
        fade: s = 10,
        volume: o = 6,
        smallestVolume: a = 0.25,
        distribute: u = null,
        growth: h = 4,
        concentrate: p = "inside",
        seed: v = Math.random(),
        ...y
      },
      S,
    ) => {
      function x() {
        const g = Math.sin(v++) * 1e4;
        return g - Math.floor(g);
      }
      const _ = se.useContext(h1),
        f = se.useRef(null),
        [d] = se.useState(() => Z6()),
        m = se.useMemo(
          () =>
            [...new Array(i)].map((g, w) => ({
              segments: i,
              bounds: new B(1, 1, 1),
              position: new B(),
              uuid: d,
              index: w,
              ref: f,
              dist: 0,
              matrix: new _t(),
              color: new Qe(),
              rotation: w * (Math.PI / i),
            })),
          [i, d],
        );
      return (
        se.useLayoutEffect(() => {
          m.forEach((g, w) => {
            var T;
            ll(g, {
              volume: o,
              color: r,
              speed: e,
              growth: h,
              opacity: n,
              fade: s,
              bounds: t,
              density: Math.max(0.5, x()),
              rotationFactor: Math.max(0.2, 0.5 * x()) * e,
            });
            const C = u == null ? void 0 : u(g, w);
            (C || i > 1) &&
              g.position
                .copy(g.bounds)
                .multiply(
                  (T = C == null ? void 0 : C.point) !== null && T !== void 0
                    ? T
                    : { x: x() * 2 - 1, y: x() * 2 - 1, z: x() * 2 - 1 },
                );
            const A = Math.abs(g.position.x),
              L = Math.abs(g.position.y),
              N = Math.abs(g.position.z),
              P = Math.max(A, L, N);
            (g.length = 1),
              A === P && (g.length -= A / g.bounds.x),
              L === P && (g.length -= L / g.bounds.y),
              N === P && (g.length -= N / g.bounds.z),
              (g.volume =
                ((C == null ? void 0 : C.volume) !== void 0
                  ? C.volume
                  : Math.max(
                      Math.max(0, a),
                      p === "random"
                        ? x()
                        : p === "inside"
                          ? g.length
                          : 1 - g.length,
                    )) * o);
          });
        }, [p, t, s, r, n, h, o, v, i, e]),
        se.useLayoutEffect(() => {
          const g = m;
          return (
            (_.current = [..._.current, ...g]),
            () => {
              _.current = _.current.filter((w) => w.uuid !== d);
            }
          );
        }, [m]),
        se.useImperativeHandle(S, () => f.current, []),
        se.createElement("group", Ma({ ref: f }, y))
      );
    },
  ),
  Uu = se.forwardRef((n, e) =>
    se.useContext(h1)
      ? se.createElement(db, Ma({ ref: e }, n))
      : se.createElement(qL, null, se.createElement(db, Ma({ ref: e }, n))),
  );
function eG(n) {
  const { bgColor: e, cloudColor: t, lightning: i, rain: r } = n,
    s = [Dm(), Dm(), Dm(), Dm()];
  return ce.jsx("div", {
    className: `absolute bg-[${e}] top-0 bottom-0 right-0 left-0`,
    children: ce.jsxs(q6, {
      camera: { position: [0, -10, 10], fov: 75 },
      children: [
        ce.jsx(iG, { cloudColor: t, rns: s }),
        ce.jsx("ambientLight", { intensity: Math.PI / 10 }),
        !!r && ce.jsx(tG, {}),
        !!i && ce.jsx(nG, {}),
      ],
    }),
  });
}
function tG() {
  const e = se.useMemo(() => {
      const i = new Rt(),
        r = new Float32Array(1e4 * 3);
      for (let s = 0; s < 1e4; s++)
        (r[s * 3] = Math.random() * 400 - 200),
          (r[s * 3 + 1] = Math.random() * 500 - 250),
          (r[s * 3 + 2] = Math.random() * 400 - 200);
      return i.setAttribute("position", new Jt(r, 3)), i;
    }, [1e4]),
    t = new Mv({ color: "lightgray", size: 0.1, transparent: !0 });
  return (
    u1(() => {
      var i, r;
      if (
        (r =
          (i = e == null ? void 0 : e.attributes) == null
            ? void 0
            : i.position) != null &&
        r.array
      ) {
        const s = e.attributes.position.array,
          o = new Float32Array(s.length);
        for (let a = 0; a < 1e4; a++)
          (o[a * 3] = s[a * 3] ?? 0),
            o[a * 3 + 1] !== void 0 &&
              ((o[a * 3 + 1] = (s[a * 3 + 1] ?? 0) - 0.6),
              (o[a * 3 + 1] ?? 0) < -200 && (o[a * 3 + 1] = 200)),
            (o[a * 3 + 2] = s[a * 3 + 2] ?? 0);
        e.setAttribute("position", new Jt(o, 3));
      }
    }),
    ce.jsx("points", { geometry: e, material: t })
  );
}
const nG = () => {
  const n = se.useRef(null);
  return (
    se.useEffect(() => {
      const e = setInterval(
        () => {
          n.current &&
            ((n.current.intensity = 1e4 + Math.random() * 1e6),
            (n.current.distance = 1e4),
            n.current.color.setHSL(0.6, 0.5, 1)),
            setTimeout(() => {
              n.current && (n.current.intensity = 0);
            }, 50);
        },
        Math.random() * 1e4 + 5e3,
      );
      return () => clearInterval(e);
    }, []),
    ce.jsx("pointLight", { ref: n, position: [0, 0, 0] })
  );
};
function Dm() {
  return Math.floor(Math.random() * 5) + 1;
}
function iG({ cloudColor: n = "gray", rns: e = [] }) {
  const t = se.useRef(),
    i = se.useRef(),
    {
      color: r,
      x: s,
      y: o,
      z: a,
      ...u
    } = {
      seed: 1,
      segments: 20,
      volume: 6,
      opacity: 0.8,
      fade: 10,
      growth: 4,
      speed: 0.1,
      x: 6,
      y: 1,
      z: 1,
      color: "white",
    };
  return (
    u1((h) => {
      (t.current.rotation.y = Math.cos(h.clock.elapsedTime / 10) / 2),
        (t.current.rotation.x = Math.sin(h.clock.elapsedTime / 10) / 2);
    }),
    ce.jsx(ce.Fragment, {
      children: ce.jsx("group", {
        ref: t,
        children: ce.jsxs(qL, {
          material: Bv,
          limit: 400,
          children: [
            ce.jsx(Uu, { ref: i, ...u, bounds: [s, o, a], color: n }),
            ce.jsx(Uu, {
              ...u,
              bounds: [s, o, a],
              color: n,
              position: [15, 0, 0],
              seed: e[0],
            }),
            ce.jsx(Uu, {
              ...u,
              bounds: [s, o, a],
              color: n,
              position: [-15, 0, 0],
              seed: e[1],
            }),
            ce.jsx(Uu, {
              ...u,
              bounds: [s, o, a],
              color: n,
              position: [0, 0, -12],
              seed: e[2],
            }),
            ce.jsx(Uu, {
              ...u,
              bounds: [s, o, a],
              color: n,
              seed: e[3],
              position: [0, 0, 12],
            }),
            ce.jsx(Uu, {
              bounds: 200,
              color: n,
              concentrate: "outside",
              growth: 100,
              opacity: 1.25,
              seed: 0.3,
              volume: 200,
            }),
          ],
        }),
      }),
    })
  );
}
function p_(n) {
  return ce.jsx(Xb, {
    className:
      "py-3 px-4 block items-center gap-x-2 text-sm font-semibold rounded-lg border border-transparent bg-white text-gray-800 hover:bg-gray-200 disabled:opacity-50 disabled:pointer-events-none dark:focus:outline-none dark:focus:ring-1 dark:focus:ring-gray-600",
    ...n,
  });
}
function rG({ isCompareRoute: n }) {
  const e = vr();
  function t(i) {
    return n
      ? { location: e.location.search.location, location2: i }
      : { location: i, location2: e.location.search.location2 };
  }
  return ce.jsxs(mf, {
    className: "p-2",
    children: [
      ce.jsx("h3", {
        className: "text-lg font-bold",
        children: "Enter a location above ",
      }),
      ce.jsx("p", {
        className: "text-sm font-bold mb-2",
        children: "or select a location to get started!",
      }),
      ce.jsxs("div", {
        className: "grid grid-cols-3 gap-2",
        children: [
          ce.jsx(p_, { search: t("40.7127753,-74.0059728"), children: "NYC" }),
          ce.jsx(p_, {
            search: t("33.748752,-84.38768449999999"),
            children: "ATL",
          }),
          ce.jsx(p_, { search: t("51.4679914,-0.455051"), children: "LHR" }),
        ],
      }),
    ],
  });
}
const sh = {
    Inconsequential: "Inconsequential",
    Mild: "Mild",
    Extreme: "Extreme",
  },
  sG = {
    cloud_cover: [20, 50],
    precipitation: [2, 10],
    snowfall: [2, 5],
    temperature_2m: [3, 6],
    uvIndex: [2, 5],
    wind_speed_10m: [10, 20],
  };
function oG(n, e, t) {
  if (!t || !n || !e) return "";
  const i = Math.abs(n - e),
    r = sG[t];
  return r != null && r.length
    ? i <= r[0]
      ? sh.Inconsequential
      : i <= r[1]
        ? sh.Mild
        : sh.Extreme
    : "";
}
function aG({ weather: n, compareLocation: e = null }) {
  const { data: t } = d2(e),
    i = Object.keys(n == null ? void 0 : n.current).filter(
      (r) =>
        r !== "time" &&
        r !== "interval" &&
        r !== "is_day" &&
        r !== "wind_direction_10m" &&
        r !== "weather_code",
    );
  return ce.jsx(mf, {
    children: ce.jsx("div", {
      className:
        "flex text-center flex-col items-center p-4 gap-2 lg:grid lg:grid-cols-3 lg:gap-4",
      children: i.map((r) => {
        var s, o;
        return ce.jsx(
          lG,
          {
            compareWeather: (t == null ? void 0 : t.current) ?? null,
            objKey: r,
            tempUnit: r.includes("temp")
              ? (s = n == null ? void 0 : n.current_units) == null
                ? void 0
                : s.temperature_2m
              : r.includes("wind")
                ? (o = n == null ? void 0 : n.current_units) == null
                  ? void 0
                  : o.wind_speed_10m
                : "",
            weather: n,
          },
          r,
        );
      }),
    }),
  });
}
function lG({ compareWeather: n, objKey: e, tempUnit: t, weather: i }) {
  const r = e.replace(/_/g, " ").replace(/[0-9]+m/g, ""),
    s = i == null ? void 0 : i.current[e],
    o = r.includes("speed"),
    a = i == null ? void 0 : i.current[e],
    u = n ? n[e] : 0,
    h = oG(a, u, e),
    p = se.useMemo(
      () =>
        h === sh.Extreme
          ? "scale-150 drop-shadow-[0_2px_2px_rgba(255,0,0,0.4)]"
          : h === sh.Mild
            ? "scale-125 drop-shadow-[0_2px_2px_rgba(255,255,0,0.4)]"
            : "scale-100",
      [h],
    );
  return ce.jsxs("div", {
    className: `flex flex-col items-center ${p} rounded-lg`,
    children: [
      ce.jsxs("span", {
        className: "capitalize",
        children: [o ? "Wind" : r, ":"],
      }),
      o
        ? ce.jsxs("span", {
            className: "flex flex-row gap-2",
            children: [
              ce.jsxs("span", {
                className: "font-bold",
                children: [
                  i.current.wind_speed_10m,
                  " ",
                  !!t && ce.jsx("span", { children: t }),
                ],
              }),
              ce.jsx("span", {
                className: "block font-bold text-xl",
                style: { rotate: `${i.current.wind_direction_10m}deg` },
                children: "",
              }),
            ],
          })
        : ce.jsxs("span", {
            className: "font-bold",
            children: [s, " ", !!t && ce.jsx("span", { children: t })],
          }),
    ],
  });
}
const m_ = "168px";
function $L({
  compareLocation: n = null,
  header: e = null,
  isCompareRoute: t,
  selectedLocation: i,
  setSelectedLocation: r,
}) {
  const s = AS(),
    { data: o, isLoading: a, isError: u, error: h } = d2(i),
    p = se.useMemo(() => {
      var m;
      return {
        weatherCode: (o == null ? void 0 : o.current.weather_code) ?? 0,
        isDaytime:
          o != null && o.current
            ? ((m = o == null ? void 0 : o.current) == null
                ? void 0
                : m.is_day) === 1
            : !0,
      };
    }, [o]),
    { isRain: v, isDay: y } = se.useMemo(() => {
      var m, g;
      return {
        isDay:
          ((m = o == null ? void 0 : o.current) == null ? void 0 : m.is_day) !==
          0,
        isRain: !!(
          (g = o == null ? void 0 : o.current) != null && g.precipitation
        ),
      };
    }, [o]),
    { backgroundColor: S } = tU(p),
    { location: x, error: _ } = nU(i),
    f = se.useMemo(
      () => (y ? (v ? "#8C9EA3" : "#F0F0F0") : v ? "#8C9EA3" : "#323A48"),
      [y, v],
    ),
    d = se.useMemo(() => `opacity-${y ? "30" : "90"}`, [y]);
  return (
    se.useEffect(() => {
      u && Ng.error(h == null ? void 0 : h.message, { id: "weather-error" });
    }, [u, h]),
    se.useEffect(() => {
      _ &&
        (Ng.error(_ == null ? void 0 : _.message, { id: "place-error" }),
        s({ to: "/forecast" }));
    }, [_]),
    ce.jsxs("section", {
      className:
        "text-center px-2 lg:px-6 py-2 relative h-full overflow-y-auto",
      style: { backgroundColor: S },
      children: [
        e,
        ce.jsxs("div", {
          className: "relative z-10  flex flex-col gap-4",
          children: [
            ce.jsx("div", {
              className: "w-[500px] max-w-full mx-auto",
              children: ce.jsx(Vk, {
                onSelection: r,
                value: x == null ? void 0 : x.label,
              }),
            }),
            !!i &&
              !o &&
              a &&
              ce.jsx(mf, {
                className: "bg-slate-900 bg-opacity-70 pb-4",
                children: ce.jsxs("figure", {
                  className: "text-center",
                  children: [
                    ce.jsx("img", {
                      alt: "Weather icon",
                      src: "/weather/clear-day-fast.svg",
                      className: "mx-auto",
                      style: { height: m_, width: m_ },
                    }),
                    ce.jsx("figcaption", {
                      className: "block text-white italic",
                      children: "Loading...",
                    }),
                  ],
                }),
              }),
            !!i &&
              !!o &&
              !a &&
              ce.jsxs(ce.Fragment, {
                children: [
                  ce.jsxs("div", {
                    className: "flex flex-col gap-4 justify-center lg:flex-row",
                    children: [
                      ce.jsx(Wk, {
                        imageSize: m_,
                        isLoading: a,
                        place: x,
                        weather: o,
                      }),
                      ce.jsx(aG, { compareLocation: n, weather: o }),
                    ],
                  }),
                  ce.jsx(Kk, { selectedLocation: i }),
                ],
              }),
            !i && ce.jsx(rG, { isCompareRoute: t }),
          ],
        }),
        ce.jsx("div", {
          className: `${d} fixed inset-0 z-[1]`,
          children: ce.jsx(eG, { bgColor: S, cloudColor: f, rain: v }),
        }),
      ],
    })
  );
}
function uG(n) {
  const e = AS();
  function t() {
    return (
      Ng.error("Invalid lat/long", { id: "invalid-lat-long" }),
      e({ to: "/forecast", replace: !0, search: !1 }),
      !1
    );
  }
  if (!n) return !0;
  const i = n == null ? void 0 : n.split(",")[0],
    r = n == null ? void 0 : n.split(",")[1];
  if (!i || !r) return t();
  const s = /^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)$/,
    o = /^[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$/;
  return !s.test(i) || !o.test(r) ? t() : !0;
}
const YL = () => {
  const n = vr(),
    e = AS(),
    t = new URLSearchParams(n.location.searchStr),
    i = location.pathname.includes("compare"),
    r = t.get("location"),
    s = se.useMemo(() => hb(r), [r]),
    o = t.get("location2"),
    a = se.useMemo(() => hb(o), [o]);
  uG(t.get("location"));
  const u = (p) => {
      typeof p == "object" && (p = `${p.latitude},${p.longitude}`);
      const y = new URLSearchParams(window.location.search).get("location2"),
        S = { location: p };
      y && (S.location2 = y),
        e({ to: n.location.pathname, search: S, replace: !0 });
    },
    h = (p) => {
      typeof p == "object" && (p = `${p.latitude},${p.longitude}`),
        e({
          to: n.location.pathname,
          search: { location: r, location2: p },
          replace: !0,
        });
    };
  return se.useMemo(
    () => ({
      location1: s,
      location2: a,
      setLocation: u,
      setLocationForCompare: h,
      isCompareRoute: i,
    }),
    [r, o, i],
  );
};
function hb(n) {
  if (!n) return null;
  const [e, t] = n.split(",");
  return e && t ? { latitude: parseFloat(e), longitude: parseFloat(t) } : null;
}
const cG = Ib.memo(() => {
    const n = vr();
    return ce.jsxs("a", {
      className:
        "relative inline-flex overflow-hidden rounded-3xl p-[4px] hover:ring-2 hover:ring-orange-200 hover:ring-offset-4 focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-offset-4 focus:ring-offset-orange-50",
      href: "/forecast/compare" + n.location.searchStr,
      children: [
        ce.jsx("span", {
          className:
            "absolute inset-[-1000%] animate-[spin_2s_linear_infinite] bg-[conic-gradient(from_90deg_at_50%_50%,#FF4500_0%,#FFA500_50%,#FFFF00_100%)]",
        }),
        ce.jsxs("span", {
          className:
            "inline-flex h-full w-full cursor-pointer items-center justify-center rounded-3xl bg-white px-3 py-2 font-medium text-black backdrop-blur-3xl hover:font-semibold",
          children: [
            ce.jsx("span", {
              className: "inline-block whitespace-nowrap",
              children: "Compare two locations",
            }),
            ce.jsxs("svg", {
              className: "flex-shrink-0 size-4",
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                ce.jsx("path", { d: "M5 12h14" }),
                ce.jsx("path", { d: "m12 5 7 7-7 7" }),
              ],
            }),
          ],
        }),
      ],
    });
  }),
  dG = () => {
    const { location1: n, setLocation: e, isCompareRoute: t } = YL();
    return ce.jsx("div", {
      className: "relative z-20 text-center h-full",
      children: ce.jsxs("div", {
        className:
          "outline-4 outline-amber-600 grid grid-rows-1 grid-cols-2 h-full",
        children: [
          ce.jsx("div", {
            className: `column-1 ${t ? "col-span-1" : "col-span-2"}`,
            children: ce.jsx($L, {
              header:
                !t &&
                ce.jsx("div", {
                  className: "relative z-20 mb-4",
                  children: ce.jsx(cG, {}),
                }),
              selectedLocation: n,
              setSelectedLocation: e,
            }),
          }),
          ce.jsx("div", { className: "column-2", children: ce.jsx(jb, {}) }),
        ],
      }),
    });
  },
  hG = bS("/forecast")({ component: dG }),
  fG = () =>
    ce.jsxs("div", {
      className:
        "bg-blue-300 font-bold w-screen h-screen flex flex-col justify-center items-center ",
      children: [
        ce.jsx("p", {
          className: "mb-4 text-white text-6xl",
          children: "Hello, world!",
        }),
        ce.jsx("p", {
          children: ce.jsx(Xb, {
            className: "font-normal text-blue-800 underline",
            to: "/forecast",
            children: "View forecast",
          }),
        }),
      ],
    }),
  pG = bS("/")({ component: fG }),
  mG = () => {
    const { location1: n, location2: e, setLocationForCompare: t } = YL();
    return ce.jsx("div", {
      className: "h-full",
      children: ce.jsx($L, {
        isCompareRoute: !0,
        compareLocation: n,
        selectedLocation: e,
        setSelectedLocation: t,
      }),
    });
  },
  gG = bS("/forecast/compare")({ component: mG }),
  KL = hG.update({ path: "/forecast", getParentRoute: () => Sw }),
  vG = pG.update({ path: "/", getParentRoute: () => Sw }),
  yG = gG.update({ path: "/compare", getParentRoute: () => KL }),
  _G = Sw.addChildren([vG, KL.addChildren([yG])]);
const xG = J3({
    routeTree: _G,
    context: { queryClient: l2 },
    defaultPreload: "intent",
    defaultPreloadStaleTime: 0,
  }),
  fb = document.querySelector("#root");
fb.innerHTML ||
  v_
    .createRoot(fb)
    .render(ce.jsx(Ib.StrictMode, { children: ce.jsx(Hk, { router: xG }) }));
